/* REXX */
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Name            : XEDIT                                          **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw (george_klauw@nl.ibm.com) **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Edit multiple TSO datasets, member-lists,      **/
/**                   and dataset-lists in a ring.                   **/
/**                   Most of the commands are the same as for       **/
/**                   XEDIT on VM (see the help-function for a list  **/
/**                   and explanation of all supported commands).    **/
/**                                                                  **/
/** Install         : ALTLIB ACTIVATE APPLICATION(EXEC) +            **/
/**                          DA('vb255.execlib.that.contains.XEDIT') **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy Description                                             **/
/** ======== ======================================================= **/
/** 31/08/94 Add prefix commands LC, LLC, UC and UUC                 **/
/** 09/09/94 Add command XXedit to support ISPF libraries            **/
/** 09/09/94 Allow a wild card ('*') for member-list specification   **/
/** 09/11/94 Add command DELETELines to delete selected lines        **/
/** 12/01/95 Add commands TAB, TABS, TABLINE                         **/
/** 20/03/95 Implement keylists                                      **/
/** 18/11/95 Implement horizontal editing                            **/
/** 01/23/19 Option to bypass PIPEs when not installed               **/
/**          Option to bypass RACF authority checking                **/
/**          LOADIspf/DROPIsp for XEDIT panels, messages, and tables **/
/**          XEDIT tables added as >Skel members (ISPTlib)           **/
/**          Add command VIEW for ISPF View                          **/
/**          Change variable from cmd to cmd1; When ABBREV('SDSF'... **/
/**          Change CMD(%RZAELGC) to PGM(ISFISP) for SDSF command    **/
/**          Fix variable names in XEDITRNG panel                    **/
/**          Add ending rexx comment to XEDHELP3 (cc 81) [LoadISPF]  **/
/**          Spell check HELP panels                                 **/
/**********************************************************************/
 
Parse Source . invoc ident . XeditDset XeditDD .
 
Parse Upper Arg parms ' (' options
If parms = '' Then
  parms = userid()'.*'
 
Signal On Syntax
Signal On Failure
Signal On Halt
 
 
InterpretTest = 'Yes'
Interpret 'InterpretSupported = "Yes"'
InterpretTest = 'No'
 
ContinueAfterInterpretTest:
 
If Sysvar(SYSISPF) ^= 'ACTIVE' Then
Do
  Say 'XEDIT can only be invoked when ISPF is active'
  Exit 4
End
 
Racf  = 0               /* 1=RACF check, 0=No RACF check            */
Pipes = 1               /* 1=Pipes installed, 0=Pipes not installed */
load_info = loadispf()  /* Lionel B Dyck inline panels, messages    */
 
Call initializations
 
If parms = '?' Then
Do
  ISPFcmd = 'help'
  cmdbuf = ''
  cmdlen = 100
  Address ISPEXEC 'VPUT (HELPCMD, DUMMYBUF, DUMMYLEN)'
  Address ISPEXEC 'DISPLAY PANEL(XEDIT) COMMAND(ISPFCMD)',
                  'RETBUFFR(CMDBUF) RETLGTH(CMDLEN)'
  x = dropispf(load_info);Exit
End
Else
Do
  If substr(parms,1,1) = '.' Then
    dataset = userid()||parms
  Else
    dataset = parms
End
 
Call GetDataset dataset
If result ^= 0 Then
Do
  If invoc = 'COMMAND' Then
  Do
    Say msg
    x = dropispf(load_info);Exit
  End
  Else
    Do
      x = dropispf(load_info);Exit msg
    End
End
SaveMsg = msg
 
cmd = 'XEXEC 'userid()'.XEDIT.PROFILE'
Call HandleCommand
Call HandleQueuedCommands
 
msg = SaveMsg
 
Do While NrRing > 0
ContinueAfterError:
  trace off
  MsgDisplayed = 'No'
  If xtype = 'DLIST' Then
    scale = ScaleOut||Substr('Dataset',1,44)' Org  Fm Lrecl Tracks %Us XT Volume'
  Else
  Do
    If xtype = 'DIR' Then
    Do
      If statistics = 'OFF' Then
        scale = ScaleOut'Member    Member    Member    Member    '||,
                        'Member    Member    Member    Member    '
      Else
        Scale = ScaleOut||Substr('Member',1,18)||,
        ' Lib Mod    Created   Modified  Time    Size    Init     User'
    End
    Else                               /* xtype = FILE                */
    Do
      scale = FullScale
      If tabline = 'ON' Then
      Do i = 1 to Words(tabs) while Word(tabs,i) <= lrecl
        scale = Overlay('T',scale,Word(tabs,i))
      End
      If CurCol >= StartCol & CurCol < StartCol+73 Then
        scale = Overlay('|',Substr(scale,StartCol,73),Curcol-Startcol+1)
      Else
        scale = Substr(scale,StartCol,73)
      If horizontal = 'ON' Then
        ScaleInOut = ScaleIn
      Else
        ScaleInOut = ScaleOut
 
      PrevScale = Scale
 
      If HorCmd = '?' Then
      Do i = 1 to Length(PrevHorCmd)
        If Substr(PrevHorCmd,i,1) ^= '' Then
          scale = Overlay(Substr(PrevHorCmd,i,1),scale,i)
      End
 
      If XPrefix = 'LEFT' Then
        scale = ScaleOut'     'ScaleInOut||scale
      Else
        scale = ScaleInOut||Scale||ScaleOut'     '
    End
  End
  If msg ^= '' Then
  Do
    MsgC = Word(MsgA,1)
    MsgH = Word(MsgA,2)
    scale = ScaleOut||msg
    MsgDisplayed = 'Yes'
  End
  Else
  Do
    MsgC = Word(ScaleA,1)
    MsgH = Word(ScaleA,2)
  End
  Address ISPEXEC 'VPUT (SCALE)'
  msg = ''
  If nulls = 'OFF' Then
    padc = ' '
  Else
    padc = 'NULLS'
 
  ArrowC   = word(ArrowA,1)
  CmdC     = word(CmdA,1)
  IDlineC  = word(IDlineA,1)
  ScaleC   = word(ScaleA,1)
  TofC     = word(TofA,1)
  FileC    = word(FileA,1)
  PrefixC  = word(PrefixA,1)
  MemberC  = word(MemberA,1)
  DatasetC = word(DatasetA,1)
  PFkeysC  = word(PFkeysA,1)
  Address ISPEXEC 'VPUT (ArrowC, Cmdc, IDlineC, FileC, PrefixC,' ||,
                        'ScaleC, TofC, MemberC, DatasetC, PFkeysC)'
  ArrowH  = word(ArrowA,2)
  CmdH    = word(CmdA,2)
  IDlineH = word(IDlineA,2)
  ScaleH  = word(ScaleA,2)
  TofH    = word(TofA,2)
  FileH   = word(FileA,2)
  PrefixH = word(PrefixA,2)
  MemberH = word(MemberA,2)
  DatasetH= word(DatasetA,2)
  PFkeysH = word(PFkeysA,2)
  Address ISPEXEC 'VPUT (ArrowH, CmdH, IDlineH, FileH, PrefixH,' ||,
                        'ScaleH, TofH, MemberH, DatasetH, PFkeysH)'
 
  Parse var timezone sign hh ':' mm
  hh = sign||hh
  mm = sign||mm
  CurTime = Substr(Time(),1,5)
  Parse var CurTime Curhh ':' Curmm
  Curhh = Curhh + hh
  Curmm = Curmm + mm
  If Curmm < 0 Then
  Do
    Curmm = Curmm+60
    Curhh = Curhh-1
  End
  If Curmm > 59 Then
  Do
    Curmm = Curmm-60
    Curhh = Curhh+1
  End
  If Curhh < 0 Then Curhh = Curhh+24
  If Curhh > 23 Then Curhh = Curhh-24
  CurTime = Right(100+Curhh,2)':'Right(100+Curmm,2)
 
  Select
    When xtype = 'DLIST' Then
      Call DisplayXEDITDS
    When xtype = 'DIR' Then
      Call DisplayXEDITDIR
    Otherwise                          /* xtype = FILE                */
      Call DisplayXEDIT
  End                                  /* end select                  */
 
  If cursor ^= 'CMD' Then
  Do
    SaveCursor = Cursor
    SaveCsrpos = Csrpos
  End
 
  If cmd ^= '' & cmd ^= '=' Then
  Do
    SaveCmd = cmd
    Call SaveRecallCmd
  End
 
  KeepCommand = 'Off'
  If substr(cmd,1,1) = '&' Then
  Do
    cmd = substr(cmd,2)
    KeepCommand = 'On'
  End
 
  CommandIssued = 'No'
 
  If xtype = 'FILE' Then
    Call HandleXEDITpfkeys
  Else                                 /* xtype = DIR or DSLIST       */
    Call Handle_XEDITDS_and_XEDITDIR_pfkeys
 
  If cmd ^= '' Then
  Do
    CommandIssued = 'Yes'
 
    Call HandleCommand
  End
 
  Call HandleQueuedCommands
 
  If KeepCommand = 'On' Then
  Do
    cmd = SaveCmd
    Address ISPEXEC 'VPUT (CMD)'
  End
  Else
  Do
    cmd = ''
    Address ISPEXEC 'VPUT (CMD)'
  End
 
  If autosave > 0 & alt >= autosave Then
    Call AutosaveDset
 
End
 
R1  = RecallCmd.1;           R51 = RecallCmd.51
R2  = RecallCmd.2;           R52 = RecallCmd.52
R3  = RecallCmd.3;           R53 = RecallCmd.53
R4  = RecallCmd.4;           R54 = RecallCmd.54
R5  = RecallCmd.5;           R55 = RecallCmd.55
R6  = RecallCmd.6;           R56 = RecallCmd.56
R7  = RecallCmd.7;           R57 = RecallCmd.57
R8  = RecallCmd.8;           R58 = RecallCmd.58
R9  = RecallCmd.9;           R59 = RecallCmd.59
R10 = RecallCmd.10;          R60 = RecallCmd.60
R11 = RecallCmd.11;          R61 = RecallCmd.61
R12 = RecallCmd.12;          R62 = RecallCmd.62
R13 = RecallCmd.13;          R63 = RecallCmd.63
R14 = RecallCmd.14;          R64 = RecallCmd.64
R15 = RecallCmd.15;          R65 = RecallCmd.65
R16 = RecallCmd.16;          R66 = RecallCmd.66
R17 = RecallCmd.17;          R67 = RecallCmd.67
R18 = RecallCmd.18;          R68 = RecallCmd.68
R19 = RecallCmd.19;          R69 = RecallCmd.69
R20 = RecallCmd.20;          R70 = RecallCmd.70
R21 = RecallCmd.21;          R71 = RecallCmd.71
R22 = RecallCmd.22;          R72 = RecallCmd.72
R23 = RecallCmd.23;          R73 = RecallCmd.73
R24 = RecallCmd.24;          R74 = RecallCmd.74
R25 = RecallCmd.25;          R75 = RecallCmd.75
R26 = RecallCmd.26;          R76 = RecallCmd.76
R27 = RecallCmd.27;          R77 = RecallCmd.77
R28 = RecallCmd.28;          R78 = RecallCmd.78
R29 = RecallCmd.29;          R79 = RecallCmd.79
R30 = RecallCmd.30;          R80 = RecallCmd.80
R31 = RecallCmd.31;          R81 = RecallCmd.81
R32 = RecallCmd.32;          R82 = RecallCmd.82
R33 = RecallCmd.33;          R83 = RecallCmd.83
R34 = RecallCmd.34;          R84 = RecallCmd.84
R35 = RecallCmd.35;          R85 = RecallCmd.85
R36 = RecallCmd.36;          R86 = RecallCmd.86
R37 = RecallCmd.37;          R87 = RecallCmd.87
R38 = RecallCmd.38;          R88 = RecallCmd.88
R39 = RecallCmd.39;          R89 = RecallCmd.89
R40 = RecallCmd.40;          R90 = RecallCmd.90
R41 = RecallCmd.41;          R91 = RecallCmd.91
R42 = RecallCmd.42;          R92 = RecallCmd.92
R43 = RecallCmd.43;          R93 = RecallCmd.93
R44 = RecallCmd.44;          R94 = RecallCmd.94
R45 = RecallCmd.45;          R95 = RecallCmd.95
R46 = RecallCmd.46;          R96 = RecallCmd.96
R47 = RecallCmd.47;          R97 = RecallCmd.97
R48 = RecallCmd.48;          R98 = RecallCmd.98
R49 = RecallCmd.49;          R99 = RecallCmd.99
R50 = RecallCmd.50;
 
Address ISPEXEC 'VPUT ('AllR') PROFILE'
 
x = dropispf(load_info);Exit
 
 
 
DisplayXEDITDS:                        /* fill dataset list panel     */
trace off
  PFkeys = '1=Help 2=Rep 3=Quit 4=Del 5=Refresh 6=Ren '||,
           '7=Up 8=Down 9=Top 10=IC 11=Xed 12=Bot'
  header = Substr(Substr(curring':'dataset,1,42),
          'Dataset 'curline' to 'Min(curline+vdepth-1,Size)' of 'Size,1,73),
          CurTime
  Address ISPEXEC 'VPUT (HEADER,PFKEYS)'
  If curline > size Then
    curline = max(1,size-Vdepth)
  j = 1
  DAxedit = ''
  Do i = curline to curline+ZscreenD-4
    If i > size Then
      DAxedit = DAxedit||DatasetOut||Substr('',1,79)
    Else
      DAxedit = DAxedit||DatasetIn||Substr(Line.i,1,79)
    j = j+1
  End
  If alt = SaveAlt & pfkey = '' & CommandIssued ^= 'Yes' Then
  Do                                   /* nothing done!               */
    If cursor ^= 'CMD' Then
    Do
      cursor = 'CMD'
      csrpos = 1
    End
    Else
    Do
      Cursor = SaveCursor
      Csrpos = SaveCsrpos
    End
  End
  Else
  Do
    If cursor = 'DAXEDIT' Then
    Do
      CursorLine = Min(Vdepth,CursorLine)
      csrpos = (CursorLine-1)*80+Min(CursorPos,79)+1
    End
    Else
    Do
      Cursor = 'CMD'
      csrpos = '1'
    End
  End
 
  SavedDAxedit = DAxedit
 
  Address ISPEXEC 'VPUT (CURSOR,CSRPOS,DAXEDIT)'
  Address ISPEXEC 'DISPLAY PANEL(XEDIT)'
  If rc > 8 Then
  Do
    If symbol('ZERRLM') = 'VAR' & zerrlm ^= '' Then
    Do
      If ZERRLM = 'PANEL NOT FOUND' Then
      Do
        Say 'XEDIT panel library not installed correctly'
        Exit 8
      End
      Else
        Say 'ISPF error: 'ZERRLM',cursor='cursor', csrpos='csrpos
    End
    cursor = 'DAXEDIT'
    csrpos = '2'
    Address ISPEXEC 'VPUT (CURSOR,CSRPOS)'
    Address ISPEXEC 'DISPLAY PANEL(XEDIT)'
    If rc ^= 0 Then
      pfkey = 'PF03'
  End
  Address ISPEXEC 'VGET (CMD,PFKEY,CURSOR,CSRPOS,DAXEDIT,VDEPTH)'
  DAxedit = DAxedit||Substr(SavedDAxedit,Length(DAxedit)+1)
  cursor = strip(cursor)
  If cursor = 'DAXEDIT' Then
  Do
    If csrpos//80 = 1 Then             /* on attribute character      */
      csrpos = csrpos+1
    CursorPos  = (csrpos-1)//80
    CursorLine = (csrpos-1)%80+1
    CursorArea = 'File'
  End
  Else
    CursorArea = cursor
 
  SaveAlt = alt
 
  Do j = 1 to ZscreenD-4
    SL.j = Substr(DAxedit,(j-1)*80+2,79)
  End
Return
 
 
 
DisplayXEDITDIR:                       /* fill directory list panel   */
trace off
  PFkeys = '1=Help 2=Rep 3=Quit 4=Del 5=Refresh 6=Ren '||,
           '7=Up 8=Down 9=Top 10=IC 11=Xed 12=Bot'
  If statistics = 'OFF' Then
    header = Substr(Substr(curring':'dataset,1,42) RecFm Lrecl,
            'Member 'Curline' to 'Min(Curline+Vdepth*8-1,Size)' of 'Size,1,73),
            Curtime
  Else
    header = Substr(Substr(curring':'dataset,1,42) RecFm Lrecl,
            'Member 'Curline' to 'Min(Curline+Vdepth-1,Size)' of 'Size,1,73),
            CurTime
  Address ISPEXEC 'VPUT (HEADER,PFKEYS)'
  DAxedit = ''
  If statistics = 'OFF' Then
  Do
    If curline > size Then
      curline = max(1,size-Vdepth*8)
    j = 1
    Do i = curline to curline+(ZscreenD-4)*8
      If i > size Then
        SL.j = MemberOut||Substr('',1,9)
      Else
        SL.j = MemberIn||Substr(line.i,1,9)
      j = j+1
    End
    Do j = 1 to ZscreenD-4
      i = j
      DAxedit = DAxedit||SL.i
      i = j+(ZscreenD-4)*1
      DAxedit = DAxedit||SL.i
      i = j+(ZscreenD-4)*2
      DAxedit = DAxedit||SL.i
      i = j+(ZscreenD-4)*3
      DAxedit = DAxedit||SL.i
      i = j+(ZscreenD-4)*4
      DAxedit = DAxedit||SL.i
      i = j+(ZscreenD-4)*5
      DAxedit = DAxedit||SL.i
      i = j+(ZscreenD-4)*6
      DAxedit = DAxedit||SL.i
      i = j+(ZscreenD-4)*7
      DAxedit = DAxedit||SL.i
    End
  End
  Else
  Do
    If curline > size Then
      curline = max(1,Size-Vdepth)
    j = 1
    Do i = curline to curline+ZscreenD-4
      If i > size Then
        SL.j = MemberOut||Substr('',1,79)
      Else
        SL.j = MemberIn||Substr(line.i,1,79)
      j = j+1
    End
    Do j = 1 to ZscreenD-4
      DAxedit = DAxedit||SL.j
    End
  End
 
  If alt = SaveAlt & pfkey = '' & CommandIssued ^= 'Yes' Then
  Do                                   /* nothing done!               */
    If cursor ^= 'CMD' Then
    Do
      cursor = 'CMD'
      csrpos = 1
    End
    Else
    Do
      Cursor = SaveCursor
      Csrpos = SaveCsrpos
    End
  End
  Else
  Do
    If cursor = 'DAXEDIT' Then
    Do
      If statistics = 'OFF' Then
      Do
        CursorLine = Min((Zscreend-4)*8,CursorLine)
        csrpos = ((CursorLine-1)//(ZscreenD-4))*80+,
                 ((CursorLine-1)%(ZscreenD-4))*10+Min(CursorPos,9)+1
      End
      Else
      Do
        CursorLine = Min(Vdepth,CursorLine)
        csrpos = (CursorLine-1)*80+Min(CursorPos,79)+1
      End
    End
    Else
    Do
      Cursor = 'CMD'
      csrpos = '1'
    End
  End
  SavedDAxedit = DAxedit
 
  Address ISPEXEC 'VPUT (CURSOR,CSRPOS,DAXEDIT)'
  Address ISPEXEC 'DISPLAY PANEL(XEDIT)'
  If rc > 8 Then
  Do
    If symbol('ZERRLM') = 'VAR' & zerrlm ^= '' Then
    Do
      If ZERRLM = 'PANEL NOT FOUND' Then
      Do
        Say 'XEDIT panel library not installed correctly'
        Exit 8
      End
      Else
        Say 'ISPF error: 'ZERRLM',cursor='cursor', csrpos='csrpos
    End
    cursor = 'DAXEDIT'
    csrpos = '2'
    Address ISPEXEC 'VPUT (CURSOR,CSRPOS)'
    Address ISPEXEC 'DISPLAY PANEL(XEDIT)'
    If rc ^= 0 Then
      pfkey = 'PF03'
  End
  Address ISPEXEC 'VGET (CMD,PFKEY,CURSOR,CSRPOS,DAXEDIT,VDEPTH)'
  DAxedit = DAxedit||Substr(SavedDAxedit,Length(DAxedit)+1)
  cursor = strip(cursor)
  If cursor = 'DAXEDIT' Then
  Do
    If statistics = 'OFF' Then
    Do
      If csrpos//10 = 1 Then           /* on attribute character      */
        csrpos = csrpos+1
      CursorPos  = (csrpos-1)//10
      CursorLine = (((csrpos-1)//80)%10*(ZscreenD-4))+(csrpos-1)%80+1
    End
    Else
    Do
      If csrpos//80 = 1 Then           /* on attribute character      */
        csrpos = csrpos+1
      CursorPos  = (csrpos-1)//80
      CursorLine = (csrpos-1)%80+1
    End
    CursorArea = 'File'
  End
  Else
    CursorArea = cursor
 
  SaveAlt = alt
 
  If statistics = 'OFF' Then
  Do
    Do j = 1 to ZscreenD-4
      i = j
      SL.i = Substr(DAxedit,(j-1)*80+2,9)
      i = j+(ZscreenD-4)*1
      SL.i = Substr(DAxedit,(j-1)*80+12,9)
      i = j+(ZscreenD-4)*2
      SL.i = Substr(DAxedit,(j-1)*80+22,9)
      i = j+(ZscreenD-4)*3
      SL.i = Substr(DAxedit,(j-1)*80+32,9)
      i = j+(ZscreenD-4)*4
      SL.i = Substr(DAxedit,(j-1)*80+42,9)
      i = j+(ZscreenD-4)*5
      SL.i = Substr(DAxedit,(j-1)*80+52,9)
      i = j+(ZscreenD-4)*6
      SL.i = Substr(DAxedit,(j-1)*80+62,9)
      i = j+(ZscreenD-4)*7
      SL.i = Substr(DAxedit,(j-1)*80+72,9)
    End
  End
  Else
  Do
    Do j = 1 to ZscreenD-4
      SL.j = Substr(DAxedit,(j-1)*80+2,79)
    End
  End
Return
 
 
 
DisplayXEDIT:                          /* fill file panel             */
trace off
  PFkeys = PFkeyLine
  header = Substr(Substr(curring':'dataset,1,48) RecFm Lrecl,
          'Size='Size' Alt='alt,1,73) CurTime
  Address ISPEXEC 'VPUT (HEADER,PFKEYS)'
  If curline > size+1 Then
    curline = max(0,size-Vdepth-1)
  j = curline-1
  DAxedit = ''
  Do i = 1 to ZscreenD
    j = j+1
    LineNr = right(j,5)
    Select
      When j = 0 Then
      Do
        If XPrefix = 'LEFT' Then
          DAxedit = DAxedit||PrefixOut||LineNr||,
                    TofOut||Substr('* * * Top of File * * *',1,73)
        Else
          DAxedit = DAxedit||TofOut||Substr('* * * Top of File * * *',1,73)||,
                    PrefixOut||LineNr
      End
      When j = size+1 Then
      Do
        If XPrefix = 'LEFT' Then
          DAxedit = DAxedit||PrefixOut||LineNr||,
                    TofOut||Substr('* * * End of File * * *',1,73)
        Else
          DAxedit = DAxedit||TofOut||Substr('* * * End of File * * *',1,73)||,
                    PrefixOut||LineNr
      End
      When j <= size Then
      Do
        If command.j ^= '' Then
        Do
          Pcmd = command.j
          Parse var Pcmd Pcnt1'|'Pcmd'|'Pcnt2
          If Pcnt2 > 1 Then  Pcmd = Pcmd||Pcnt2
          If Pcnt1 > 1 Then  Pcmd = Pcnt1||Pcmd
          prefix = PrefixIn||Substr(Pcmd,1,5)
        End
        Else
          Prefix = PrefixIn||right(j,5)
 
        DataLine = Substr(line.j,StartCol,73)
        InLine = DataLine              /* remove non-displayables     */
        OutLine = ''
        Do until Inline == ''
          y = verify(Inline,Displayable,'Nomatch')
          If y > 0 Then
          Do
            Outline = Outline||Substr(Inline,1,y-1)
            Inline = Substr(Inline,y)
            x = verify(Inline,Displayable,'match')
            If x > 2 Then              /* more than one non-displ.    */
            Do
              Outline = Outline||FileOut||Substr('',1,x-3,'.')||FileIn
              Inline = Substr(Inline,x)
            End
            Else                       /* only one non-displayable    */
            Do
              Outline = Outline||FileIn
              Inline = Substr(Inline,2)
            End
          End
          Else
          Do
            Outline = Outline||Inline
            Inline = ''
          End
        End
        If Lrecl < 73 Then
          OutLine = Substr(OutLine,1,lrecl)||FileOut||,
                    Substr('',1,72-lrecl)
        If XPrefix = 'LEFT' Then
          DAxedit = DAxedit||Prefix||FileIn||OutLine
        Else
          DAxedit = DAxedit||FileIn||OutLine||Prefix
 
        If hex = 'ON' Then
        Do
          HexLine = c2x(DataLine)
          line1 = ''
          line2 = ''
          Do k = 1 to 73
            line1 = line1||substr(HexLine,(k-1)*2+1,1)
            line2 = line2||substr(HexLine,k*2,1)
          End
          If Lrecl < 73 Then
          Do
            Line1 = Substr(line1,1,lrecl)||FileOut||,
                    Substr('',1,72-lrecl)
            Line2 = Substr(line2,1,lrecl)||FileOut||,
                    Substr('',1,72-lrecl)
          End
          If XPrefix = 'LEFT' Then
          Do
            DAxedit = DAxedit||PrefixOut||'     '||FileIn||Line1
            DAxedit = DAxedit||PrefixOut||'     '||FileIn||Line2
          End
          Else
          Do
            DAxedit = DAxedit||FileIn||Line1||PrefixOut||'     '
            DAxedit = DAxedit||FileIn||Line2||PrefixOut||'     '
          End
          i = i+2
        End
      End
      Otherwise                        /* after End of File           */
        DAxedit = DAxedit||PrefixOut||Substr('',79)
    End
  End
  If alt = SaveAlt & pfkey = '' & CommandIssued ^= 'Yes' Then
  Do                                   /* nothing done!               */
    If cursor ^= 'CMD' Then
    Do
      cursor = 'CMD'
      csrpos = 1
    End
    Else
    Do
      Cursor = SaveCursor
      Csrpos = SaveCsrpos
    End
  End
  Else
  Do
    If cursor = 'DAXEDIT' Then
    Do
      CursorLine = Min(Vdepth,CursorLine)
      If CursorArea = 'Prefix' Then
        CursorPos = 1
      If XPrefix = 'LEFT' Then
        csrpos = (CursorLine-1)*80+Min(CursorPos,73)+7
      Else
        csrpos = (CursorLine-1)*80+Min(CursorPos,73)+1
    End
    Else
    Do
      If cursor ^= 'SCALE' | xtype ^= 'FILE' Then
      Do
        Cursor = 'CMD'
        csrpos = '1'
      End
    End
  End
 
  SavedDAxedit = DAxedit
 
  Address ISPEXEC 'VPUT (CURSOR,CSRPOS,DAXEDIT)'
  Address ISPEXEC 'DISPLAY PANEL(XEDIT)'
  If rc > 8 Then
  Do
    If symbol('ZERRLM') = 'VAR' & zerrlm ^= '' Then
    Do
      If ZERRLM = 'PANEL NOT FOUND' Then
      Do
        Say 'XEDIT panel library not installed correctly'
        Exit 8
      End
      Else
        Say 'ISPF error: 'ZERRLM',cursor='cursor', csrpos='csrpos
    End
    cursor = 'CMD'
    csrpos = '1'
    Address ISPEXEC 'VPUT (CURSOR,CSRPOS)'
    Address ISPEXEC 'DISPLAY PANEL(XEDIT)'
    If rc ^= 0 Then
      pfkey = 'PF03'
  End
  Address ISPEXEC 'VGET (CMD,PFKEY,CURSOR,CSRPOS,DAXEDIT,VDEPTH)'
  DAxedit = DAxedit||Substr(SavedDAxedit,Length(DAxedit)+1)
  cursor = strip(cursor)
  If cursor = 'DAXEDIT' Then
  Do
    If csrpos//80 = 1 Then             /* on attribute character      */
      csrpos = csrpos+1
    If XPrefix = 'LEFT' Then
    Do
      If csrpos//80 = 7 Then
        csrpos = csrpos+1
      If (csrpos-1)//80 < 7 Then
      Do
        CursorArea = 'Prefix'
        CursorPos  = (csrpos-1)//80
      End
      Else
      Do
        CursorArea = 'File'
        CursorPos  = (csrpos-7)//80
      End
    End
    Else
    Do
      If csrpos//80 = 75 Then
        csrpos = csrpos+1
      If (csrpos-1)//80 < 75 Then
      Do
        CursorArea = 'File'
        CursorPos  = (csrpos-1)//80
      End
      Else
      Do
        CursorArea = 'Prefix'
        CursorPos  = (csrpos-75)//80
      End
    End
    CursorLine = (csrpos-1)%80+1
  End
  Else
    CursorArea = cursor
 
  SaveAlt = alt
 
  Call UpdateLines
  Call HandlePrefixCommands
  Call HandleHorCommands
Return
 
 
 
UpdateLines:
trace off
  If Index(DAxedit, UserMod) > 0 Then
    LinesUpdated = 'Yes'
  Else
  Do
    LinesUpdated = 'No'
    Return
  End
  j = curline-1
  Do i = 1 to vdepth
    j = j+1
    Select
      When j = 0 Then
        nop
      When j = size+1 Then
        nop
      When j <= size Then
      Do
        /**************************************************************/
        /* handle prefix command                                      */
        /**************************************************************/
        If XPrefix = 'LEFT' Then
        Do
          SavedC = Substr(SavedDAxedit,(i-1)*80+2,5)
          C = Substr(DAxedit,(i-1)*80+2,5)
        End
        Else
        Do
          SavedC = Substr(SavedDAxedit,(i-1)*80+76,5)
          C = Substr(DAxedit,(i-1)*80+76,5)
        End
        If SavedC ^= C Then
        Do
          L = compare(SavedC,C)
          SavedC = Strip(Substr(SavedC,L))
          C = Strip(Substr(C,L))
          revsc = reverse(SavedC)
          revc = reverse(C)
          p = Strip(reverse(substr(revc,compare(revsc,revc))))
          Call SetPrefixCmd p, j
        End
        /**************************************************************/
        /* Handle updated lines                                       */
        /**************************************************************/
        If XPrefix = 'LEFT' Then
          StartLine = (i-1)*80+8
        Else
          StartLine = (i-1)*80+2
        SavedL = Substr(SavedDAxedit,StartLine,73)
        L = Substr(DAxedit,StartLine,73)
        If Index(Substr(DAxedit,StartLine-1,74), UserMod) > 0 Then
        Do
          alt = alt+1
          L = Translate(L,'   ',UserMod||FileIn||FileOut)
          SavedL = Translate(SavedL,'   ',UserMod||FileIn||FileOut)
          Do x = 1 to 73
            If Substr(L,x,1) ^== Substr(SavedL,x,1) Then
              Line.j = Overlay(Substr(L,x,1),Line.j,startcol-1+x)
          End
          Line.j = Strip(Substr(line.j,1,lrecl),'T')
          Call TagChange j
          If word(case,1) = 'UPPER' Then
            Line.j = translate(,
               Line.j, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
          If word(case,1) = 'LOWER' Then
            Line.j = translate(,
               Line.j,'abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì','abcdefghijklmnopqrstuvwxyzÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ')
        End
        If hex = 'ON' Then
        Do
          If XPrefix = 'LEFT' Then
          Do
            SavedL1 = Substr(SavedDAxedit,i*80+8,min(lrecl,73))
            SavedL2 = Substr(SavedDAxedit,(i+1)*80+8,min(lrecl,73))
            L1 = Substr(DAxedit,i*80+8,min(lrecl,73))
            L2 = Substr(DAxedit,(i+1)*80+8,min(lrecl,73))
          End
          Else
          Do
            SavedL1 = Substr(SavedDAxedit,i*80+2,min(lrecl,73))
            SavedL2 = Substr(SavedDAxedit,(i+1)*80+2,min(lrecl,73))
            L1 = Substr(DAxedit,i*80+2,min(lrecl,73))
            L2 = Substr(DAxedit,(i+1)*80+2,min(lrecl,73))
          End
          If SavedL1 ^= L1 | SavedL2 ^= L2 Then
          Do
            hexline = ''
            hexline1 = Strip(translate(L1))
            hexline2 = Strip(translate(L2))
            Do m = 1 to min(lrecl,73)
              hexline = hexline||substr(hexline1,m,1)
              hexline = hexline||substr(hexline2,m,1)
            End
            If verify(hexline,'1234567890ABCDEF') ^= 0 Then
            Do
               CursorArea = 'File'
               CursorPos = (verify(hexline,'1234567890ABCDEF')+1)%2
               msg = 'Incorrect HEX value specified on line' j 'in column',
                      CursorPos+startcol-1
            End
            Else
            Do
              alt = alt+1
              hexline = x2c(hexline)
              If startcol > 1 Then
                Line.j = Strip(Substr(Substr(Line.j,1,startcol-1)||,
                                      Substr(hexline,1,73)||,
                                      Substr(line.j,Startcol+73),1,lrecl),'T')
              Else
                Line.j = Strip(Substr(Substr(hexline,1,73)||,
                                      Substr(line.j,Startcol+73),1,lrecl),'T')
              Call TagChange j
            End
          End
          i = i+2
        End
      End
      Otherwise                        /* after End of File           */
        nop
    End
    if j > size Then return
  End
return
 
 
 
SetPrefixCmd:
trace off
  PrefixCmd = arg(1)
  PrefixLine = arg(2)
  If PrefixCmd = '=' & SavePrefixCmd ^= '' Then
     PrefixCmd = SavePrefixCmd
  Else
     SavePrefixCmd = PrefixCmd
  k = verify(PrefixCmd,'0123456789')
  Pcnt1 = ''
  Pcnt2 = ''
  If k > 1 Then
  Do
    Pcmd = word(substr(PrefixCmd,k),1)
    Pcnt2 = substr(PrefixCmd,1,k-1)
  End
  Else
    Pcmd = Word(PrefixCmd,1)
  Upper Pcmd
  abc = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ\/*-<>()."'
  If verify(Pcmd,abc) > 1 Then
  Do
    Pcnt1 = Substr(Pcmd,verify(Pcmd,abc))
    If datatype(Pcnt1,'WHOLE') ^= 1 Then
      Pcnt1 = ''
    Pcmd = Substr(Pcmd,1,verify(Pcmd,abc)-1)
  End
  If Pcnt2 = '' Then Pcnt2 = 1
  If Pcnt1 = '' Then
  Do
    Pcnt1 = Pcnt2
    Pcnt2 = 1
  End
  If Substr(PrefixCmd,1,1) = '.' Then
  Do
    t = Strip(Substr(PrefixCmd,2))
    If t ^= '' Then
    Do
      If wordpos(t,tags) = 0 Then
        tags = tags||t' '
      tag.t = PrefixLine
    End
    Pcmd = ''
  End
  If Pcmd = '?' Then Pcmd = ''
  NrPrefCmd = NrPrefCmd+1
  command.PrefixLine = Pcnt1'|'Pcmd'|'Pcnt2
return
 
 
 
Handle_XEDITDS_and_XEDITDIR_pfkeys:
  If xtype = 'DIR' & statistics = 'OFF' Then
    NrLines = Vdepth*8
  Else
    NrLines = Vdepth
  Select
    When PFkey = '' Then               /* ENTER pressed               */
    Do
      If cmd = '' Then                 /* no command specified        */
      Do
        NewCurline = Curline
        Do ii = 1 to NrLines,          /* get all commands entered    */
           while curline+ii-1<=size & line.ii ^= ''
          jj = curline+ii-1
          NewLine = Strip(SL.ii)
          If xtype = 'DIR' & statistics = 'OFF' Then
            OldLine = Strip(Substr(line.jj,1,9))
          Else
            OldLine = Strip(line.jj)
          If NewLine ^= '' & NewLine ^= OldLine Then
          Do
            RevNL = reverse(NewLine)
            RevOL = reverse(OldLine)
            cmd = Strip(reverse(substr(RevNL,compare(RevNL,RevOL))))
            If cmd = '/' Then
            Do
              NewCurline = jj
              cmd = ''
            End
            If cmd = '\' Then
            Do
              NewCurline = Max(1,jj-NrLines+1)
              cmd = ''
            End
            If cmd ^= '' Then
            Do
              If cmd = '=' & SaveC ^= '' Then
                cmd = SaveC
              Else
                SaveC = cmd
              UserCmd = cmd            /* remember cmd entered by user*/
              If xtype = 'DLIST' Then  /* dataset list                */
              Do
                cmd = CheckCmd(cmd,Word(OldLine,1))
                If index(cmd,'/') = 0 & index(cmd,'&') = 0 & ,
                   cmd ^= '=' & UserCmd = cmd Then
                  cmd = cmd "'"Word(OldLine,1)"'"
              End
              Else                     /* display directory list      */
              Do
                Parse var dataset pds '(' .
                cmd = CheckCmd(cmd,pds'('Word(OldLine,1)')')
                If index(cmd,'/') = 0 & index(cmd,'&') = 0 & ,
                   cmd ^= '=' & UserCmd = cmd Then
                  cmd = cmd "'"pds"("Word(OldLine,1)")'"
              End
              If ABBREV('XEDIT',translate(word(cmd,1))) = 0 &,
                 ABBREV('BROWSE',translate(word(cmd,1))) = 0 &,
                 ABBREV('EDIT',translate(word(cmd,1))) = 0 &,
                 ABBREV('VIEW',translate(word(cmd,1))) = 0 &,
                 ABBREV('LIST',translate(word(cmd,1))) = 0 &,
                 ABBREV('XEXEC',translate(word(cmd,1))) = 0 &,
                 ABBREV('PRINT',translate(word(cmd,1))) = 0 &,
                 ABBREV('COMPRESS',translate(word(cmd,1))) = 0 &,
                 ABBREV('TSO',translate(word(cmd,1))) = 0 Then
                  cmd = 'TSO' cmd
              If xtype = 'DIR' & ,     /* DIR access with XXEDIT?     */
                 ABBREV('XEDIT',translate(word(cmd,1))) > 0 &,
                 xxgroup2||xxgroup3||xxgroup4 ^= '' Then
                                       /* yes,make it a XXEDIT command*/
                Call QueueCommand 'x'cmd xxgroup2 xxgroup3 xxgroup4
              Else
                Call QueueCommand cmd
            End
          End
        End
        Curline = NewCurline
        cmd = ''
      End
    End
    When PFkey = 'PF01' Then
      cmd = 'help'
    When PFkey = 'PF02' Then
      cmd = SaveCmd
    When PFkey = 'PF03' Then
      cmd = 'QUIT'
    When PFkey = 'PF04' Then
    Do                                 /* Delete requested            */
      NrDeleted = 0
      j = 1
      Do i = 1 to NrLines while curline+j-1 <= size
        k = curline+j-1
        If xtype = 'DLIST' Then
        Do
          NewLine = Strip(Substr(SL.i,1,47))
          OldLine = Strip(Substr(line.k,1,47))
        End
        Else
        Do
          NewLine = Strip(Substr(SL.i,1,8))
          OldLine = Strip(Substr(line.k,1,8))
        End
        If Newline = '' Then
        Do
          If xtype = 'DLIST' Then
          Do
            If Substr(Oldline,74,6) = 'MIGRAT' Then
              c = "HDELETE '"Word(OldLine,1)"' PURGE NOWAIT"
            Else
              c = "DELETE '"Word(OldLine,1)"'"
            c
          End
          Else                         /* display directory list      */
          Do
            Parse var dataset pds '(' .
            Address ISPEXEC "LMINIT DATAID(ID) DATASET('"pds"') ENQ(SHRW)"
            MaxRc = rc
            Address ISPEXEC "LMOPEN DATAID("id") OPTION(OUTPUT)"
            MaxRc = Max(MaxRc,rc)
            Address ISPEXEC "LMMDEL DATAID("id") MEMBER("Word(OldLine,1)")"
            MaxRc = Max(MaxRc,rc)
            Address ISPEXEC "LMCLOSE DATAID("id")"
            MaxRc = Max(MaxRc,rc)
            Address ISPEXEC "LMFREE DATAID("id")"
            Rc = Max(MaxRc,rc)
          End
 
          If rc = 0 Then
          Do
            NrDeleted = NrDeleted+1
            If xtype = 'DLIST' Then    /* display dataset list        */
              msg = 'Dataset' Word(OldLine,1) 'deleted'
            Else                       /* display directory list      */
              msg = 'Member' Word(OldLine,1) 'of' dataset 'deleted'
            Call DelLines k,1
            j = j-1
          End
          Else
          Do
            i = NrLines
            msg = c 'failed, rc='rc
          End
        End
        j = j+1
      End
      If NrDeleted = 0 Then
      Do
        If xtype = 'DLIST' Then        /* display dataset list        */
          msg = 'To delete a dataset, clear the name(s) and press PF4'
        Else                           /* display directory list      */
          msg = 'To delete a member, clear the name(s) and press PF4'
      End
      Else
      Do
        If NrDeleted > 1 Then
        Do
          If xtype = 'DLIST' Then      /* display dataset list        */
            msg = NrDeleted 'datasets deleted'
          Else                         /* display directory list      */
            msg = NrDeleted 'members deleted from dataset' dataset
        End
      End
    End
    When PFkey = 'PF05' Then
    Do                                 /* Refresh requested           */
      PrevDataset = Dataset
      Prevxxgroup2 = xxgroup2
      Prevxxgroup3 = xxgroup3
      Prevxxgroup4 = xxgroup4
      cmd = 'QQUIT'
      call HandleCommand
      If Prevxxgroup2^='' | Prevxxgroup3^='' | Prevxxgroup4^='' Then
        cmd = 'XXEDIT' Prevdataset Prevxxgroup2 Prevxxgroup3 Prevxxgroup4
      Else
        cmd = 'XEDIT 'PrevDataset
      msg = Dataset 'refreshed'
    End
    When PFkey = 'PF06' Then
    Do                                 /* Rename requested            */
      NrRenamed = 0
      Do i = 1 to NrLines while curline+i-1<=size & Value("line."i) ^= ''
        k = curline+i-1
        If xtype = 'DLIST' Then
        Do
          NewLine = Word(Substr(SL.i,1,47),1)
          OldLine = Word(Substr(line.k,1,47),1)
        End
        Else
        Do
          NewLine = Word(Substr(SL.i,1,8),1)
          OldLine = Word(Substr(line.k,1,8),1)
        End
        If Newline ^= '' & NewLine ^= OldLine Then
        Do
          Upper NewLine
          If xtype = 'DLIST' Then      /* display dataset list        */
            "RENAME '"OldLine"' '"NewLine"'"
          Else                         /* display directory list      */
          Do
            Parse var dataset pds '(' .
            c = "RENAME '"pds"("OldLine")' ("NewLine")"
            Parse var dataset pds '(' .
            Address ISPEXEC "LMINIT DATAID(ID) DATASET('"pds"') ENQ(SHRW)"
            MaxRc = rc
            Address ISPEXEC "LMOPEN DATAID("id") OPTION(OUTPUT)"
            MaxRc = Max(MaxRc,rc)
            Address ISPEXEC "LMMREN DATAID("id") MEMBER("Word(OldLine,1)")  NEWNAME("Word(NewLine,1)")"
            MaxRc = Max(MaxRc,rc)
            Address ISPEXEC "LMCLOSE DATAID("id")"
            MaxRc = Max(MaxRc,rc)
            Address ISPEXEC "LMFREE DATAID("id")"
            Rc = Max(MaxRc,rc)
          End
          If rc = 0 Then
          Do
            NrRenamed = NrRenamed+1
            If xtype = 'DLIST' Then    /* display dataset list        */
            Do
              line.k = Substr(NewLine,1,47)||Substr(line.k,48,32)
              msg = 'Dataset' OldLine 'renamed to' NewLine
            End
            Else                       /* display directory list      */
            Do
              line.k = Substr(NewLine,1,8)||Substr(line.k,9,53)
              msg = 'Member' OldLine 'renamed to' NewLine
            End
          End
          Else
          Do
            i = NrLines
            msg = c 'failed, rc='rc
          End
        End
      End
      If Renamed = 0 Then
      Do
        If xtype = 'DLIST' Then        /* display dataset list        */
          msg = 'To rename a dataset, overtype the name(s) and press PF6'
        Else                           /* display directory list      */
          msg = 'To rename a member, overtype the name(s) and press PF6'
      End
      Else
      Do
        If NrRenamed > 1 Then
        Do
          If xtype = 'DLIST' Then      /* display dataset list        */
            msg = NrRenamed 'datasets renamed'
          Else                         /* display directory list      */
            msg = NrRenamed 'members renamed in dataset' dataset
        End
      End
    End
    When PFkey = 'PF07' Then
    Do
      Select
        When Curline = 1 Then
        Do
          If cursor ^= 'CMD' Then
            CursorLine = 1
          Curline = max(1,size-NrLines+1)
        End
        When Curline-NrLines >= 1 Then
        Do
          If cursor ^= 'CMD' Then
            CursorLine = 1
          Curline = curline-NrLines+1
        End
        Otherwise
        Do
          If cursor ^= 'CMD' Then
            CursorLine = curline
          Curline = 1
        End
      End
    End
    When PFkey = 'PF08' Then
    Do
      If cursor ^= 'CMD' Then
        CursorLine = 1
      If Curline = size Then
        Curline = 1
      Else
        Curline = min(size,curline+NrLines-1)
    End
    When PFkey = 'PF09' Then
    Do
      Cursor = 'CMD'
      CurLine = 1
    End
    When PFkey = 'PF10' Then
    Do
      If CursorArea = 'File' Then
      Do
        k = curline+CursorLine-1
        If line.k ^= '' Then
        Do
          If xtype = 'DLIST' Then      /* display dataset list        */
            cmd = "ICPR '"Word(line.k,1)"'"
          Else                         /* display directory list      */
            cmd = "ICPR '"dataset"'"
        End
        Else
        Do
          If xtype = 'DLIST' Then      /* display dataset list        */
            msg = 'Place the cursor on a dataset and press PF10'
          Else                         /* display directory list      */
            msg = 'Place the cursor on a member and press PF10'
        End
      End
      Else
      Do
        If xtype = 'DLIST' Then        /* display dataset list        */
          msg = 'Place the cursor on a dataset and press PF10'
        Else                           /* display directory list      */
          msg = 'Place the cursor on a member and press PF10'
      End
    End
    When PFkey = 'PF11' Then
    Do
      If CursorArea = 'File' Then
      Do
        k = curline+CursorLine-1
        If line.k ^= '' Then
        Do
          If xtype = 'DLIST' Then      /* display dataset list        */
            cmd = 'XEDIT 'Word(line.k,1)
          Else                         /* display directory list      */
          Do
            Parse var dataset pds '(' .
                                       /* DIR access with XXEDIT?     */
            If xxgroup2||xxgroup3||xxgroup4 ^= '' Then
                                       /* yes,make it a XXEDIT command*/
              cmd = 'XXEDIT 'pds'('Word(line.k,1)')' xxgroup2 xxgroup3 xxgroup4
            Else
              cmd = 'XEDIT 'pds'('Word(line.k,1)')'
          End
        End
        Else
        Do
          If xtype = 'DLIST' Then      /* display dataset list        */
            msg = 'Place the cursor on a dataset and press PF11'
          Else                         /* display directory list      */
            msg = 'Place the cursor on a member and press PF11'
        End
      End
      Else
      Do
        If xtype = 'DLIST' Then        /* display dataset list        */
          msg = 'Place the cursor on a dataset and press PF11'
        Else                           /* display directory list      */
          msg = 'Place the cursor on a member and press PF11'
      End
    End
    When PFkey = 'PF12' Then
    Do
      Cursor = 'CMD'
      CurLine = max(size-NrLines+1,1)
    End
    Otherwise
    Do
      SavedCmd = cmd
      If PFkey >= 'PF13' & PFkey <= 'PF24' Then
        cmd = PFCmd.PFkey
      Else
      Do
        Address ISPEXEC 'VGET (ZVERB)'
        cmd = zverb
      End
      call HandleCommand
      Cmd = SavedCmd
    End
  End
Return
 
 
 
HandleXEDITpfkeys:
Trace off
  If PFkey ^= '' Then
  Do
    SavedCmd = cmd
    If PFkey >= 'PF01' & PFkey <= 'PF24' Then
      cmd = PFCmd.PFkey
    Else
    Do
      Address ISPEXEC 'VGET (ZVERB)'
      cmd = zverb
    End
    call HandleCommand
    Cmd = SavedCmd
  End
return
 
 
 
HandlePrefixCommands:
trace off
  If NrPrefCmd = 0 Then
    return
  NrPrefCmd = 0
  Do i = 1 to words(PrefixPenCmds)
    pcmd = word(PrefixPenCmds,i)
    pending.pcmd = 0
  End
  Pending.pcmd_fp = 0
  i = 0
  Do while i <= size
    i = i+1
    Pcmd = command.i
    command.i = ''
    Parse var Pcmd Pcnt1'|'Pcmd'|'Pcnt2
    If Pcmd ^= '' Then
      NrPrefCmd = NrPrefCmd+1
    Select
      When Pcmd = '' Then Nop
 
      When Pcmd = '?' Then Nop
 
      When Pcmd = '/' Then
      Do
        curline = i
        CursorLine = 1
        Cursor = 'DAXEDIT'
      End
 
      When Pcmd = '\' Then
      Do
        curline = max(0,i-Vdepth+1)
        CursorLine = Vdepth
        Cursor = 'DAXEDIT'
      End
 
      When Pcmd = '-' Then
      Do
        Do k = i to i+Pcnt1-1
          Line.k = '--'line.k
          Call TagChange k
        End
        alt = alt+1
      End
 
      When Pcmd = '--' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          Do k = j to i
            Line.k = '--'line.k
            Call TagChange k
          End
          alt = alt+1
        End
      End
 
      When Pcmd = '(' Then
      Do
        Do k = i to i+Pcnt2-1
          Line.k = Substr(Line.k,Pcnt1+1)
          Call TagChange k
        End
        alt = alt+1
      End
 
      When Pcmd = '((' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          PenCmd = command.j
          Parse var PenCmd PenCnt1'|'PenCmd'|'PenCnt2
          command.j = ''
          pcnt1 = max(pcnt1,pencnt1)
          Do k = j to i
            Line.k = Substr(Line.k,Pcnt1+1)
            Call TagChange k
          End
          alt = alt+1
        End
      End
 
      When Pcmd = ')' Then
      Do
        Do k = i to i+Pcnt2-1
          Line.k = Strip(Substr(Substr('',1,Pcnt1)||Line.k,1,lrecl),'T')
          Call TagChange k
        End
        alt = alt+1
      End
 
      When Pcmd = '))' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          PenCmd = command.j
          Parse var PenCmd PenCnt1'|'PenCmd'|'PenCnt2
          command.j = ''
          pcnt1 = max(pcnt1,pencnt1)
          Do k = j to i
            Line.k = Strip(Substr(Substr('',1,Pcnt1)||Line.k,1,lrecl),'T')
            Call TagChange k
          End
          alt = alt+1
        End
      End
 
      When Pcmd = '<' Then
        Call ShiftLinesLeft i,pcnt2,pcnt1
 
      When Pcmd = '<<' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          PenCmd = command.j
          Parse var PenCmd PenCnt1'|'PenCmd'|'PenCnt2
          command.j = ''
          pcnt1 = max(pcnt1,pencnt1)
          Call ShiftLinesLeft j ,i-j+1,pcnt1
        End
      End
 
      When Pcmd = '>' Then
        Call ShiftLinesRight i,pcnt2,pcnt1
 
      When Pcmd = '>>' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          PenCmd = command.j
          Parse var PenCmd PenCnt1'|'PenCmd'|'PenCnt2
          command.j = ''
          pcnt1 = max(pcnt1,pencnt1)
          Call ShiftLinesRight j ,i-j+1,pcnt1
        End
      End
 
      When Pcmd = '/*' Then
      Do
        If Substr(Word(line.i,1),1,2) = '/*' Then
        Do
          Call AddLines i, Pcnt1
          m = Index(Line.i,'/*')
          n = Index(Line.i,'*/')
          If m < n-5 Then
            If Substr(Line.i,m,3) = '/**' Then
              l = Substr('',1,m-1)||'/**'||Substr('',1,n-m-4)||'**/'
            Else
              l = Substr('',1,m-1)||'/*'||Substr('',1,n-m-2)||'*/'
          Else
            l = Substr('',1,m-1)'/*'copies(' ',69-m)'*/'
          Do k = i+1 to i+Pcnt1
            line.k = l
            Call TagChange k
          End
          CursorLine = CursorLine+1
          CursorPos = m+4-startcol
        End
        Else
        Do
          Do k = i to i+Pcnt1-1
            l = length(strip(Line.k,'T'))
            If l <= 39 Then
              l = 39
            Else
              l = l+1
            If l < 60 Then
            Do
              Line.k = Substr(Line.k,1,l)'/*'copies(' ',68-l)'*/'
              Call TagChange k
            End
          End
          CursorPos = max(44,index(Line.i,'/*')+4)-Startcol
        End
        CursorArea = 'File'
        alt = alt+1
      End
 
      When Pcmd = 'A' Then
      Do
        k = i+1
        Indent = DetermineIndent(Line.i,Line.k)
        Call AddLines i,Pcnt1
        alt = alt+1
        CursorPos = Indent
        If CursorArea = 'File' Then
          CursorLine = CursorLine+1
        CursorArea = 'File'
      End
 
      When Pcmd = 'B' Then
      Do
        k = i+1
        Indent = DetermineIndent(Line.i,Line.k)-1
        Call AddLines i,3
        k = i+1
        line.k = substr('',1,indent)'/*'copies('*',68-indent)'*/'
        Call TagChange k
        k = k+1
        line.k = substr('',1,indent)'/*'copies(' ',68-indent)'*/'
        Call TagChange k
        k = k+1
        line.k = substr('',1,indent)'/*'copies('*',68-indent)'*/'
        Call TagChange k
        alt = alt+1
        CursorArea = 'File'
        CursorPos = Indent+4
        CursorLine = CursorLine+2
      End
 
      When Pcmd = 'C' | Pcmd = 'M' Then
      Do
        If Pending.pcmd_fp >= 0 Then   /* no error with F or P        */
        Do
          Do j = Pending.pcmd_fp to size until PenCmd='F' | PenCmd='P'
            PenCmd = command.j
            Parse var PenCmd PenCnt1'|'PenCmd'|'PenCnt2
          End
          If j <= size Then            /* F or P found?               */
          Do
            Pending.pcmd_fp = min(i,j)
            command.i = ''
            command.j = ''
            alt = alt+1
            Select
              When PenCmd = 'F' & pcmd = 'C' Then
                call CopyLines i, pcnt1, j
              When PenCmd = 'P' & pcmd = 'C' Then
                call CopyLines i, pcnt1, j-1
              When PenCmd = 'F' & pcmd = 'M' Then
                call MoveLines i, pcnt1, j
              When PenCmd = 'P' & pcmd = 'M' Then
                call MoveLines i, pcnt1, j-1
              Otherwise
              Do
                Pending.pcmd_fp = -1   /* error with F or P           */
                command.i = Pcnt1'|'Pcmd'|'Pcnt2
              End
            End
          End                          /* end F or P found            */
          Else
            command.i = Pcnt1'|'Pcmd'|'Pcnt2
        End                            /* end no error with F or P    */
      End
 
      When Pcmd = 'CC' | Pcmd = 'MM' Then
      Do
        k = pending.pcmd
        If Pending.pcmd = 0 | index(command.k,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          If Pending.pcmd_fp >= 0 Then /* no P or F error yet         */
          Do
            Do j = Pending.pcmd_fp to size until PenCmd = 'F' | PenCmd = 'P'
              PenCmd = command.j
              Parse var PenCmd PenCnt1'|'PenCmd'|'PenCnt2
            End
            If j <= size Then          /* F or P found                */
            Do
              Pending.pcmd_fp = min(i,j)
              Pending.pcmd = 0
              command.i = ''
              command.k = ''
              command.j = ''
              alt = alt+1
              Select
                When PenCmd = 'F' & pcmd = 'CC' Then
                  Call CopyLines k, i-k+1, j
                When PenCmd = 'P' & pcmd = 'CC' Then
                  Call CopyLines k, i-k+1, j-1
                When PenCmd = 'F' & pcmd = 'MM' Then
                  Call MoveLines k, i-k+1, j
                When PenCmd = 'P' & pcmd = 'MM' Then
                  Call MoveLines k, i-k+1, j-1
                Otherwise
                Do
                  Pending.pcmd_fp = -1 /* indicate P or F error       */
                  command.i = Pcnt1'|'Pcmd'|'Pcnt2
                End
              End
            End                        /* end F or P found            */
            Else
              command.i = Pcnt1'|'Pcmd'|'Pcnt2
          End                          /* end no P or F error yet     */
        End
      End
 
      When Pcmd = 'D' Then
      Do
        Pcnt1 = min(size-i+1,Pcnt1)
        Call DelLines i,Pcnt1
        alt = alt+1
        i = i-Pcnt1
      End
 
      When Pcmd = 'DD' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          Call DelLines j,i-j+1
          alt = alt+1
          i = j
        End
      End
 
      When Pcmd = 'E' Then
      Do
        Do k = 1 to min(size-i,Pcnt1)
          l = i+k
          Do j = 1 to min(lrecl,length(Line.i))
            If Substr(Line.i,j,1) ^= ' ' Then
            Do
              Line.l = Overlay(Substr(line.i,j,1),line.l,j)
              Call TagChange l
            End
          End
        End
        alt = alt+1
      End
 
      When Pcmd = 'F' | Pcmd = 'P' Then
      Do
        command.i = Pcnt1'|'Pcmd'|'Pcnt2
        If Pending.pcmd_fp = 0 Then
          Pending.pcmd_fp = i
      End
 
      When Pcmd = 'G' Then
      Do
        If PutLines = 0 Then
          msg = "No lines saved in 'PUT-queue'"
        Else
        Do
          alt = alt+1
          Call AddLines i,PutLines
          NrSplit = 0
          l = i
          InsertedLines = PutLines
          Do k = 1 to PutLines
            l = l+1
            If Length(Strip(PutLine.k,'T')) > lrecl Then
            Do
              ExtraLines = Length(Strip(PutLine.k,'T'))%lrecl
              If Length(Strip(PutLine.k,'T'))//lrecl = 0 Then
                ExtraLines = ExtraLines - 1
              InsertedLines = InsertedLines+ExtraLines
              Call AddLines l,ExtraLines
              NrSplit = NrSplit+1
              Do e = 0 to ExtraLines
                Line.l = substr(PutLine.k,e*lrecl+1,lrecl)
                Call TagChange k
                l = l+1
              End
              l = l-1
            End
            Else
            Do
              Line.l = PutLine.k
              Call TagChange l
            End
          End
          If NrSplit > 0 Then
            msg = InsertedLines 'Lines inserted,' NrSplit 'line(s) split'
        End
      End
 
      When Pcmd = 'I' Then
      Do
        k = max(1,i-1)
        Indent = DetermineIndent(Line.k,Line.i)
        Call AddLines max(0,i-1),Pcnt1
        alt = alt+1
        CursorArea = 'File'
        CursorPos = Indent
      End
 
      When Pcmd='IF'|Pcmd='ELSE'|Pcmd='FOR'|Pcmd='WHILE'|Pcmd='UNTIL'|,
           Pcmd='DO'|Pcmd='SELEC'|Pcmd='WHEN' Then
      Do
        If language = 'PL1' Then
          LangVar = 'Pli'PCMD
        Else
          LangVar = 'Rexx'PCMD
        Insert = Value(LangVar'.1')
        k = i+1
        Call AddLines i,insert
        CursorPos = verify(line.i,' ')
        If CursorPos = 0 Then
        Do
          If Language = 'PL1' Then
            CursorPos = 2
          Else
            CursorPos = 1
        End
        Else
        Do
          fword = translate(word(line.i,1))
          If verify(fword,'ABCDEFGHIJKLMNOPQRSTUVWXYZ') > 0 Then
            fword = substr(fword,1,verify(fword,'ABCDEFGHIJKLMNOPQRSTUVWXYZ')-1)
          If wordpos(fword,Value(LangVar'.4')) > 0 Then
            CursorPos = CursorPos+2
          If Value(LangVar'.5') ^= '' &,
             wordpos(fword,Value(LangVar'.5')) = 0 Then
            CursorPos = max(1,CursorPos-2)
        End
        Do k = 1 to insert
          l = i+k
          line.l = Substr('',1,CursorPos-1)||Value(LangVar'.'k+5)
        End
        CursorArea = 'File'
        CursorPos = CursorPos+Value(LangVar'.3')
        CursorLine = CursorLine+Value(LangVar'.2')
        alt = alt+1
      End
 
      When Pcmd = 'K' Then
      Do
        Call CommentLines i, Pcnt1
      End
 
      When Pcmd = 'KK' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          Call CommentLines j, i-j+1
        End
      End
 
      When Pcmd = 'L' Then
      Do
        Do k = i to i+Pcnt1-1
          Line.k = translate(,
             Line.k,'abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì','ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ')
          Call TagChange k
        End
        alt = alt+1
      End
 
      When Pcmd = 'LC' Then
      Do
        Pcnt1 = min(size-i+1,Pcnt1)
        Call Lowercase i,Pcnt1
        alt = alt+1
      End
 
      When Pcmd = 'LEN' Then
      Do
        Pcnt1 = min(size-i+1,Pcnt1)
        Do k = i to i+Pcnt1-1
          Say 'Length of line' k 'is' Length(Line.k)
        End
      End
 
      When Pcmd = 'LL' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          Do k = j to i
            Line.k = translate(,
               Line.k,'abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì','ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ')
            Call TagChange k
          End
          alt = alt+1
        End
      End
 
      When Pcmd = 'LLC' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          Call Lowercase j, i-j+1
          alt = alt+1
        End
      End
 
      When Pcmd = 'O' Then
      Do
        Do k = 1 to min(size-i,Pcnt1)
          l = i+k
          Do j = 1 to min(lrecl,length(Line.i))
            If Substr(Line.l,j,1) = ' ' Then
              Line.l = Overlay(Substr(line.i,j,1),line.l,j)
            Call TagChange l
          End
        End
        alt = alt+1
      End
 
      When Pcmd = 'PD' Then
      Do
        PutLines = min(size-i+1,Pcnt1)
        Do k = 1 to PutLines
          l = i+k-1
          PutLine.k = Line.l
        End
        Call DelLines i,PutLines
        i = i-PutLines
        alt = alt+1
      End
 
      When Pcmd = 'PPD' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          PutLines = i-j+1
          Do k = 1 to PutLines
            l = j+k-1
            PutLine.k = Line.l
          End
          Call DelLines j,PutLines
          i = i-PutLines
          alt = alt+1
        End
      End
 
      When Pcmd = 'PUT' Then
      Do
        PutLines = min(size-i+1,Pcnt1)
        Do k = 1 to PutLines
          l = i+k-1
          PutLine.k = Line.l
        End
      End
 
      When Pcmd = 'PP' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          PutLines = i-j+1
          Do k = 1 to PutLines
            l = j+k-1
            PutLine.k = Line.l
          End
        End
      End
 
      When Pcmd = 'R' | Pcmd = '"' Then
      Do
        alt = alt+1
        Call AddLines i,Pcnt1
        do j = i+1 to i+Pcnt1
          line.j = line.i
          Call TagChange j
        End
      End
 
      When Pcmd = 'RR' | Pcmd = '""' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          PenCmd = command.j
          Parse var PenCmd PenCnt1'|'PenCmd'|'PenCnt2
          pcnt1 = max(pcnt1,pencnt1)
          Pending.pcmd = 0
          command.j = ''
          Do k = 0 to max(pcnt1,pencnt1)-1
            Call CopyLines j,i-j+1,i+k*(i-j+1)
          End
          alt = alt+1
        End
      End
 
      When Pcmd = 'SI' | Pcmd = '.....' Then
      Do
        If Pcmd = 'SI' | LinesUpdated = 'Yes' Then
        Do
          k = i+1
          Indent = DetermineIndent(Line.i,Line.k)
          Call AddLines i,1
          i = i+1
          command.i = '|.....|'
          CursorArea = 'File'
          CursorPos = Indent
          If CursorLine = Vdepth Then
            CurLine = CurLine+1
          Else
            CursorLine = CursorLine+1
        End
        Else
        Do
          Call DelLines i,1
          i = i-1
        End
        alt = alt+1
      End
 
      When Pcmd = 'SQL' Then
      Do
        If DB2subsystem = '' Then
          Msg = "DB2-subsystem is not known, set it via the command: SSID <DB2sys>"
        Else
        Do
          SqlStat = ''
          Do k = i to size Until Right(Strip(SqlStat),1) = ';'
            If Left(Line.k,2) ^= '--' Then
              SqlStat = SqlStat Left(Line.k,72)
          End
          If SqlStat = '' Then
            Msg = "No SQL statement found"
          Else
          Do
            If Right(Strip(SqlStat),1) = ';' Then
              SqlStat = Strip(Strip(SqlStat),'T',';')
 
            Call IssuePipe "SQL SSID" DB2subsystem SqlStat "| terminal"
 
            If rc ^= 0 & rc ^= 100 Then
              msg = "SQL statement" Word(SQLstat,1) "failed, rc="rc
            Else
              msg = "SQL statement" Word(SQLstat,1) "completed, rc="rc
          End
        End
      End
 
      When Pcmd = 'T' Then
      Do
        SaveTagChange = TagChange
        TagChange = 'ON' Subword(TagChange,2)
        Do k = i to i+Pcnt1-1
          Call TagChange k
        End
        alt = alt+1
        TagChange = SaveTagChange
      End
 
      When Pcmd = 'U' Then
      Do
        Do k = i to i+Pcnt1-1
          Line.k = translate(,
             Line.k, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
          Call TagChange k
        End
        alt = alt+1
      End
 
      When Pcmd = 'UC' Then
      Do
        Pcnt1 = min(size-i+1,Pcnt1)
        Call Uppercase i,Pcnt1
        Do k = i to i+Pcnt1-1
          Call TagChange k
        End
        alt = alt+1
      End
 
      When Pcmd = 'UT' Then
      Do
        Pcnt1 = min(size-i+1,Pcnt1)
        Call UnTagChange i, Pcnt1
        alt = alt+1
      End
 
      When Pcmd = 'TT' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          SaveTagChange = TagChange
          TagChange = 'ON' Subword(TagChange,2)
          Pending.pcmd = 0
          command.j = ''
          Do k = j to i
            Call TagChange k
          End
          TagChange = SaveTagChange
          alt = alt+1
        End
      End
 
      When Pcmd = 'UU' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          Do k = j to i
            Line.k = translate(,
               Line.k, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
            Call TagChange k
          End
          alt = alt+1
        End
      End
 
      When Pcmd = 'UUC' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          Call Uppercase j, i-j+1
          Do k = j to i
            Call TagChange k
          End
          alt = alt+1
        End
      End
 
      When Pcmd = 'UTT' Then
      Do
        j = pending.pcmd
        If Pending.pcmd = 0 | index(command.j,pcmd) = 0 Then
        Do
          command.i = Pcnt1'|'Pcmd'|'Pcnt2
          Pending.pcmd = i
        End
        Else
        Do
          Pending.pcmd = 0
          command.j = ''
          Call UnTagChange j, i-j+1
          alt = alt+1
        End
      End
 
      When Pcmd = 'X' Then
        call QueueCommand 'XEDIT' line.i
 
      When Pcmd = 'XE' Then
        call QueueCommand line.i
 
      Otherwise
        command.i = '|?|'
    End
  End
return
 
 
HandleHorCommands:
trace off
If MsgDisplayed = 'Yes' Then
  return
If XPrefix = 'LEFT' Then
  Scale = Substr(Scale,8)
Else
  Scale = Substr(Scale,2,73)
HorCmd = ''
Do i = 1 to Length(Scale)
  If Substr(Scale,i,1) ^= ' ' & ,
     Substr(PrevScale,i,1) ^= Substr(Scale,i,1) Then
    HorCmd = HorCmd||Substr(Scale,i,1)
  Else
    HorCmd = HorCmd' '
End
HorCmd = Strip(HorCmd,'T')
If Strip(HorCmd) = '=' Then
  HorCmd = PrevHorCmd
If Strip(HorCmd) ^= '?' Then
  PrevHorCmd = HorCmd
i = Verify(HorCmd, ' ')
If i > 0 Then
Do
  Select
    When Pos('=',HorCmd) > 0 &,        /* computation?                */
         Pos('Y',HorCmd) > 0 Then
      Call HorComputation
    When Substr(HorCmd,i,1) = '/' Then /* set current column          */
    Do
      SavedCmd = cmd
      cmd = 'RIGHT' i-1
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = '\' Then /* set current column          */
    Do
      SavedCmd = cmd
      cmd = 'LEFT' 73-i
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = '+' Then /* accumulate numbers in column*/
    Do
      SavedCmd = cmd
      cmd = 'COLSUM' i+StartCol-1 GetHorCount(i)
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = '?' Then /* recall previous hor command */
      Nop                              /* handled before the call to  */
                                       /* DisplayXedit                */
    When Substr(HorCmd,i,1) = 'e' Then /* emulate columns             */
    Do
      string = Substr(HorCmd,i+1)
      If string ^= '' Then
      Do
        SavedCmd = cmd
        i = i+Verify(string,' ')
        cmd = 'COLEMULATE' i+StartCol-1 Strip(string)
        Call HandleCommand
        Cmd = SavedCmd
      End
    End
    When Substr(HorCmd,i,1) = 'o' Then /* overlay columns             */
    Do
      string = Substr(HorCmd,i+1)
      If string ^= '' Then
      Do
        SavedCmd = cmd
        i = i+Verify(string,' ')
        cmd = 'COLOVERLAY' i+StartCol-1 Strip(string)
        Call HandleCommand
        Cmd = SavedCmd
      End
    End
    When Substr(HorCmd,i,1) = 'a' Then /* add columns                 */
    Do
      SavedCmd = cmd
      cmd = 'COLADD' i+StartCol-1 GetHorCount(i)
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = 'd' Then /* delete columns              */
    Do
      SavedCmd = cmd
      cmd = 'COLADD' i+StartCol-2 GetHorCount(i)*-1
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = 'i' Then /* insert colums               */
    Do
      SavedCmd = cmd
      cmd = 'COLADD' i+StartCol-2 GetHorCount(i)
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = 'j' Then /* justify left of right       */
    Do
      j1 = i+StartCol-1
      j2 = ''
      If Substr(HorCmd,i+1,1) = 'j' Then
      Do
        If Pos('j',Substr(HorCmd,i+3)) > 0 Then
        Do
          j2 = i + Pos('j',Substr(HorCmd,i+3)) + StartCol + 1
          i = i+1
        End
      End
      If Substr(HorCmd,i+1,1) = 'l' | ,
         Substr(HorCmd,i+1,1) = 'r' Then
      Do
        SavedCmd = cmd
        cmd = 'JUSTIFY' Substr(HorCmd,i+1,1)  GetHorCount(i+1) j1 j2
        Call HandleCommand
        Cmd = SavedCmd
      End
    End
    When Substr(HorCmd,i,1) = 'c' |,   /* copy or move columns        */
         Substr(HorCmd,i,1) = 'm' |,
         Substr(HorCmd,i,1) = 'p' |,
         Substr(HorCmd,i,1) = 'f' Then
    Do
      I_c = Pos('c',HorCmd)
      I_m = Pos('m',HorCmd)
      I_p = Pos('p',HorCmd)
      I_f = Pos('f',HorCmd)
      j = ''
      HorCommand = ''
      If (I_p < I_f | I_f = 0) & I_p > 0 Then
        j = I_p-1
      If (I_f < I_p | I_p = 0) & I_f > 0 Then
        j = I_f
      If (I_c < I_m | I_m = 0) & I_c > 0 Then
      Do
        i = I_c
        HorCommand = 'COLCOPY'
      End
      If (I_m < I_c | I_c = 0) & I_m > 0 Then
      Do
        i = I_m
        HorCommand = 'COLMOVE'
      End
      If j ^= '' & HorCom ^= '' Then
      Do
        SavedCmd = cmd
        cmd = HorCommand i+StartCol-1 GetHorCount(i) j+StartCol-1
        Call HandleCommand
        Cmd = SavedCmd
      End
    End
    When Substr(HorCmd,i,1) = 'l' Then /* lowercase columns           */
    Do
      SavedCmd = cmd
      cmd = 'COLLOWER' i+StartCol-1 GetHorCount(i)
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = 'n' Then /* number in columns           */
    Do
      SavedCmd = cmd
      cmd = 'COLNUM' i+StartCol-1 GetHorCount(i)
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = 's' Then /* sort on column (ascending)  */
    Do
      SavedCmd = cmd
      cmd = 'SORT' i+StartCol-1
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = 'S' Then /* sort on column(descending)  */
    Do
      SavedCmd = cmd
      cmd = 'SORT D' i+StartCol-1
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = 'u' Then /* uppercase columns           */
    Do
      SavedCmd = cmd
      cmd = 'COLUPPER' i+StartCol-1 GetHorCount(i)
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = 'w' Then /* wordflow                    */
    Do
      SavedCmd = cmd
      cmd = 'COLWORDFLOW' i+StartCol-1 GetHorCount(i)
      Call HandleCommand
      Cmd = SavedCmd
    End
    When Substr(HorCmd,i,1) = 'r' |,   /* Repeat (copy) columns       */
         Substr(HorCmd,i,1) = '"' Then
    Do
      SavedCmd = cmd
      j = GetHorCount(i)
      cmd = 'COLCOPY' i+StartCol-1 j (i+StartCol-1)+j-1
      Call HandleCommand
      Cmd = SavedCmd
    End
    Otherwise
      msg = 'Invalid horizontal editing command "'||,
            Strip(HorCmd)'". Use PF1 for help.'
  End
End
return
 
 
 
GetHorCount: Procedure expose HorCmd
HorI = arg(1)
HorC = Substr(HorCmd,HorI,1)
Do j=HorI+1 while Substr(HorCmd,j,1) = HorC
End
If j > HorI+1 Then
  HorCount = j-HorI
Else
Do
  Do j=HorI+1 while Substr(HorCmd,j,1) ^= '' &,
                    Datatype(Substr(HorCmd,j,1),'Whole') = 1
  End
  If j > HorI+1 Then
    HorCount = Substr(HorCmd,HorI+1,j-HorI-1)
  Else
    HorCount = 1
End
Return HorCount
 
 
 
HorComputation: procedure expose line. HorCmd size msg StartCol
If InterpretSupported = 'No' Then
  msg = 'Horizontal cumputation not supported in this version'
Else
Do
  ResultStart = 0
  ResultEnd = 0
  Do j=1 to Length(HorCmd)
    /******************************************************************/
    /* place decimal point where they are needed                      */
    /******************************************************************/
    If Substr(HorCmd,j,1) = '=' & ResultStart = 0 Then
      ResultStart = j
    If Substr(HorCmd,j,1) = '=' & Substr(HorCmd,j+1,1) = ' ' &,
       Substr(HorCmd,j+2,1) = '=' Then
      HorCmd = Overlay('.',HorCmd,j+1)
    If Verify(Substr(HorCmd,j,1), '0123456789') = 0 &,
       Substr(HorCmd,j+1,1) = ' ' &,
       Verify(Substr(HorCmd,j+2,1), '0123456789') = 0 Then
      HorCmd = Overlay('.',HorCmd,j+1)
    If Substr(HorCmd,j,1) = '=' & Substr(HorCmd,j+1,1) = '' &,
       ResultStart > 0 Then
      ResultEnd = j
  End
  If ResultStart > 0 Then
  Do
    before = Pos('.',Substr(HorCmd,ResultStart,ResultEnd-ResultStart+1))
    If before = 0 Then
    Do
      before = ResultEnd-ResultStart+1
      after = 0
    End
    Else
    Do
      before = before-1
      after = ResultEnd-ResultStart-before
    End
    MaxValue = copies('9',before)'.'copies('9',after)
  End
  ResultStart = ResultStart+StartCol-1
  ResultEnd = ResultEnd+StartCol-1
  Do i = 1 to size
    computation = ''
    Do j=1 to Length(HorCmd)
      Select
        When j+StartCol-1 >= ResultStart & ,
             j+StartCol-1 <= ResultEnd Then
          Nop
        When Substr(HorCmd,j,1) = 'Y' Then
          Computation = Computation||Substr(line.i,j+StartCol-1,1)
        When Substr(HorCmd,j,1) = ' ' Then
          Nop
        Otherwise
          Computation = Computation||Substr(HorCmd,j,1)
      End
    End
    pc_result = Compute(Computation)
    If ResultStart > 0 Then
    Do
      If pc_result > MaxValue Then
        Say pc_result 'is too big for output format',
            Substr(HorCmd,ResultStart,ResultEnd-ResultStart+1)
      Else
      Do
        If pc_result ^= '' Then
        Do
          If datatype(pc_result,'NUMBER') = 1 Then
          Do
            MaxResult = copies('9',before)||'.'||copies('9',after)
            If pc_result > MaxResult Then
            Do
              say Pc_result 'does not fit (it is replacedby' MaxResult ')'
              pc_result = MaxResult
            End
            Else
              pc_result = format(pc_result,before,after)
          End
          Else
            pc_result = Right(pc_result,before+after+1)
          line.i = Overlay(pc_result,line.i,ResultStart)
        End
      End
    End
    Else
      Say computation '=' pc_result
  End
End
Return
 
 
IssuePipe:
InPipe = 'Yes'
"PIPE" arg(1)
ContinueAfterPipe:
InPipe = 'No'
Return
 
 
Compute: procedure expose msg i
computation = arg(1)
pc_result = ''
InHorComputation = 'Yes'
Interpret 'pc_result = 'Computation
ContinueAfterComputation:
InHorComputation = 'No'
Return pc_result
 
 
 
/* function for PC */
X: Parse Arg Input ; Return X2D(Input)
 
 
HandleCommand:
trace off
If xdebug = 'Y' Then trace r
  cmd = strip(cmd)
  If cmd = '' Then
    Return
 
  If cmd = '=' Then
    cmd = SaveCmd
 
  cmd = CheckCmd(cmd, dataset)
 
  MixedCmd = cmd
  Upper cmd
  cmd = strip(cmd,'T')
  abc = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  cmd1 = word(cmd,1)
  If verify(cmd1,abc) > 1 Then
    cmd1 = substr(cmd1,1,verify(cmd1,abc)-1)
  cmd2 = strip(substr(cmd,length(cmd1)+1),'L')
 
  Select
    When xtype = 'DLIST' Then          /* display dataset list        */
      Not_Allowed = MixedCmd 'not allowed in dataset list display'
    When xtype = 'DIR' Then              /* display directory        */
      Not_Allowed = MixedCmd 'not allowed in PDS directory display'
    Otherwise                          /* display file                */
      Not_Allowed = MixedCmd 'not allowed in edit'
  End                                  /* end select                  */
 
  Select
    When datatype(cmd,'WHOLE') = 1 Then /* integer specified          */
    Do
      If xtype = 'FILE' Then
        curline = max(min(size,curline+cmd),0)
      Else                              /* directory or dslist      */
        curline = max(min(size,curline+cmd),1)
    End
 
    When substr(strip(cmd),1,1) = '.' Then
    Do
      MixedCmd = strip(MixedCmd)
      Parse var MixedCmd '.' t
      If t ^= '' Then
      Do
        If wordpos(t,tags,) > 0 & Datatype(tag.t,'W') = 1 Then
          curline = tag.t
        Else
          msg = 'Tag' MixedCmd 'not found'
      End
      Else
        msg = 'Tag missing'
    End
 
    When substr(strip(cmd),1,1) = ':' Then
    Do
      Parse var cmd ':' string
      If datatype(string,'WHOLE') = 1 & string <= size & string >= 0 Then
        curline = string
      Else
        msg = 'Incorrect line number' string
    End
 
    When substr(strip(cmd),1,1) = '¦' | substr(strip(cmd),1,1) = '|' Then
    Do
      If substr(strip(cmd),1,1) = '¦' Then
        Parse var cmd '¦' string
      Else
        Parse var cmd '|' string
      If datatype(string,'WHOLE') = 1 & string <= size & string >= 0 Then
        curline = string
      Else
        msg = 'Incorrect line number' string
    End
 
    When substr(strip(cmd),1,1) = '/' |,
         substr(strip(cmd),1,2) = '^/' |,
         (ABBREV('LOCATE',cmd1,2) & (substr(strip(cmd2),1,1) = '/' |,
                                     substr(strip(cmd2),1,2) = '^/')) Then
    Do
      If right(cmd,1) = '/' Then
        Parse var Mixedcmd type not '/' string '/'
      Else
        Parse var Mixedcmd type not '/' string
      If substr(strip(cmd),1,2) = '^/' Then
      Do
        type = ''
        not = '^'
      End
      If not ^= '' & not ^= '^' Then
      Do
        msg = 'Invalid command: "'MixedCmd'". Syntax: LOcate <^>/string/'
        return
      End
      If string == '' Then
        return
      If word(case,2) = 'IGNORE' Then
        string = translate(,
           string, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
      If (substr(string,1,2) = "X'" | substr(string,1,2) = "x'") &,
         substr(string,length(string),1) = "'" & length(string) > 2 Then
      Do
        string = translate(substr(string,3,length(string)-3))
        If verify(string,'1234567890ABCDEF') ^= 0 | ,
           length(string)//2 = 1 Then
        Do
          msg = 'Invalid hex string:' string
          return
        End
        string = x2c(string)
      End
      If cursor = 'DAXEDIT' &,
         (CursorArea = 'Prefix' | CursorArea = 'File') Then
      Do
        If Hex = 'ON' Then
        Do
          If curline = 0 Then
           j = (CursorLine+4)%3+curline-1
          Else
           j = (CursorLine+2)%3+curline-1
        End
        Else
          j = CursorLine+curline-1
      End
      Else
      Do
        CursorPos = 0
        If not = '^' Then               /*search for line without string*/
          j = curline
        Else
          j = max(curline,1)
      End
      If CursorArea ^= 'File' Then
        CursorPos = 0
      If not = '^' Then               /*search for line without string*/
      Do
        j = j+1                       /* start search on next line!!! */
        CursorPos = 0                  /* at the beginning            */
      End
      If j > size Then
        j = 1
      found = 'No'
      Do i = 1 to size+1 until found = 'Yes'
        ll = Line.j' '
        If word(case,2) = 'IGNORE' Then
          ll = translate(,
             ll, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
        If not = '' Then               /* normal search?              */
        Do                             /* yes                         */
          If i = 1 Then
          Do
            k = index(substr(ll,startcol+CursorPos),string)
            If k > 0 Then
            Do
              CurCol = startcol+CursorPos+k-1
              found = 'Yes'
            End
          End
          Else
          Do
            If index(ll,string) > 0 Then
            Do
              CurCol = index(ll,string)
              found = 'Yes'
            End
          End
        End                            /* end normal search           */
        Else                           /* not = '^'!!!!               */
        Do
          If (string = '' & ll ^= '') |,
             (string ^= '' & pos(string,ll)=0) Then
          Do
            CurCol = 1
            found = 'Yes'
          End
        End                            /* end not = '^'!!!            */
        If found ^= 'Yes' Then
        Do
          If j = size Then
          Do
            msg = 'Wrapped ....'
            j = 1
          End
          Else
            j = j+1
        End
      End
      If found = 'Yes' Then
      Do
        Cursor = 'DAXEDIT'
        CursorArea = 'File'
        If Hex = 'ON' Then
        Do
          If j < curline | j >= curline+(Vdepth+2)%3 | type ^= '' Then
          Do
            curline = j
            CursorLine = 1
          End
          Else
          Do
            If Curline = 0 Then
              CursorLine = (j-curline)*3-1
            Else
              CursorLine = (j-curline)*3+1
          End
        End
        Else                           /* hex is off                  */
        Do
          If j < curline | j >= curline+Vdepth | type ^= '' Then
          Do
            curline = j
            CursorLine = 1
          End
          Else
            CursorLine = j-curline+1
        End
        If CurCol < StartCol | CurCol >= StartCol+73 Then
          StartCol = max(CurCol-30,1)
        CursorPos = CurCol-StartCol+1
      End
      Else
      Do
        Parse var MixedCmd . '/' string '/'
        If not = '^' Then               /*search for line without string*/
          msg = 'string "'string'" found in all lines'
        Else
          msg = 'string "'string'" not found'
      End
    End
 
    When substr(strip(cmd),1,1) = '\' |,
         substr(strip(cmd),1,2) = '^\' |,
         (ABBREV('LOCATE',cmd1,2) & (substr(strip(cmd2),1,1) = '\' |,
                                     substr(strip(cmd2),1,2) = '^\')) Then
    Do
      If right(cmd,1) = '\' Then
        Parse var Mixedcmd type not '\' string '\'
      Else
        Parse var Mixedcmd type not '\' string
      If substr(strip(cmd),1,2) = '^\' Then
      Do
        type = ''
        not = '^'
      End
      If not ^= '' & not ^= '^' Then
      Do
        msg = 'Invalid command: "'MixedCmd'". Syntax: LOcate <^>/string/'
        return
      End
      If string == '' Then
        return
      string = translate(reverse(string))
      If word(case,2) = 'IGNORE' Then
        string = translate(,
           string, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
      If (substr(string,1,2) = "X'" | substr(string,1,2) = "x'") &,
         substr(string,length(string),1) = "'" Then
      Do
        string = translate(substr(string,3,length(string)-3))
        If verify(string,'1234567890ABCDEF') ^= 0 | ,
           length(string)//2 = 1 Then
        Do
          msg = 'Invalid hex string:' string
          return
        End
        string = x2c(string)
      End
      If cursor = 'DAXEDIT' &,
         (CursorArea = 'Prefix' | CursorArea = 'File') Then
      Do
        If Hex = 'ON' Then
        Do
          If curline = 0 Then
           j = (CursorLine+4)%3+curline-1
          Else
           j = (CursorLine+2)%3+curline-1
        End
        Else
          j = CursorLine+curline-1
      End
      Else
      Do
        CursorPos = 1
        If not = '^' Then             /*search for line without string*/
          j = curline
        Else
          j = max(curline,1)
      End
      If CursorArea ^= 'File' Then
        CursorPos = 1
      If not = '^' Then               /*search for line without string*/
      Do
        j = j-1                       /* start search on prev. line!!!*/
        CursorPos = Length(line.j)+1   /* at the end of the line      */
      End
      If j > size Then
        j = 1
      If j < 1 Then
        j = size
      found = 'No'
      Do i = 1 to size+1 until found = 'Yes'
        If i = 1 Then
          ll = reverse(substr(Line.j' ',1,max(startcol+CursorPos-2,0)))
        Else
          ll = reverse(Line.j' ')
        If word(case,2) = 'IGNORE' Then
          ll = translate(,
             ll, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
        If not = '' Then               /* normal search?              */
        Do                             /* yes                         */
          If index(ll,string) > 0 Then
          Do
            CurCol = length(ll)-index(ll,string)-length(string)+2
            found = 'Yes'
          End
        End                            /* end normal search           */
        Else                           /* not = '^'!!!!               */
        Do
          If (string = '' & ll ^= '') |,
             (string ^= '' & pos(string,ll)=0) Then
          Do
            CurCol = 1
            found = 'Yes'
          End
        End                            /* end not = '^'!!!            */
        If found ^= 'Yes' Then
        Do
          If j = 1 Then
          Do
            msg = 'Wrapped ....'
            j = size
          End
          Else
            j = j-1
        End
      End
      If found = 'Yes' Then
      Do
        Cursor = 'DAXEDIT'
        CursorArea = 'File'
        If Hex = 'ON' Then
        Do
          If j < curline | j >= curline+(Vdepth+2)%3 | type ^= '' Then
          Do
            curline = j
            CursorLine = 1
          End
          Else
          Do
            If curline = 0 Then
              CursorLine = (j-curline)*3-1
            Else
              CursorLine = (j-curline)*3+1
          End
        End
        Else                           /* hex is off                  */
        Do
          If j < curline | j > curline+Vdepth | type ^= '' Then
          Do
            curline = j
            CursorLine = 1
          End
          Else
            CursorLine = j-curline+1
        End
        If CurCol < StartCol | CurCol >= StartCol+73 Then
          StartCol = max(CurCol-30,1)
        CursorPos = CurCol-StartCol+1
      End
      Else
      Do
        Parse var MixedCmd . '\' string '\'
        If not = '^' Then               /*search for line without string*/
          msg = 'string "'string'" found in all lines'
        Else
          msg = 'string "'string'" not found'
      End
    End
 
    When ABBREV('ADD',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' then cmd2 = 1
        If datatype(cmd2,'WHOLE') = 1 & cmd2 > 0 Then
        Do
          Call AddLines curline, cmd2
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: Add <nnn>'
      End
    End
 
    When ABBREV('ALLOCATE',cmd1) Then
      Address ISPEXEC 'SELECT PGM(ISRUDA) PARM(ISRUDA2S)'
 
    When ABBREV('AUTOSAVE',cmd1) Then
    Do
      Select
        When word(cmd2,1) = 'ON' Then
        Do
          If word(cmd2,2) = '' Then cmd2 = cmd2' 30'
          If Datatype(word(cmd2,2),'WHOLE') = 1 & word(cmd2,2) > 0 Then
          Do
            If autosave > 0 Then
              autosave = word(cmd2,2)
            Else
            Do
              autosave = word(cmd2,2)
              AutosaveDset = ''
            End
            msg = 'AUTOSAVE ON' autosave
          End
          Else
            msg = 'Invalid command: "'MixedCmd||,
                  '". Syntax: AUtosave <OFF|ON <nnn>>'
        End
        When word(cmd2,1) = 'OFF' Then
        Do
          If AutosaveDset ^= '' Then
          Do
            alt = alt+1
            msgstat = msg('off')
            "DELETE '"AutosaveDset"'"
            msgstat = msg(msgstat)
            AutosaveDset = ''
          End
          autosave = 0
          msg = 'AUTOSAVE OFF'
        End
        Otherwise msg = 'Invalid command: "'MixedCmd||,
                        '". Syntax: AUtosave <OFF|ON <nnn>>'
      End
    End
 
    When ABBREV('BROWSE',cmd1) Then
    Do
      If cmd2 = '' Then
        dset = dataset
      Else
        dset = CheckName(cmd2)
      Address ISPEXEC 'CONTROL ERRORS RETURN'
      Address ISPEXEC "BROWSE DATASET('"dset"')"
      Select
        When rc=12 Then
          msg = 'Dataset' dset 'is empty'
        When rc=14 Then
          msg = 'Member' dset 'not found'
        When rc=16 Then
          msg = 'No members in dataset' dset
        When rc=20 Then
          msg = 'Severe error during BROWSE of' dset
        Otherwise
          ;
      End
    End
 
    When ABBREV('BRALL',cmd1) Then
    Do
      If xtype ^= 'FILE' Then          /* DIR or DLIST?               */
      Do
        If xtype = 'DIR' Then          /* display dataset list        */
          parse var dataset pds '(' .
        Do ii = 1 to size
          If xtype = 'DLIST' Then      /* display dataset list        */
            Call QueueCommand 'BROWSE' Word(line.ii,1)
          Else                         /* display directory list      */
          Do
            If xxgroup2||xxgroup3||xxgroup4 = '' Then
              Call QueueCommand 'BROWSE' pds'('Word(line.ii,1)')'
            Else
            Do
              parse var pds pr '.' gr '.' ty
              Select
                When Word(line.ii,2) = '1' Then
                  Call QueueCommand 'BROWSE' pr'.'gr'.'ty'('Word(line.ii,1)')'
                When Word(line.ii,2) = '2' Then
                  Call QueueCommand 'BROWSE' pr'.'xxgroup2'.'ty'('Word(line.ii,1)')'
                When Word(line.ii,2) = '3' Then
                  Call QueueCommand 'BROWSE' pr'.'xxgroup3'.'ty'('Word(line.ii,1)')'
                Otherwise
                  Call QueueCommand 'BROWSE' pr'.'xxgroup4'.'ty'('Word(line.ii,1)')'
              End
            End
          End                          /* end directory list          */
        End
      End
      Else
        msg = Not_Allowed
    End
 
    When ABBREV('BOL',cmd1) Then
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
        Call BeginOfLine
 
    When ABBREV('BOTTOM',cmd1) Then
    Do
      Cursor = 'CMD'
      If Hex = 'ON' Then
      Do
        If size <= Vdepth%3 Then
          Curline = 1
        Else
          Curline = size-(Vdepth)%3+1
      End
      Else
        CurLine = max(size-Vdepth+2,0)
    End
 
    When ABBREV('CHANGE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        d = substr( strip( substr(cmd,length(cmd1)+1) ) ,1,1)
        Select
          When d = '/' Then
            Parse var Mixedcmd . '/' s1 '/' s2 '/' c1 c2 .
          When d = '@' Then
            Parse var Mixedcmd . '@' s1 '@' s2 '@' c1 c2 .
          When d = '¢' Then
            Parse var Mixedcmd . '¢' s1 '¢' s2 '¢' c1 c2 .
          When d = '#' Then
            Parse var Mixedcmd . '#' s1 '#' s2 '#' c1 c2 .
          When d = '\' Then
            Parse var Mixedcmd . '\' s1 '\' s2 '\' c1 c2 .
          When d = '¦' Then
            Parse var Mixedcmd . '¦' s1 '¦' s2 '¦' c1 c2 .
          When d = '|' Then
            Parse var Mixedcmd . '|' s1 '|' s2 '|' c1 c2 .
          When d = '%' Then
            Parse var Mixedcmd . '%' s1 '%' s2 '%' c1 c2 .
          Otherwise
          Do
            msg = 'Invalid command: "'MixedCmd||,
                  '".  Syntax: Change/string1/string2/ <nnn> <mmm>'
          return
          End
        End
        If c1 = '*' Then c1 = size
        If c1 = '' Then c1 = 1
        If c2 = '*' Then c2 = lrecl
        If c2 = '' Then c2 = 1
        If (s1 == '' & s2 == '') | ,
           datatype(d,'MIXED CASE') |,
           datatype(c1,'WHOLE') ^= 1 | datatype(c2,'WHOLE') ^= 1 Then
        Do
          msg = 'Invalid command: "'MixedCmd||,
                '".  Syntax: Change/string1/string2/ <nnn> <mmm>'
          return
        End
        If (substr(s1,1,2) = "x'" | substr(s1,1,2) = "X'") &,
            right(s1,1) = "'" Then
        Do
          s1 = translate(substr(s1,3,length(s1)-3))
          If verify(s1,'1234567890ABCDEF') ^= 0 Then
          Do
            msg = 'Incorrect hex string' s1
            return
          End
          s1 = x2c(s1)
        End
        If (substr(s2,1,2) = "x'" | substr(s2,1,2) = "X'") &,
            right(s2,1) = "'" Then
        Do
          s2 = translate(substr(s2,3,length(s2)-3))
          If verify(s2,'1234567890ABCDEF') ^= 0 Then
          Do
            msg = 'Incorrect hex string' s2
            return
          End
          s2 = x2c(s2)
        End
        l1 = length(s1)
        l2 = length(s2)
        changes = 0
        lines = 0
        lastline = 0
 
/**********************************************************************/
/* code for arbchar change to be completed                            */
/*                                                                    */
/*      If Word(arbchar,1) = 'ON' &                                   */
/*         Index(s1,Word(arbchar,2) > 0 Then                          */
/*      Do                                                            */
/*        Arb1I = Index(s1,Word(arbchar,2)                            */
/*        s1a = Substr(s1,1,Arb1I-1)                                  */
/*        s1b = Substr(s1,Arb1I+1)                                    */
/*        Arb2I = Index(s2,Word(arbchar,2)                            */
/*        If Arb2I > 0 Then                                           */
/*        Do                                                          */
/*          s2a = Substr(s2,1,Arb1I-1)                                */
/*          s2b = Substr(s2,Arb1I+1)                                  */
/*        End                                                         */
/*        Else                                                        */
/*        Do                                                          */
/*          s2a = s2                                                  */
/*          s2b = ''                                                  */
/*        End                                                         */
/*      End                                                           */
/*                                                                    */
/**********************************************************************/
        Do i = max(curline,1) to min(size,max(curline,1)+c1-1)
          l = 1
          line.i = Strip(line.i,'T')
          Do j = 1 to c2
            l = index(line.i,s1,l)
            If l > 0 Then
            Do
              Line.i = Insert(s2,Delstr(Line.i,l,l1),l-1)
              l = l+l2
              If LastLine ^= i Then
                lines = lines+1
              lastline = i
              changes = changes+1
              Do while length(Line.i) > lrecl
                Call AddLines i,1
                k = i+1
                Line.k = Substr(Line.i,lrecl+1)
                Line.i = Substr(Line.i,1,lrecl)
                i = i+1
              End
            End
            Else
              j = c2
          End
        End
        If changes > 0 Then
        Do
          msg = changes 'changes on' lines 'lines'
          alt = alt+1
        End
        Else
          msg = 'string "'s1'" not found'
      End
    End
 
    When ABBREV('CHECKPL1',cmd1) Then
    Do
      /****************************************************************/
      /* check for characters in column 1 and 73 to 80, unmatched     */
      /* comments or quotes. Start after the current line and stop    */
      /* when an error is found                                       */
      /****************************************************************/
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        found = 'No'
        Wrapped = 'No'
        Do i = 1 to size until found = 'Yes'
          j = curline+i
          If j > size Then
          Do
            j=j-size
            Wrapped = 'Yes'
          End
          ll = line.j
          Select
            When verify(Substr(ll,1,1),' 01') > 0 Then
            Do
              msg = 'Unexpected character ("'Substr(ll,1,1)'") in colum 1'
              CurLine = j
              CurCol = 1
              StartCol = 1
              found = 'Yes'
            End
            When Substr(ll,73) ^= '' Then
            Do
              msg = 'Unexpected character(s) ("'Strip(Substr(ll,73))'") after colum 72 at line' j
              CurLine = j
              CurCol = 72+verify(Substr(ll,73),' ')
              StartCol = 8
              found = 'Yes'
            End
            When (Pos('/*',ll) > 0) ^= (Pos('*/',ll) > 0) Then
            Do
              msg = 'Unbalanced start- and end-comments (/* and */) at line' j
              CurLine = j
              CurCol = Max(Pos('/*',ll),Pos('*/',ll))
              StartCol = 1
              found = 'Yes'
            End
            Otherwise
            Do
              lc = Pos('/*',ll)
              rc = Pos('*/',ll)
              If lc > 0 & rc > 0 & lc < rc Then
                ll = Substr(ll,1,lc-1)||Substr(ll,rc+2)
              QuoteCnt = 0
              Do While Pos("'",ll) > 0
                ll = Substr(ll,Pos("'",ll)+1)
                QuoteCnt = QuoteCnt + 1
              End
              If QuoteCnt//2 = 1 Then
              Do
                msg = 'Unbalanced quotes at line' j
                CurLine = j
                ll = line.j
                CurCol = Pos("'",ll)
                found = 'Yes'
              End
            End
          End
        End
        If found = 'Yes' Then
        Do
          Cursor = 'DAXEDIT'
          CursorArea = 'File'
          If CurCol < StartCol | CurCol >= StartCol+73 Then
            StartCol = max(CurCol-30,1)
          CursorPos = CurCol-StartCol+1
          CursorLine = 1
          If Wrapped = 'Yes' Then
            msg = 'CHECKPLI wrapped.' msg
        End
        Else
          msg = 'No PL/1 comment/quote balancing or margin errors found'
      End
    End
 
    When ABBREV('CASE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        Do i = 2 to words(cmd)
          If ABBREV('MIXED',word(cmd,i)) = 0 & ,
             ABBREV('UPPER',word(cmd,i)) = 0 & ,
             ABBREV('LOWER',word(cmd,i)) = 0 & ,
             ABBREV('RESPECT',word(cmd,i)) = 0 & ,
             ABBREV('IGNORE',word(cmd,i)) = 0 Then
          Do
            msg = 'Invalid command: "'MixedCmd||,
                  '". Syntax: Case <Upper|Lower> <Respect|Ignore>'
            leave i
          End
        End
        If i > words(cmd) Then
        Do i = 2 to words(cmd)
          Select
            When ABBREV('MIXED',word(cmd,i)) Then
              case = 'MIXED' word(case,2)
            When ABBREV('UPPER',word(cmd,i)) Then
              case = 'UPPER' word(case,2)
            When ABBREV('LOWER',word(cmd,i)) Then
              case = 'LOWER' word(case,2)
            When ABBREV('RESPECT',word(cmd,i)) Then
              case = word(case,1) 'RESPECT'
            When ABBREV('IGNORE',word(cmd,i)) Then
              case = word(case,1) 'IGNORE'
            Otherwise nop;
          End
        End
        msg = 'CASE' case
      End
    End
 
    When ABBREV('COLADD',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var MixedCmd . after count string
        If (substr(string,1,2) = "x'" | substr(string,1,2) = "X'") &,
            right(string,1) = "'" Then
        Do
          string = translate(substr(string,3,length(string)-3))
          If verify(string,'1234567890ABCDEF') ^= 0 Then
          Do
            msg = 'Incorrect hex string' string
            return
          End
          string = x2c(string)
        End
        If datatype(after,'WHOLE') = 1 & datatype(count,'WHOLE') = 1 Then
        Do
          after = min(max(after,0),lrecl)
          If after+count > lrecl Then count = lrecl-after
          If count < 0 & after > lrecl+count Then count = after-lrecl
          truncated = 0
          Do i = 1 to size
            If count < 0 Then
              Line.i = substr(Line.i,1,after)||substr(line.i,after-count+1)
            Else
              Line.i = substr(Line.i,1,after)||substr(string,1,count)||,
                       substr(line.i,after+1)
            If Length(Strip(Line.i,'T')) > lrecl Then
            Do
              truncated = truncated+1
              Line.i = substr(Line.i,1,lrecl)
            End
          End
          If truncated > 0 Then
            msg = 'Columns added,' truncated 'line(s) truncated'
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLAdd after count <string>'
      End
    End
 
    When ABBREV('COLCOPY',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var cmd2 from for after
        If Datatype(from,'WHOLE') = 1 & Datatype(for,'WHOLE') = 1 &,
           Datatype(after,'WHOLE') = 1 Then
        Do
          If from>0 & from<lrecl & for>0 & from+for<=lrecl &,
             after>=0 & after<=lrecl & (after<from | after>=from+for-1) Then
          Do
            truncated = 0
            Do i = 1 to size
              If after = 0 Then
                Line.i = Substr(Line.i,from,for)||Line.i
              Else
                Line.i = Substr(Line.i,1,after)||Substr(Line.i,from,for)||,
                         Substr(line.i,after+1)
              If Length(Strip(Line.i,'T')) > lrecl Then
              Do
                truncated = truncated+1
                Line.i = substr(Line.i,1,lrecl)
              End
            End
            If truncated > 0 Then
              msg = 'Columns copied,' truncated 'line(s) truncated'
            alt = alt+1
          End
          Else
            msg = 'Invalid command: "'MixedCmd||,
                  '". Syntax: COLCopy from for after'
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLCopy from for after'
      End
    End
 
    When ABBREV('COLEMULATE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var MixedCmd . start string
        If datatype(start,'WHOLE') = 1 & start > 0 Then
        Do
          Do i = 1 to size
            Do j = start to min(lrecl,start+Length(String))
              If Substr(String,j-start+1,1) ^= ' ' Then
                Line.i = Overlay(Substr(string,j-start+1,1),line.i,j)
            End
          End
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLEmulate start <string>'
      End
    End
 
    When ABBREV('COLLOWER',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var cmd2 from for .
        If Datatype(from,'WHOLE') = 1 &,
           (Datatype(for,'WHOLE') = 1 | for = '') Then
        Do
          LowerABC = 'abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì'
          UpperABC = 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ'
          from = min(max(from,1),lrecl)
          If for = '' Then
            for = 1
          If from+for > lrecl Then for = lrecl-from
          for = max(0,for)
          Do i = 1 to size
            Line.i = Substr(Line.i,1,from-1)||,
                     Translate(Substr(Line.i,from,for),LowerABC,UpperABC)||,
                     Substr(Line.i,from+for)
          End
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLLower from <for>'
      End
    End
 
    When ABBREV('COLMOVE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var cmd2 from for after
        If Datatype(from,'WHOLE') = 1 & Datatype(for,'WHOLE') = 1 &,
           Datatype(after,'WHOLE') = 1 Then
        Do
          If from>0 & from<lrecl & for>0 & from+for<=lrecl &,
             after>=0 & after<=lrecl & (after<from | after>=from+for) Then
          Do
            Do i = 1 to size
              If after = 0 Then
                Line.i = Substr(Line.i,from,for)||Substr(Line.i,1,from-1)||,
                         Substr(Line.i,from+for)
              Else
                If after < from Then
                  Line.i = Substr(Line.i,1,after)||Substr(Line.i,from,for)||,
                           Substr(line.i,after+1,from-after-1)||,
                           Substr(line.i,from+for)
                Else
                  Line.i = Substr(Line.i,1,from-1)||,
                           Substr(Line.i,from+for,after-from-for+1)||,
                           Substr(line.i,from,for)||,
                           Substr(line.i,after+1)
            End
            alt = alt+1
          End
          Else
            msg = 'Invalid command: "'MixedCmd||,
                  '". Syntax: COLMove from for after'
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLMove from for after'
      End
    End
 
    When ABBREV('COLNUM',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var cmd2 from for startnum .
        If Datatype(from,'WHOLE') = 1 & Datatype(for,'WHOLE') = 1 &,
           from > 0 & for > 0 &,
           (Datatype(startnum,'WHOLE') = 1 | startnum = '') Then
        Do
          If startnum = '' Then
            startnum = 1
          If Datatype(Substr(line.1,from,for),'WHOLE') = 1 Then
            startnum = Substr(line.1,from,for)
          from = min(max(from,1),lrecl)
          If from+for > lrecl Then for = lrecl-from
          for = max(0,for)
          Do i = 1 to size
            If Substr(Line.i,from,for) = '' Then
              Line.i = Substr(Line.i,1,from-1)||right(startnum,for)||,
                       Substr(Line.i,from+for)
            startnum = startnum+1
          End
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLNum from for <startnum>'
      End
    End
 
    When ABBREV('COLOR',cmd1) Then
    Do
      Parse Upper var cmd2 area attr
      Select
        When ABBREV('ARROW',area) Then
          ArrowA = GetAttr(attr, ArrowA)
        When ABBREV('CMDLINE',area) Then
          CmdA = GetAttr(attr, CmdA)
        When ABBREV('FILEAREA',area) Then
          FileA  = GetAttr(attr, FileA)
        When ABBREV('IDLINE',area) Then
          IDlinea = GetAttr(attr, IDlineA)
        When ABBREV('MEMBERS',area) Then
          MemberA = GetAttr(attr, MemberA)
        When ABBREV('DATASETS',area) Then
          DatasetA = GetAttr(attr, DatasetA)
        When ABBREV('MSGLINE',area) Then
          MsgA = GetAttr(attr, MsgA)
        When ABBREV('PREFIX',area) Then
          PrefixA = GetAttr(attr, PrefixA)
        When ABBREV('PFKEYS',area) Then
          PFkeysA = GetAttr(attr, PFkeysA)
        When ABBREV('SCALE',area) Then
          ScaleA = GetAttr(attr, ScaleA)
        When ABBREV('TOFEOF',area) Then
          TofA = GetAttr(attr, TofA)
        Otherwise
        msg = 'Invalid command: "'MixedCmd'". Syntax: COlor area color'
      End
    End
 
    When ABBREV('COLOVERLAY',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var MixedCmd . start string
        If datatype(start,'WHOLE') = 1 & start > 0 Then
        Do
          Do i = 1 to size
            Do j = start to min(lrecl,start+Length(String))
              If Substr(Line.i,j,1) = ' ' Then
                Line.i = Overlay(Substr(string,j-start+1,1),line.i,j)
            End
          End
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLOVerlay start <string>'
      End
    End
 
    When ABBREV('COLSUM',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var cmd2 from for .
        If Datatype(from,'WHOLE') = 1 & Datatype(for,'WHOLE') = 1 Then
        Do
          from = min(max(from,1),lrecl)
          If from+for > lrecl Then for = lrecl-from
          for = max(0,for)
          max = ''
          min = ''
          count = 0
          sum = 0
          Do i = 1 to size
            If datatype(substr(Line.i,from,for),'NUMERIC') = 1 Then
            Do
              val = substr(Line.i,from,for)
              If max = '' | max < val Then max = val
              If min = '' | min > val Then min = val
              sum = sum+val
              count = count+1
            End
          End
          If count = 0 Then
            msg = 'No numbers found in columns' from 'to' from+for
          Else
            msg = count' number found: total='format(sum)||,
                  ', min='format(min)', max='format(max)||,
                  ', avg='format(sum/count)
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLSum from for'
      End
    End
 
    When ABBREV('COLUMN',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' then cmd2 = 1
        If datatype(cmd2,'WHOLE') = 1 Then
        Do
          Startcol = min(max(1,Lrecl-72),abs(cmd2))
          curcol = max(min(lrecl,abs(cmd2)),1)
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: COLUmn <nnn>'
      End
    End
 
    When ABBREV('COLUPPER',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var cmd2 from for .
        If Datatype(from,'WHOLE') = 1 &,
           (Datatype(for,'WHOLE') = 1 | for = '') Then
        Do
          from = min(max(from,1),lrecl)
          If for = '' Then
            for = 1
          If from+for > lrecl Then for = lrecl-from
          for = max(0,for)
          Do i = 1 to size
            Line.i = Substr(Line.i,1,from-1)||,
                     Translate(Substr(Line.i,from,for))||,
                     Substr(Line.i,from+for)
          End
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLUpper from <for>'
      End
    End
 
    When ABBREV('COLWORDFLOW',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var cmd2 from for .
        If Datatype(from,'WHOLE') = 1 &,
           Datatype(for,'WHOLE') = 1 & for > 1 Then
        Do
          from = min(max(from,1),lrecl)
          If from+for > lrecl Then for = lrecl-from
          for = max(0,for)
          wf. = ''
          wfI = 0
          wfline = substr('',1,from-1)
          Do i = 1 to size
            Do j = 1 to words(line.i)
              If Length(wfline||word(line.i,j)) > from+for Then
              Do
                If wfline ^= '' Then
                Do
                  wfI = wfI+1
                  wf.wfI = wfline
                End
                wfline = substr('', 1, from-1)word(line.i,j)' '
                Do while Length(wfline) > from+for
                  wfI = wfI+1
                  wf.wfI = substr(wfline, 1, from+for)
                  wfline = substr('',1,from-1)||,
                           substr(wfline, from+for+1)
                End
              End
              Else
                wfline = wfline||word(line.i,j)' '
            End
          End
          If wfline ^= '' Then
          Do
            wfI = wfI+1
            wf.wfI = wfline
          End
          Do i = 1 to wfI
            line.i = wf.i
          End
          Do i = wfI+1 to size
            line.i = ''
          End
          size = max(size, wfI)
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: COLWordflow from <for>'
      End
    End
 
    When ABBREV('COMPRESS',cmd1) Then
    Do
      dset = CheckName(cmd2)
      Parse var dset pds '(' .
      If CheckDataset(pds) > 4 Then
      Do
        Msg 'Dataset' pds 'does not exist'
        Return
      End
      If sysdsorg ^= 'PO' Then
      Do
        msg = dataset 'is not a PDS'
        return
      End
 
      TempDset = CheckTempDataset('COMPRESS')
      If TempDset = '' Then
      Do
        msg = 'Compress' pds 'canceled'
        return
      End
      cmd="ALLOCATE FI(ZYXEDITQ) DA("TempDset")" ,
          "SPACE(5,5) TRACKS LRECL(80) BLKSIZE(800) DSORG(PS) NEW REUSE"
      cmd
      if rc ^= 0 Then
      Do
        msg = 'Unexpected return code from "'cmd'", rc='rc
        Return 16
      End
      TempLine.1 = ' COPY INDD=ZYXINOUT,OUTDD=ZYXINOUT'
      'EXECIO 1 DISKW ZYXEDITQ (STEM TEMPLINE. FINIS'
      'FREE FI(ZYXEDITQ)'
 
      cmd = "ALLOCATE FILE(SYSIN) DA("TempDset") SHR REUSE"
      cmd
      If rc ^= 0 Then
      Do
        msg = 'Unexpected return code from "'cmd'", rc='rc
        msgstat = msg('off')
        'DELETE' TempDset
        msgstat = msg(msgstat)
        Return 16
      End
 
      "ALLOCATE FILE(ZYXINOUT) DA('"pds"') SHR"
 
      If rc ^= 0 Then
      Do
        msg = 'Unexpected return code from "'cmd'", rc='rc
        'FREE FILE(SYSIN)'
        msgstat = msg('off')
        'DELETE' TempDset
        msgstat = msg(msgstat)
        Return 16
      End
 
      msgstat = msg('off')
      Address ISPEXEC 'SELECT PGM(IEBCOPY)'
      If rc = 0 Then
        msg = pds 'compressed'
      Else
        msg = 'Compress of dataset' pds 'failed, IEBCOPY rc='rc
 
      'FREE FILE(ZYXINOUT)'
      'FREE FILE(SYSIN)'
      'DELETE' TempDset
      msgstat = msg(msgstat)
    End
 
    When ABBREV('COPY',cmd1) Then
      Address ISPEXEC 'SELECT PGM(ISRUMC) SCRNAME(MCOPY)'
 
    When ABBREV('CUTPASTE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cursor = 'DAXEDIT' & CursorArea = 'File' Then
        Do
          If Hex = 'ON' Then
          Do
            If curline = 0 Then
             i = (CursorLine+4)%3+curline-1
            Else
             i = (CursorLine+2)%3+curline-1
          End
          Else
            i = CursorLine+curline-1
          If i <= 0 | i > size Then
          Do
            msg = 'Cursor not on valid field'
            Return
          End
          t = 'CutPaste'
          Select
            When CutNrLines > 0 Then
            Do
              j = i
              offset = startcol+CursorPos-1
              rest = Substr(Line.j,offset)
              Line.j = Substr(Line.j,1,offset-1)||CutLine.1
              If Length(Line.j) > lrecl Then
              Do
                Call AddLines j, 1
                j = j+1
                Line.j = Substr(Line.i,lrecl+1)
                Line.i = Substr(Line.i,1,lrecl)
              End
              If CutNrLines > 1 Then
                Call AddLines j, CutNrLines-1
              Do k = 2 to CutNrLines
                j = j+1
                Line.j = CutLine.k
              End
              Line.j = Line.j||rest
              If Length(Line.j) > lrecl Then
              Do
                Call AddLines j, 1
                k = j
                j = j+1
                Line.j = Substr(Line.k,lrecl+1)
                Line.k = Substr(Line.k,1,lrecl)
              End
              CutNrLines = -1          /* no lines cut                */
              alt = alt+1
            End
            When CutNrLines = 0 Then
            Do
              If (i = tag.t & CutPasteOffset > startcol+CursorPos-1) |,
                 i < tag.t Then
              Do
                l1 = i
                o1 = startcol+CursorPos-1
                l2 = tag.t
                o2 = CutPasteOffset
              End
              Else
              Do
                l1 = tag.t
                o1 = CutPasteOffset
                l2 = i
                o2 = startcol+CursorPos-1
              End
              CutNrLines = 1
              If l1 = l2 Then
              Do
                CutLine.1 = Substr(Line.l1,o1,o2-o1+1)
                Line.i = Substr(Line.i,1,o1-1)||Substr(Line.i,o2+1)
              End
              Else
              Do
                CutLine.1 = Substr(Line.l1,o1)
                Line.l1 = Substr(Line.l1,1,o1-1)
                Do j = l1+1 to l2-1
                  CutNrLines = CutNrLines+1
                  CutLine.CutNrLines = line.j
                End
                CutNrLines = CutNrLines+1
                CutLine.CutNrLines = Substr(Line.l2,1,o2)
                Line.j = Substr(Line.l2,o2+1)
                If l1 < l2-1 Then
                  Call DelLines l1+1, l2-l1-1
              End
              alt = alt+1
              msg = 'Text has been CUT. Move cursor to destination',
                    'and repeat CUTPASTE (use =)'
            End
            Otherwise
            Do
              If wordpos(t,tags) = 0 Then
                tags = tags||t' '
              tag.t = i
              CutPasteOffset = startcol+CursorPos-1
              CutNrLines = 0
              msg = 'Move cursor to ending position',
                    'and repeat CUTPASTE (use =)'
            End
          End                          /* end select                  */
        End
        Else
          msg = 'Cursor not in the file area'
      End
    End
 
    When ABBREV('CUTSQUARE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cursor = 'DAXEDIT' & CursorArea = 'File' Then
        Do
          If Hex = 'ON' Then
          Do
            If curline = 0 Then
             i = (CursorLine+4)%3+curline-1
            Else
             i = (CursorLine+2)%3+curline-1
          End
          Else
            i = CursorLine+curline-1
          If i <= 0 | i > size Then
          Do
            msg = 'Cursor not on valid field'
            Return
          End
          t = 'CutSquare'
          If CutSquareStatus = '' |,   /* set first position          */
             CutSquareStatus = 'CutDone' Then
          Do
            If wordpos(t,tags) = 0 Then
              tags = tags||t' '
            tag.t = i
            CutSquareOffset = startcol+CursorPos-1
            CutSquareStatus = '1st Pos'
            msg = 'Move cursor to ending position',
                  'and repeat CUTSQUARE (use =)'
          End
          Else
          Do
            If (i = tag.t & CutSquareOffset > startcol+CursorPos-1) |,
               i < tag.t Then
            Do
              l1 = i
              o1 = startcol+CursorPos-1
              l2 = tag.t
              o2 = CutSquareOffset
            End
            Else
            Do
              l1 = tag.t
              o1 = CutSquareOffset
              l2 = i
              o2 = startcol+CursorPos-1
            End
            CutSquareNrLines = 0
            Do j = l1 to l2
              CutSquareNrLines = CutSquareNrLines + 1
              CutSquareLine.CutSquareNrLines = Substr(line.j,o1,o2-o1+1)
              Line.j = Substr(line.j,1,o1-1)||Copies(' ',o2-o1+1)|| ,
                       Substr(line.j,o2+1)
            End
            alt = alt+1
            msg = 'Text has been CUT. Type PASTESquare and move',
                  'the cursor to the destination'
            CutSquareStatus = 'CutDone'
          End
        End
        Else
          msg = 'Cursor not in the file area'
      End
    End
 
    When ABBREV('PASTESQUARE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cursor = 'DAXEDIT' & CursorArea = 'File' Then
        Do
          If Hex = 'ON' Then
          Do
            If curline = 0 Then
             i = (CursorLine+4)%3+curline-1
            Else
             i = (CursorLine+2)%3+curline-1
          End
          Else
            i = CursorLine+curline-1
          If i <= 0 | i > size Then
          Do
            msg = 'Cursor not on valid field'
            Return
          End
          t = 'CutSquare'
          If CutSquareStatus = 'CutDone' Then /* lines were cut       */
          Do
            If i + CutSquareNrLines - 1 > size Then
              Call AddLines Size, i + CutSquareNrLines - 1 - size
            offset = startcol+CursorPos-1
            j = i
            Do k = 1 to CutSquareNrLines
              Line.j = Substr(Line.j,1,offset-1)||CutSquareLine.k||,
                       Substr(Line.j,offset+Length(CutSquareLine.k))
              If Length(Line.j) > lrecl Then
                Line.j = Left(Line.j,lrecl)
              j = j+1
            End
            alt = alt+1
          End
          Else                         /* no lines were cut           */
            msg = 'No text was CUTSquare'
        End
        Else
          msg = 'Cursor not in the file area'
      End
    End
 
    When ABBREV('DOWN',cmd1) Then
    Do
      If Hex = 'ON' Then
        scroll = Vdepth%3
      Else
        scroll = Vdepth-1
      Select
        When cmd2 = '' then
        Do
          If cursorArea = 'File' | cursorArea = 'Prefix' Then
            CursorLine = 1
          If Curline = size+1 Then
            Curline = 0
          Else
            Curline = min(size+1,curline+scroll)
        End
        When ABBREV('CSR',translate(cmd2)) Then
        Do
          If CursorArea ^= 'File' & CursorArea ^= 'Prefix' Then
            CursorLine = 1             /* act as if on first line     */
          If Hex = 'ON' Then
          Do
            If curline = 0 Then
             l = (CursorLine+4)%3
            Else
             l = (CursorLine+2)%3
          End
          Else
            l = CursorLine
 
          Select
            When curline+l-1 = size+1 Then
              Curline = 0
            When l = 1 Then
              Curline = min(size+1,curline+scroll)
            Otherwise
              Curline = min(size+1,curline+l-1)
          End
          If cursorArea = 'File' | cursorArea = 'Prefix' Then
            CursorLine = 1
        End
        Otherwise
        Do
          If datatype(cmd2,'WHOLE') = 1 & cmd2 > 0 Then
            curline = min(size+1,curline+cmd2)
          Else
            msg = 'Invalid command: "'MixedCmd'". Syntax: Down <nnn>'
        End
      End
    End
 
    When ABBREV('DATASET',cmd1) Then
    Do
      If cmd2 ^= '' Then
      Do
        dset = CheckName(cmd2)
        Do ir = 1 to NrRing
          r = word(rings,ir)
          If ring.r.sdataset = dset Then
          Do
            msg = dset 'already in XEDIT ring ('r')'
            ir = NrRing+10
          End
        End
        If ir = NrRing+1 Then
          dataset = dset
      End
      Else
        msg = 'Invalid command: "'MixedCmd'". Syntax: DAtaset dset'
    End
 
    When ABBREV('DELETE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' Then cmd2 = 1
        If cmd2 = '*' Then cmd2 = size-curline+1
        If datatype(cmd2,'WHOLE') = 1 & cmd2 > 0 Then
        Do
          alt = alt+1
          Call DelLines curline, cmd2
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: DElete <nnn>'
      End
    End
 
    When ABBREV('DELETEDUPLICATE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' Then
        Do
          SavedSize = size
          Do i = size to max(curline,1) by -1
            Line_i = line.i
            Do j = i-1 to max(curline,1) by -1 while Line_i = line.j
            End
            If j < i-1 Then
              Call DelLines j+1, i-j-1
          End
          If SavedSize ^= size Then
            alt = alt+1
          msg = SavedSize-Size 'lines deleted'
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: DELETEDuplicate'
      End
    End
 
    When ABBREV('DELETELINES',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If right(cmd,1) = '/' Then
          Parse var Mixedcmd . not '/' string '/'
        Else
          Parse var Mixedcmd . not '/' string
        If string ^= '' Then
        Do
          If word(case,2) = 'IGNORE' Then
            string = translate(,
               string, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
          If (substr(string,1,2) = "X'" | substr(string,1,2) = "x'") &,
             substr(string,length(string),1) = "'" Then
          Do
            string = translate(substr(string,3,length(string)-3))
            If verify(string,'1234567890ABCDEF') ^= 0 | ,
               length(string)//2 = 1 Then
            Do
              msg = 'Invalid hex string:' string
              return
            End
            string = x2c(string)
          End
        End
        If not = '^' | not = '' Then
        Do
          SavedSize = size
          Do i = size to max(curline,1) by -1
            Line_i = line.i' '
            If word(case,2) = 'IGNORE' Then
              Line_i = translate(,
                 Line_i, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
            If (string = '' &,
                ((not = '^' & Line_i ^= '') |,
                 (not = '' & Line_i = '')) ) |,
               (string ^= '' &,
                ((not = '^' & pos(string,Line_i)=0) |,
                 (not = '' & pos(string,Line_i)>0)) ) Then
              Call DelLines i, 1
          End
          If SavedSize ^= size Then
            alt = alt+1
          msg = SavedSize-Size 'lines deleted'
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: DELETELines <^>/string/'
      End
    End
 
    When ABBREV('DIRECTORY',cmd1) Then
    Do
      If dsorg ^= 'PO' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' Then
        Do
          parse var dataset pds '(' mem ')'
          cmd = 'XEDIT' pds
          call HandleCommand
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: DIrectory'
      End
    End
 
    When ABBREV('DRING',cmd1) Then
      Call DisplayRing
 
    When ABBREV('DTAGS',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
        Call DisplayTags
    End
 
    When ABBREV('EDIT',cmd1) Then
    Do
      If cmd2 = '' Then
        dset = dataset
      Else
        dset = CheckName(cmd2)
      Address ISPEXEC 'CONTROL ERRORS RETURN'
      Address ISPEXEC "EDIT DATASET('"dset"')"
      Select
        When rc=4 Then
          msg = 'Dataset' dset 'not saved'
        When rc=12 Then
          msg = 'Dataset' dset 'is empty'
        When rc=14 Then
          msg = 'Member or dataset' dset 'in use'
        When rc=16 Then
          msg = 'No members in dataset' dset
        When rc=20 Then
          msg = 'Severe error during EDIT of' dset
        Otherwise
          ;
      End
    End
 
    When ABBREV('EDITALL',cmd1) Then
    Do
      If xtype ^= 'FILE' Then          /* DIR or DLIST?               */
      Do
        If xtype = 'DIR' Then          /* display dataset list        */
          parse var dataset pds '(' .
        Do ii = 1 to size
          If xtype = 'DLIST' Then      /* display dataset list        */
            Call QueueCommand 'EDIT' Word(line.ii,1)
          Else                         /* display directory list      */
          Do
            If xxgroup2||xxgroup3||xxgroup4 = '' Then
              Call QueueCommand 'EDIT' pds'('Word(line.ii,1)')'
            Else
            Do
              parse var pds pr '.' gr '.' ty
              Select
                When Word(line.ii,2) = '1' Then
                  Call QueueCommand 'EDIT' pr'.'gr'.'ty'('Word(line.ii,1)')'
                When Word(line.ii,2) = '2' Then
                  Call QueueCommand 'EDIT' pr'.'xxgroup2'.'ty'('Word(line.ii,1)')'
                When Word(line.ii,2) = '3' Then
                  Call QueueCommand 'EDIT' pr'.'xxgroup3'.'ty'('Word(line.ii,1)')'
                Otherwise
                  Call QueueCommand 'EDIT' pr'.'xxgroup4'.'ty'('Word(line.ii,1)')'
              End
            End
          End                          /* end directory list          */
        End
      End
      Else
        msg = Not_Allowed
    End
 
    When ABBREV('EOL',cmd1) Then
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
        Call EndOfLine
 
    When ABBREV('EXEC',cmd1) Then
    Do
      If cmd2 = '' Then
        "EXEC" "'"dataset"'"
      Else
        "EXEC" cmd2
    End
 
    When ABBREV('FILE',cmd1) Then
    Do
      If cmd2 = '' | datatype(cmd2,'WHOLE') = 0 Then
      Do
        Call SaveDataset cmd2
        If result = 0 Then
        Do
          msg = dset 'filed'
          msgstat = msg('off')
          If AutosaveDset ^= '' Then
            "DELETE '"AutosaveDset"'"
          msgstat = msg(msgstat)
          NrRing = NrRing-1
          If NrRing > 0 Then
          Do
            Call DropRing CurRing
            rings = ' 'SubWord(rings,1,curring-1),
                    Subword(rings,curring+1)' '
            If CurRing >= NrRing Then
              CurRing = NrRing
            Call GetRing CurRing
          End
          Else
            Do
              x = dropispf(load_info);Exit
            End
        End
      End
      Else
      Do
        If datatype(cmd2,'WHOLE') = 1 & cmd2 > 0 Then
        Do i = 1 to cmd2
          Call QueueCommand 'FILE'
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: File <<nnn>|<dset>>'
      End
    End
 
    When ABBREV('FINDDUPLICATE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse upper var cmd2 c1 c2 rest
        If c1 = '' Then c1 = 1
        If c2 = '' Then c2 = lrecl
        If datatype(c1,'WHOLE') = 1 & datatype(c2,'WHOLE') = 1 &,
           c1>=0 & c2<=lrecl & c1<=c2 Then /* correct invocation?     */
        Do                             /* yes, not a dslist or dir.?  */
          c3 = c2-c1+1                 /* number of columns to sort   */
          i = max(curline+1,1)
          found = 'No'
          Do while i < size & found = 'No';
            j = i+1
            If Substr(line.i,c1,c3) = Substr(line.j,c1,c3) Then
            Do
              found = 'Yes'
              curline = i
              msg = 'Duplicate line (in columns' c1 'to' c2') found'
            End
            Else
              i = i + 1
          End
          If found = 'No' Then
            msg = 'No duplicate lines found (in columns' c1 'to' c2') from line' max(curline+1,1)
        End
        Else                           /* incorrect invocation        */
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: FINduplicate <col1> <col2>'
      End
    End
 
    When ABBREV('FINDUNIQUE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse upper var cmd2 c1 c2 rest
        If c1 = '' Then c1 = 1
        If c2 = '' Then c2 = lrecl
        If datatype(c1,'WHOLE') = 1 & datatype(c2,'WHOLE') = 1 &,
           c1>=0 & c2<=lrecl & c1<=c2 Then /* correct invocation?     */
        Do                             /* yes, not a dslist or dir.?  */
          c3 = c2-c1+1                 /* number of columns to sort   */
          i = max(curline+1,2)
          found = 'No'
          Do while i < size & found = 'No'
            j = i-1
            k = i+1
            If Substr(line.i,c1,c3) ^= Substr(line.j,c1,c3) &,
               Substr(line.i,c1,c3) ^= Substr(line.k,c1,c3) Then
            Do
              found = 'Yes'
              msg = 'Lines' i 'is unique in columns' c1 'to' c2
              curline = i
            End
            Else
              i = i + 1
          End
          If found = 'No' Then
            msg = 'No unique lines found in columns' c1 'to' c2
        End
        Else                           /* incorrect invocation        */
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: FINDUnique <col1> <col2>'
      End
    End
 
    When ABBREV('FRING',cmd) Then
    Do
      CurNrRing = NrRing
      Do RingNr = 1 to CurNrRing
        PrevDataset = dataset
        cmd = 'FILE'
        call HandleCommand
        If PrevDataset = dataset Then
        Do
          cmd = 'XEDIT'
          call HandleCommand
        End
      End
    End
 
    When ABBREV('GET',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If PutLines = 0 Then
          msg = 'No lines saved in "PUT-file"'
        Else
        Do
          alt = alt+1
          GetLine = min(size,curline)
          Call AddLines GetLine,PutLines
          NrSplit = 0
          If size=0 Then GetLine = 0
          l = Getline
          InsertedLines = PutLines
          Do k = 1 to PutLines
            l = l+1
            If Length(Strip(PutLine.k,'T')) > lrecl Then
            Do
              ExtraLines = Length(Strip(PutLine.k,'T'))%lrecl
              If Length(Strip(PutLine.k,'T'))//lrecl = 0 Then
                ExtraLines = ExtraLines - 1
              InsertedLines = InsertedLines+ExtraLines
              Call AddLines l,ExtraLines
              NrSplit = NrSplit+1
              Do e = 0 to ExtraLines
                Line.l = substr(PutLine.k,e*lrecl+1,lrecl)
                l = l+1
              End
              l = l-1
            End
            Else
              Line.l = PutLine.k
          End
          If NrSplit > 0 Then
            msg = InsertedLines 'Lines inserted,' NrSplit 'line(s) split'
        End
      End
    End
 
    When ABBREV('GROUP',cmd1) Then
    Do
      If verify(substr(cmd2,1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ') = 0 &,
         verify(cmd2,'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890') = 0 &,
         length(cmd2) <= 8 Then
      Do
        Parse var dataset project '.' group'.'rest
        If group ^= '' Then
        Do
          dset = project'.'cmd2'.'rest
          Do ir = 1 to NrRing
            r = word(rings,ir)
            If ring.r.sdataset = dset Then
            Do
              msg = dset 'already in XEDIT ring ('r')'
              ir = NrRing+10
            End
          End
          If ir = NrRing+1 Then
            dataset = dset
        End
        Else
          msg = 'Group can not be updated'
      End
      Else
        msg = 'Incorrect group-name "'cmd2'" specified'
    End
 
    When ABBREV('HEX',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        Select
          When cmd2 = '' Then
          Do
            If hex = 'ON' Then
              hex = 'OFF'
            Else
              hex = 'ON'
          End
          When ABBREV('ON',cmd2) Then
            hex = 'ON'
          When ABBREV('OFF',cmd2) Then
            hex = 'OFF'
          Otherwise
            msg = 'Invalid command: "'MixedCmd'". Syntax: Hex <On|OFf>'
        End
      End
    End
 
    When ABBREV('HORIZONTAL',cmd1) Then
    Do
      Select
        When cmd2 = '' Then
        Do
          If horizontal = 'ON' Then
            horizontal = 'OFF'
          Else
            horizontal = 'ON'
        End
        When ABBREV('ON',cmd2) Then
          horizontal = 'ON'
        When ABBREV('OFF',cmd2) Then
          horizontal = 'OFF'
        Otherwise
          msg = 'Invalid command: "'MixedCmd'". Syntax: HOrizontal <On|OFf>'
      End
      If msg = '' Then
        msg = 'HORIZONTAL' horizontal
    End
 
    When ABBREV('INSERT',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' then cmd2 = 1
        If datatype(cmd2,'WHOLE') = 1 & cmd2 > 0 Then
        Do
          Call AddLines max(0,curline-1), cmd2
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: Insert <nnn>'
      End
    End
 
    When ABBREV('INPUT',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        Call AddLines curline, 1
        k = min(curline+1,size)
        Line.k = SubWord(MixedCmd,2)
        alt = alt+1
      End
    End
 
    When ABBREV('ICPRINT',cmd1) Then
    Do
      InTSOcmd = 'Yes'
      If cmd2 = '' then
        cmd2 = "'"dataset"'"
      Parse var cmd2 dset '(' mem ')' rest
      If mem ^= '' Then
      Do
        Select
          When rest = "'" Then
            cmd2 = dset"' ( member("mem")"
          When rest = "" Then
            cmd2 = dset "(member("mem")"
          Otherwise
            cmd2 = dset||rest
        End
      End
      "ICPR" cmd2
      InTSOcmd = 'No'
    End
 
    When ABBREV('JUSTIFY',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse upper var MixedCmd . LeftRight Space Jstart Jend
        If LeftRight = '' Then LeftRight = 'LEFT'
        If Space = '' Then Space = 1
        If Jstart = '' Then Jstart = 1
        If Jend = '' Then Jend = lrecl
        If Jend > lrecl Then Jend = lrecl
        If (ABBREV('LEFT',LeftRight,1) | ABBREV('RIGHT',LeftRight,1)) &,
           datatype(Space,'WHOLE') = 1 & Space >= 0 &,
           datatype(Jstart,'WHOLE') = 1 & Jstart > 0 &,
           datatype(Jend,'WHOLE') = 1 & Jend > Jstart Then
        Do
          Spaces = Substr('',1,Space+1)
          If Substr(LeftRight,1,1) = 'R' Then
          Do
            j = Jstart
            Jstart = lrecl-Jend+1
            Jend = lrecl-J+1
          End
          Do i = 1 to size
            If Substr(LeftRight,1,1) = 'R' Then
              string = Reverse(Substr(line.i,1,lrecl))
            Else
              string = line.i
            s2 = Substr(string, Jstart, Jend-Jstart+1)
            j = Pos(Spaces,S2)
            Do while j > 0
              If Substr(s2,j) ^= '' Then
              Do
                k = Verify(Substr(s2,j),' ')
                s2 = Delstr(s2,j,k-space-1)
                j = Pos(Spaces,S2)
              End
              Else
                j = 0
            End
            String = Substr(string, 1, Jstart-1) ||,
                     Substr(S2, 1, Jend-Jstart+1) ||,
                     Substr(string, Jend+1,Lrecl-Jend)
            If Substr(LeftRight,1,1) = 'R' Then
              line.i = Reverse(Substr(string,1,lrecl))
            Else
              line.i = string
          End
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd||,
                '". Syntax: JUstify <left|right> <fromcol> <tocol>'
      End
    End
 
    When ABBREV('LIBRARY',cmd1) Then
      Address ISPEXEC 'SELECT PGM(ISRUDA) PARM(ISRUDA1) SCRNAME(LIBUTIL)'
 
    When ABBREV('LIST',cmd1) Then
    Do
      If cmd2 = '' Then
        parse var dataset dset '(' .
      Else
        dset = CheckName(cmd2)
      Address ISPEXEC 'CONTROL ERRORS RETURN'
      Address ISPEXEC "LMDINIT LISTID(ID) LEVEL("dset")"
      If rc = 0 Then
      Do
        Address ISPEXEC "LMDDISP LISTID("id")"
        If rc ^= 0 Then
          msg = 'No datasets found matching' dset
      End
      Else
        msg = zerrlm
      Address ISPEXEC "LMDFREE LISTID("id")"
    End
 
    When ABBREV('LISTALC',cmd1) Then
    Do
      If Pipes = 1 Then
      "PIPE (End ?)          ",
      "   TSO LISTALC STATUS ",
      "|  stem listalc.      "
      Else
      Do
        Call Outtrap 'listalc.'
        Address TSO "LISTALC STATUS "
        Call Outtrap 'off'
      End
 
      Say "DDname   Disposition   Dataset"
      Say "======== ============= ====================================="
      li = 2
      Do while li <= listalc.0
        If Word(listalc.li,1) = "NULLFILE" |,
           Word(listalc.li,1) = "TERMFILE" Then
        Do
          Say Substr(listalc.li,11,8) Copies(' ',13) Substr(listalc.li,1,8)
          li = li+1
        End
        Else
        Do
          lj = li+1
          Say Substr(listalc.lj,3,8) Substr(listalc.lj,12,13) Strip(listalc.li)
          li = li+2
        End
      End
    End
 
    When ABBREV('LEFT',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' then cmd2 = 40
        If ABBREV('CSR',cmd2) Then
        Do
          If cursorArea = 'File' Then
            If CursorPos = 73 Then
              cmd2 = 72
            Else
              cmd2 = 73-CursorPos
          Else
            cmd2 = 40
        End
        If datatype(cmd2,'WHOLE') = 1 Then
        Do
          SavedStartcol = Startcol
          Startcol = max(Startcol-abs(cmd2),1)
          If cursorArea = 'File' Then
            CursorPos = min(CursorPos+(SavedStartcol-Startcol),73)
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: Left <nnn>'
      End
    End
 
    When ABBREV('LANGUAGE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        Select
          When cmd2 = '' Then
          Do
            If language = 'REXX' Then
              language = 'PL1'
            Else
              language = 'REXX'
          End
          When ABBREV('REXX',cmd2) Then
            language = 'REXX'
          When ABBREV('PL1',cmd2) Then
            language = 'PL1'
          Otherwise
            msg = 'Invalid command: "'MixedCmd'". Syntax: LAnguage <Rexx|Pl1>'
        End
        If msg = '' Then
          msg = 'LANGUAGE' language
      End
    End
 
    When ABBREV('LOWERCASE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' Then cmd2 = 1
        If (datatype(cmd2,'WHOLE') = 1 & cmd2 > 0) | cmd2 = '*' Then
        Do
          If curline = 0 Then
            LowerStart = 1
          Else
            LowerStart = curline
          If cmd2 = '*' Then
            LowerLines = max(size-LowerStart+1,0)
          Else
            LowerLines = max(min(size-LowerStart+1,cmd2),0)
          Call Lowercase LowerStart,LowerLines
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: LOWercase <nnn|*>'
      End
    End
 
    When ABBREV('LOCK',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        Parse var dataset project'.'group'.'type'('mem')'
        dset = project'.'userid()'.'type'('mem')'
        Do ir = 1 to NrRing
          r = word(rings,ir)
          If ring.r.sdataset = dset Then
          Do
            msg = dset 'already in XEDIT ring ('r')'
            return
          End
        End
        Call CheckDataset dset
        If result = 0 Then
        Do
          msg = mem "already exists in '"project"."userid()"."type"'"
          return
        End
        If result > 4 Then
        Do
          msg = "'"project"."userid()"."type"' does not exist"
          return
        End
        If result ^= 4 | sysdsorg ^= 'PO' | ,
           group = userid() | type = '' | mem = '' Then
        Do
          msg = dataset 'is not an LMF controlled dataset'
          return
        End
        If group = 'DEV' | group = 'SYS' | group = 'REL' Then
        Do                             /* special naming for FIRE     */
          If group = 'REL' Then
          Do
            Call CheckDataset project".SYS."type"("mem")"
            If result = 0 Then
            Do
              msg = mem "also exists in '"project".SYS."type"'"
              return
            End
          End
          If group = 'SYS' | group = 'REL' Then
          Do
            Call CheckDataset project".DEV."type"("mem")"
            If result = 0 Then
            Do
              msg = mem "also exists in '"project".DEV."type"'"
              return
            End
          End
        End
        Else                           /* normal group names eg:      */
        Do                             /* JIS1300D, JIS1300S, etc     */
          If Right(group,1) = "B" Then
          Do
            Call CheckDataset project"."right(group,2)"S."type"("mem")"
            If result = 0 Then
            Do
              msg = mem "also exists in '"project"."right(group,2)"S."type"'"
              return
            End
          End
          If Right(group,1) = "B" | Right(group,1) = "S" Then
          Do
            Call CheckDataset project"."right(group,2)"D."type"("mem")"
            If result = 0 Then
            Do
              msg = mem "also exists in '"project"."right(group,2)"D."type"'"
              return
            End
          End
        End                            /* end normal group names      */
 
        Address ISPEXEC "LMINIT DATAID(ID) PROJECT("project")" ,
                        "GROUP1("group") TYPE("type")"
        LockRc = rc
 
        If rc = 0 Then
        Do
          Address ISPEXEC "LMOPEN DATAID("id")"
          Address ISPEXEC "LMMFIND DATAID("id")" ,
                          "STATS(YES) MEMBER("member")"
          CurrTimestamp = zlmdate'|'zlmtime'|'zlmsec
          LockRequested = 'Yes'
          If CurrTimestamp ^= Timestamp Then
            Call AskConfirmation
          If LockRequested = 'Yes' Then
          Do
            Address ISPEXEC "LMMFIND DATAID("id")" ,
                            "LOCK MEMBER("mem")"
            LockRc = rc
          End
          Address ISPEXEC "LMCLOSE DATAID("id")"
          Address ISPEXEC "LMFREE DATAID("id")"
        End
        If lockRc = 0 & LockRequested = 'Yes' Then
        Do
          dataset = dset
          cmd = 'SAVE'
          call HandleCommand
          msg = mem 'locked and saved'
        End
        Else
        Do
          If LockRequested = 'Yes' Then
            msg = 'Lock 'mem' failed: 'zerrlm
          Else
            msg = mem 'not locked on user request'
        End
      End
    End
 
    When ABBREV('LRECL',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 ^= '' & datatype(cmd2,'WHOLE') = 1 & cmd2 > 0 Then
          lrecl = cmd2
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: LRecl <nnn>'
      End
    End
 
    When ABBREV('MEMBER',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If verify(substr(cmd2,1,1),'$#@ABCDEFGHIJKLMNOPQRSTUVWXYZ') = 0 &,
           verify(cmd2,'$#@ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890') = 0 &,
           length(cmd2) <= 8 Then
        Do
          Parse var dataset rest'('mem')'
          If mem ^= '' Then
          Do
            dset = rest'('cmd2')'
            Do ir = 1 to NrRing
              r = word(rings,ir)
              If ring.r.sdataset = dset Then
              Do
                msg = dset 'already in XEDIT ring ('r')'
                ir = NrRing+10
              End
            End
            If ir = NrRing+1 Then
            Do
              dataset = dset
              member = mem
            End
          End
          Else
            msg = 'Dataset is not a PDS'
        End
        Else
          msg = 'Incorrect member-name "'cmd2'" specified'
      End
    End
 
    When ABBREV('MSG',cmd1) Then
      msg = Subword(MixedCmd,2)
 
    When ABBREV('NULLS',cmd1) Then
    Do
      Select
        When cmd2 = '' Then
        Do
          If nulls = 'ON' Then
            nulls = 'OFF'
          Else
            nulls = 'ON'
        End
        When ABBREV('ON',cmd2) Then
          nulls = 'ON'
        When ABBREV('OFF',cmd2) Then
          nulls = 'OFF'
        Otherwise
          msg = 'Invalid command: "'MixedCmd'". Syntax: Nulls <On|OFf>'
      End
      If msg = '' Then
        msg = 'NULLS' nulls
    End
 
    When cmd1 = 'PC' Then
    Do
      Numeric Digits 20
      If cmd2 ^= '' & cmd2 ^= '?' Then
      Do
        If InterpretSupported = 'No' Then
          msg = PC(cmd2)
        Else
        Do
          InPC = 'Yes'
          Interpret 'pc_result = 'cmd2
          Hex_result = D2X(Trunc(Abs(pc_result)))
          Hex_result = '=X('hex_result')'
          Hex_result = Hex_result
          msg = 'PC:' cmd2'='pc_result||Hex_result
          InPC = 'No'
        End
      End
      Else
        msg = 'PC preforms calculations for you.',
              'Try PC 5*5 or PC X(BEEF)-(X(BAF)+9*214)'
    End
 
    When ABBREV('PFKEY',cmd1) Then
    Do
      Parse var MixedCmd . pfk pfcommand
      Upper pfk
      If pfk >= 'PF01' & pfk <= 'PF24' Then
      Do
        PFcmd.pfk = pfcommand
        msg = 'PFkey' pfk 'set to "'pfcommand'"'
      End
      Else
        msg = 'Invalid command: "'MixedCmd'". Syntax: PFKEY PFxx <command>'
    End
 
    When ABBREV('PFKEYLINE',cmd1) Then
      Parse var MixedCmd . PFkeyLine
 
    When ABBREV('PREFIX',cmd1) Then
    Do
      Select
        When cmd2 = '' Then
        Do
          If Xprefix = 'LEFT' Then
            Xprefix = 'RIGHT'
          Else
            Xprefix = 'LEFT'
        End
        When ABBREV('LEFT',cmd2) Then
          Xprefix = 'LEFT'
        When ABBREV('RIGHT',cmd2) Then
          Xprefix = 'RIGHT'
        Otherwise
          msg = 'Invalid command: "'MixedCmd'". Syntax: PRefix <Left|Righr>'
      End
    End
 
    When ABBREV('PREFIXCMD',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        parse var MixedCmd . nnn command
        Upper name
        If Datatype(nnn,'WHOLE') ^= 1 Then
        Do
          nnn = curline
          parse var MixedCmd . command
        End
        If nnn < size & command ^= '' Then
          Call SetPrefixCmd command, nnn
        Else
          msg = 'Command omitted. Syntax: PREFIXCmd <nnn> command'
      End
    End
 
    When ABBREV('PRINT',cmd1) Then
    Do
      If cmd2 = '' Then
        ZHDSN = "'"dataset"'"
      Else
        ZHDSN = "'"CheckName(cmd2)"'"
      Address ISPEXEC 'VPUT (ZHDSN)'
      Address ISPEXEC 'CONTROL ERRORS RETURN'
      Address ISPEXEC "SELECT PGM(ISRUHC) SCRNAME(HARDCOPY)"
    End
 
    When ABBREV('PRIBIG',cmd1) Then
    Do
      If cmd2 = '' Then
        dset = "'"dataset"'"
      Else
        dset = "'"CheckName(cmd2)"'"
      "PRIBIG" dset
    End
 
    When ABBREV('PROJECT',cmd1) Then
    Do
      If verify(substr(cmd2,1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ') = 0 &,
         verify(cmd2,'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890') = 0 &,
         length(cmd2) <= 8 Then
      Do
        Parse var dataset project'.'rest
        dset = cmd2'.'rest
        Do ir = 1 to NrRing
          r = word(rings,ir)
          If ring.r.sdataset = dset Then
          Do
            msg = dset 'already in XEDIT ring ('r')'
            ir = NrRing+10
          End
        End
        If ir = NrRing+1 Then
          dataset = dset
      End
      Else
        msg = 'Incorrect project-name "'cmd2'" specified'
    End
 
    When ABBREV('PUT',cmd1) Then
    Do
      If cmd2 = '' Then cmd2 = 1
      If datatype(cmd2,'WHOLE') = 1 | cmd2 = '*' Then
      Do
        If curline = 0 Then
          PutStart = 1
        Else
          PutStart = curline
        If cmd2 = '*' Then
          PutLines = max(size-PutStart+1,0)
        Else
          PutLines = max(min(size-PutStart+1,cmd2),0)
        Do k = 1 to PutLines
          l = PutStart+k-1
          PutLine.k = Line.l
        End
      End
      Else
        msg = 'Invalid command: "'MixedCmd'". Syntax: PUt <nnn|*>'
    End
 
    When ABBREV('QUIT',cmd1) Then
    Do
      If cmd2 = '' Then
      Do
        If alt = 0 & totalalt = 0 Then
        Do
          msgstat = msg('off')
          If AutosaveDset ^= '' Then
            "DELETE '"AutosaveDset"'"
          msgstat = msg(msgstat)
          NrRing = NrRing-1
          If NrRing > 0 Then
          Do
            Call DropRing CurRing
            rings = ' 'SubWord(rings,1,CurRing-1),
                    Subword(rings,CurRing+1)' '
            If CurRing >= NrRing Then
              CurRing = NrRing
            Call GetRing CurRing
          End
        End
        Else
          msg = 'Use FILE to save or QQUIT to cancel updates'
      End
      Else
      Do
        If datatype(cmd2,'WHOLE') = 1 & cmd2 > 0 Then
        Do i = 1 to cmd2
          Call QueueCommand 'QUIT'
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: Quit <nnn>'
      End
    End
 
    When ABBREV('QRING',cmd) Then
    Do
      CurNrRing = NrRing
      Do RingNr = 1 to CurNrRing
        If alt = 0 & totalalt = 0 Then
          cmd = 'QUIT'
        Else
          cmd = 'XEDIT'
        call HandleCommand
      End
    End
 
    When ABBREV('QQUIT',cmd1) Then
    Do
      If cmd2 = '' Then
      Do
        msgstat = msg('off')
        If AutosaveDset ^= '' Then
          "DELETE '"AutosaveDset"'"
        msgstat = msg(msgstat)
        NrRing = NrRing-1
        If NrRing > 0 Then
        Do
          Call DropRing CurRing
          rings = ' 'SubWord(rings,1,curring-1),
                  Subword(rings,curring+1)' '
          If CurRing >= NrRing Then
            CurRing = NrRing
          Call GetRing CurRing
        End
      End
      Else
      Do
        If datatype(cmd2,'WHOLE') = 1 & cmd2 > 0 Then
        Do i = 1 to cmd2
          Call QueueCommand 'QQUIT'
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: QQuit <nnn>'
      End
    End
 
    When ABBREV('QQRING',cmd) Then
    Do
      Do while NrRing > 0
        cmd = 'QQUIT'
        call HandleCommand
      End
    End
 
    When ABBREV('QUERY',cmd1) Then
    Do
      If ABBREV('ALT',cmd2,1) = 1 | cmd2 = '*' Then
        Say 'total alt = 'totalalt+alt
      If ABBREV('AUTOSAVE',cmd2,1) = 1 | cmd2 = '*' Then
      Do
        If autosave > 0 Then
          Say 'autosave  = ON 'autosave
        Else
          Say 'autosave  = OFF'
        If autosavedset ^= '' Then
          Say "Dataset is autosaved in '"autosavedset"'"
      End
      If ABBREV('CASE',cmd2,1) = 1 | cmd2 = '*' Then
        Say 'case      = 'case
      If ABBREV('LANGUAGE',cmd2,1) = 1 | cmd2 = '*' Then
        Say 'language  = 'language
      If ABBREV('NULLS',cmd2,1) = 1 | cmd2 = '*' Then
        Say 'nulls     = 'nulls
      If ABBREV('PFKEYS',cmd2,1) = 1 | cmd2 = '*' Then
      Do i = 1 to 24
        pfk = 'PF'||substr(100+i,2,2)
        Say pfk '=' PFcmd.pfk
      End
      If ABBREV('RING',cmd2,1) = 1 | cmd2 = '' | cmd2 = '*' Then
      Do i = 1 to NrRing
        r = word(rings,i)
        Say 'Ring.'substr(i,1,5)'= 'ring.r.sdataset
      End
      If ABBREV('SYNONYM',cmd2,1) = 1 | cmd2 = '*' Then
      Do i = 1 to NrSynonyms
        Say 'Synonym' Synonym.i SynLen.i SynCmd.i
      End
      If ABBREV('TABS',cmd2,3) = 1 | cmd2 = '*' Then
        Say 'TABS' tabs
      If ABBREV('TAGCHANGE',cmd2,4) = 1 | cmd2 = '*' Then
        Say 'TAGCHANGE' tagchange
      If ABBREV('TAGS',cmd2,4) = 1 | cmd2 = '*' Then
      Do i = 1 to words(tags)
        t = word(tags,i)
        If Datatype(tag.t,'W') = 1 Then
        Do
          linenr = tag.t
          Say '.'t 'at line' linenr '=' Substr(line.linenr,1,60)
        End
      End
      If ABBREV('TIMEZONE',cmd2,4) = 1 | cmd2 = '*' Then
        Say 'TIMEZONE' timezone
    End
 
    When cmd1 = '?' | ABBREV('RECALL',cmd1) Then
    Do
      If cmd2 ^= '' then
      Do
        If datatype(cmd2,'WHOLE') = 1 & cmd2 > 0 & cmd2 <= 40 Then
        Do
          SaveCmd = RecallCmd.cmd2
          KeepCommand = 'On'
        End
        Else
          Call RecallCmd
      End
      Else
        Call RecallCmd
    End
 
    When ABBREV('RESET',cmd) Then
      command. = ''
 
    When ABBREV('RIGHT',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' then cmd2 = 40
        If ABBREV('CSR',cmd2) Then
        Do
          If cursorArea = 'File' Then
            If CursorPos = 1 Then
              cmd2 = 72
            Else
              cmd2 = CursorPos-1
          Else
            cmd2 = 40
        End
        If datatype(cmd2,'WHOLE') = 1 Then
        Do
          SavedStartcol = Startcol
          Startcol = min(max(1,Lrecl-72),Startcol+abs(cmd2))
          If cursorArea = 'File' Then
            CursorPos = max(1,CursorPos+(Savedstartcol-Startcol))
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: Right <nnn>'
      End
    End
 
    When ABBREV('SAVE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        Call SaveDataset cmd2
        If result = 0 Then
        Do
          alt = 0
          totalalt = 0
          msg = dset 'saved'
        End
      End
    End
 
    When ABBREV('SDSF',cmd1) Then
    Do
      If cmd2 = '' Then
        cmd2 = 'DA'
      Address ISPEXEC 'CONTROL ERRORS RETURN'
      /*
      Address ISPEXEC "SELECT CMD(%RZAELGC SDSF@ FN('CMD(%SDSFLIBR NA" cmd2")  '))"
      */
      Address ISPEXEC "SELECT PGM(ISFISP) NOCHECK PARM("cmd2")"
    End
 
    When ABBREV('SEARCH',cmd1) Then
      Address ISPEXEC 'SELECT PGM(ISRSFM) SCRNAME(SRCHFOR)'
 
    When ABBREV('SORT',cmd1) Then
    Do
      parse upper var cmd2 order c1 c2 rest
      If order ^= 'A' & order ^= 'D' Then
      Do
        c2 = c1
        c1 = order
        order = 'A'
      End
      If xtype = 'DLIST' Then
      Do
        Select
          When ABBREV('DSORG',c1) Then   c1 = 48
          When ABBREV('RECFM',c1) Then   c1 = 54
          When ABBREV('LRECL',c1) Then   c1 = 60
          When ABBREV('SIZE',c1) Then    c1 = 66
          When ABBREV('VOLUME',c1) Then  c1 = 73
          Otherwise                      c1 = 1
        End
      End
      If xtype = 'DIR' Then
      Do
        Select
          When ABBREV('MEMBER',c1) Then     c1 = 1
          When ABBREV('LIB',c1) Then        c1 = 19
          When ABBREV('MOD',c1) Then        c1 = 13
          When ABBREV('CREATED',c1) Then    c1 = 27
          When ABBREV('MODIFIED',c1) Then   c1 = 38
          When ABBREV('TIME',c1) Then       c1 = 49
          When ABBREV('SIZE',c1) Then       c1 = 55
          When ABBREV('INIT',c1) Then       c1 = 63
          When ABBREV('USER',c1) Then       c1 = 71
          Otherwise                         c1 = 1
        End
      End
      If c1 = '' Then c1 = 1
      If c2 = '' Then c2 = lrecl
      If datatype(c1,'WHOLE') = 1 & datatype(c2,'WHOLE') = 1 &,
         c1>=0 & c2<=lrecl & c1<=c2 Then /* correct invocation?       */
      Do                               /* yes, not a dslist or dir.?  */
        If xtype = 'FILE' Then
          alt = alt+1                  /* increase number of changes  */
 
        If size > 1 Then
        Do
          line.0 = size
          If Pipes = 1 Then
            'PIPE  stem line. | sort' c1'-*' order '| stem line.'
          Else
            msg = 'Invalid command: "'MixedCmd||,
                  '". Pipes not available'
        End
 
      End                              /* end correct invocation      */
      Else                             /* incorrect invocation        */
        msg = 'Invalid command: "'MixedCmd||,
              '". Syntax: SOrt <A|D> <col1> <col2>'
    End
 
    When ABBREV('SPLITJOIN',cmd1,6) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
        Call SplitJoin
    End
 
    When ABBREV('SRING',cmd) Then
    Do
      Do RingNr = 1 to NrRing
        If xtype = 'FILE' Then
        Do
          cmd = 'SAVE'
          call HandleCommand
        End
        cmd = 'XEDIT'
        call HandleCommand
      End
    End
 
    When ABBREV('SSID',cmd1) Then
    Do
      If cmd2 ^= '' Then
      Do
        DB2subsystem = cmd2
        msg = 'DB2 subsystem-ID is set to' DB2subsystem
      End
      Else
        msg = 'Invalid command: "'MixedCmd'". Syntax: SSID <DB2sys>'
    End
 
    When ABBREV('STATISTICS',cmd1) Then
    Do
      Select
        When cmd2 = '' Then
        Do
          If statistics = 'ON' Then
            statistics = 'OFF'
          Else
            statistics = 'ON'
        End
        When ABBREV('ON',cmd2) Then
          statistics = 'ON'
        When ABBREV('OFF',cmd2) Then
          statistics = 'OFF'
        Otherwise
          msg = 'Invalid command: "'MixedCmd'". Syntax: STatistics <On|OFf>'
      End
    End
 
    When ABBREV('SUBMIT',cmd1) Then
    Do
      If cmd2 = '' Then
      Do
        If xtype ^= 'FILE' Then
          msg = 'Dataset omitted on SUBMIT command'
        Else
        Do
          TempDset = CheckTempDataset('SUBMIT')
          If TempDset = '' Then
          Do
            msg = 'Submit canceled'
            return
          End
          cmd="ALLOCATE FI(ZYXEDITQ) DA("TempDset")" ,
              "SPACE(5,5) TRACKS LRECL(80) BLKSIZE(0) DSORG(PS) NEW REUSE"
          cmd
          If rc ^= 0 Then
          Do
            msg = 'Unexpected return code from "'cmd'", rc='rc
            Return 16
          End
          'EXECIO 'size' DISKW ZYXEDITQ (STEM LINE. FINIS'
          'FREE FI(ZYXEDITQ)'
 
          Drop trapmsg.
          x = outtrap('trapmsg.')
          "SUBMIT "TempDset
          SubmitRc = rc
          "DELETE "TempDset
          x = outtrap('OFF')
 
          If SubmitRc = 0 Then
          Do
            Parse var trapmsg.1 . job .
            msg = dataset 'submitted as' job
          End
          Else
            msg = 'Submit' dataset 'failed,' trapmsg.1
        End
      End
      Else
      Do
        x = outtrap('trapmsg.')
        "SUBMIT "cmd2
        submitRc = rc
        x = outtrap('OFF')
        If SubmitRc = 0 Then
        Do
          Parse var trapmsg.1 . job .
          msg = cmd2 'submitted as' job
        End
        Else
          msg = 'Submit' cmd2 'failed,' trapmsg.1
      End
    End
 
    When ABBREV('SUPERC',cmd1) Then
      Address ISPEXEC 'SELECT PGM(ISRSSM) SCRNAME(SUPERC)'
 
    When ABBREV('SYNONYM',cmd1) Then
    Do
      parse var MixedCmd . name nnn command
      Upper name
      command = Strip(command)
      If Datatype(nnn,'WHOLE') = 1 & command ^= '' Then
      Do
        Do i = 1 to NrSynonyms,
          While Synonym.i ^= name
        End
        If i > NrSynonyms Then
          NrSynonyms = NrSynonyms+1
        Synonym.i = name
        SynCmd.i = command
        SynLen.i = nnn
      End
      Else
        msg = 'Command omitted. Syntax: SYnonym name nnn command'
    End
 
    When ABBREV('TAB',cmd1) Then
    Do
      If Cursor = 'DAXEDIT' Then
      Do
        If startcol+CursorPos-1 < word(tabs,1) Then
          curcol = min(lrecl,Word(tabs,1))
        Do i = 1 to Words(tabs) ,
           while startcol+CursorPos-1 >= word(tabs,i)
          If startcol+CursorPos-1 < word(tabs,i+1) Then
            curcol = Word(tabs,i+1)
        End
        If i > Words(tabs) | curcol > lrecl Then
        Do
          curcol = min(lrecl,Word(tabs,1))
          CursorLine = CursorLine + 1
        End
        If CurCol < StartCol | CurCol >= StartCol+73 Then
        Do
          If Curcol > 72 Then
            StartCol = min(lrecl-72,Curcol-30)
          Else
            StartCol = 1
        End
        CursorPos = curcol-startcol+1
        CursorArea = 'File'
      End
      Else
       msg = 'Cursor not on valid field'
    End
 
    When ABBREV('TABLINE',cmd1) Then
    Do
      Select
        When cmd2 = '' Then
        Do
          If tabline = 'ON' Then
            tabline = 'OFF'
          Else
            tabline = 'ON'
        End
        When ABBREV('ON',cmd2) Then
          tabline = 'ON'
        When ABBREV('OFF',cmd2) Then
          tabline = 'OFF'
        Otherwise
          msg = 'Invalid command: "'MixedCmd'". Syntax: TABLine <On|OFf>'
      End
    End
 
    When ABBREV('TAGCHANGE',cmd1) Then
    Do
      If cmd2 = '' Then
      Do
        If Word(tagchange,1) = 'ON' Then
          tagchange = 'OFF' Subword(tagchange,2)
        Else
          tagchange = 'ON' Subword(tagchange,2)
        msg = 'TAGCHANGE' tagchange
      End
      Else
      Do
        If words(MixedCmd) < words(tagchange)+1 Then
          cmd2 = MixedCmd Subword(tagchange,Words(MixedCmd))
        Else
          cmd2 = MixedCmd
        Parse var cmd2 . OnOff string from to option rest
        Upper OnOff
        Upper option
        Select
          When (^ABBREV('ON',OnOff) & ^ABBREV('OFF',OnOff)) |,
               datatype(from,'WHOLE') = 0 | ,
               datatype(to,'WHOLE') = 0 | ,
               from >= to | from <=0 | to <= 0 | ,
               from > lrecl | to > lrecl | ,
               (^ABBREV('IFBLANK',option) & ^ABBREV('ALWAYS',option)) |,
               rest ^= '' Then
            msg = 'Invalid command: "'MixedCmd'". Syntax: TAGchange <On|OFf> string <from> <to> <Ifblank|Always>'
          When to-from+1 < Length(string) Then
            msg = 'String "'string'" does not fit in position' from 'to' to'. Syntax: TAGchange <On|OFf> string <from> <to> <Ifblank|Always>'
          Otherwise
          Do
            If ABBREV('ON',OnOff) Then
              OnOff = 'ON'
            Else
              OnOff = 'OFF'
            If ABBREV('IFBLANK',option) Then
              option = 'IFBLANK'
            Else
              option = 'ALWAYS'
            tagchange = OnOff string from to option
            msg = 'TAGCHANGE' tagchange
          End
        End
      End
    End
 
    When ABBREV('TABS',cmd1) Then
    Do
      LastTab = 0
      Do i = 1 to Words(cmd2)
        If datatype(Word(cmd2,i),'WHOLE') ^= 1 | ,
           LastTab >= Word(cmd2,i) Then
        Do
          msg = 'Invalid TABS column(s) defined'
          return
        End
        LastTab = Word(cmd2,i)
      End
      tabs = cmd2
      msg = 'TABS' tabs
    End
 
    When ABBREV('TIMEZONE',cmd1) Then
    Do
      Parse var cmd2 hh ':' mm
      If datatype(hh,'WHOLE') = 1 & hh >= -23 & hh <= 23 &,
        (mm = '' | (datatype(mm,'WHOLE') = 1 & mm >= 0 & mm <60)) Then
      Do
        If hh >= 0 Then sign = '+'
        Else sign = '-'
        hh = right(abs(hh)+100,2)
        If mm = '' Then mm = 0
        mm = right(mm+100,2)
        timezone = sign hh':'mm
        msg = 'TIMEZONE' timezone
      End
      Else
        msg = 'Invalid command: "'MixedCmd||'".  Syntax: Timezone <+|-> hh:mm'
    End
 
    When ABBREV('TOP',cmd1) Then
    Do
      Cursor = 'CMD'
      CurLine = 0
    End
 
    When ABBREV('TSO',cmd1) Then
    Do
      PromptStat = Prompt('on')
      InTSOcmd = 'Yes'
      Cmd2 = Substr(MixedCmd,Length(cmd1)+1)
      Cmd2
      InTSOcmd = 'No'
      If rc ^= 0 Then
        msg = 'RC='rc', from "'MixedCmd'"'
      PromptStat = Prompt(PromptStat)
    End
 
    When ABBREV('TRAP',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        Drop trapmsg.
        x = outtrap('trapmsg.')
        PromptStat = Prompt('OFF')
        InTSOcmd = 'Yes'
        Cmd2 = Substr(MixedCmd,Length(cmd1)+1)
        Cmd2
        InTSOcmd = 'No'
        x = outtrap('OFF')
        x = trapmsg.0
        If x > 0 Then
        Do
          Call AddLines curline, x
          alt = alt+1
          Do y = 1 to x
            z = y+curline
            line.z = trapmsg.y
          End
        End
        Else
          msg = 'No output from "'MixedCmd'"'
        If rc ^= 0 Then
          msg = 'RC='rc', from "'MixedCmd'"'
        PromptStat = Prompt(PromptStat)
      End
    End
 
    When ABBREV('TYPE',cmd1) Then
    Do
      If verify(substr(cmd2,1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ') = 0 &,
         verify(cmd2,'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890') = 0 &,
         length(cmd2) <= 8 Then
      Do
        Parse var dataset project'.'group'.'type'.'rest
        If rest = '' Then
        Do
          Parse var dataset project'.'group'.'type'('rest
          If rest ^= '' Then
            rest = '('rest
        End
        Else
          rest = '.'rest
        If type ^= '' Then
        Do
          dset = project'.'group'.'cmd2||rest
          Do ir = 1 to NrRing
            r = word(rings,ir)
            If ring.r.sdataset = dset Then
            Do
              msg = dset 'already in XEDIT ring ('r')'
              ir = NrRing+10
            End
          End
          If ir = NrRing+1 Then
            dataset = dset
        End
        Else
          msg = 'Dataset has no type'
      End
      Else
        msg = 'Incorrect type-name "'cmd2'" specified'
    End
 
    When ABBREV('UP',cmd1) Then
    Do
      If Hex = 'ON' Then
        scroll = Vdepth%3
      Else
        scroll = Vdepth-1
      Select
        When cmd2 = '' then
        Do
          Select
            When Curline = 0 Then
            Do
              If cursorArea = 'File' | cursorArea = 'Prefix' Then
                CursorLine = 1
              Curline = max(0,size-scroll)
            End
            When Curline-scroll >= 0 Then
            Do
              If cursorArea = 'File' | cursorArea = 'Prefix' Then
                CursorLine = Vdepth
              Curline = curline-scroll
            End
            Otherwise
            Do
              If cursorArea = 'File' | cursorArea = 'Prefix' Then
                CursorLine = Curline+1
              Curline = 0
            End
          End
        End
        When ABBREV('CSR',translate(cmd2)) Then
        Do
          SavedCurline = Curline
          If CursorArea ^= 'File' & CursorArea ^= 'Prefix' Then
            CursorLine = 1             /* act as if on first line     */
          If Hex = 'ON' Then
          Do
            If curline = 0 Then
              l = (CursorLine+4)%3
            Else
              l = (CursorLine+2)%3
            If cursorArea = 'File' | cursorArea = 'Prefix' Then
              CursorLine = Min(size*3-2,Scroll*3+1)
          End
          Else
          Do
            l = CursorLine
            If cursorArea = 'File' | cursorArea = 'Prefix' Then
              CursorLine = Min(size+1,Vdepth)
          End
          Select
            When curline+l = 1 Then
              Curline = max(0,size-scroll+1)
            When l = scroll+1 Then
            Do
              If curline = 0 Then
                CursorLine = 1
              Curline = max(0,curline-scroll)
            End
            Otherwise
              Curline = max(0,curline-(scroll-l+1))
          End
          If SavedCurline = Curline &,
             (cursorArea = 'File' | cursorArea = 'Prefix') Then
            CursorLine = 1
        End
        Otherwise
        Do
          If datatype(cmd2,'WHOLE') = 1 Then
            curline = max(0,curline-cmd2)
          Else
            msg = 'Invalid command "'MixedCmd'". Syntax: Up <nnn>'
        End
      End
    End
 
    When ABBREV('UPPERCASE',cmd1) Then
    Do
      If xtype ^= 'FILE' Then
        msg = Not_Allowed
      Else
      Do
        If cmd2 = '' Then cmd2 = 1
        If (datatype(cmd2,'WHOLE') = 1 & cmd2 > 0) | cmd2 = '*' Then
        Do
          If curline = 0 Then
            UpperStart = 1
          Else
            UpperStart = curline
          If cmd2 = '*' Then
            UpperLines = max(size-UpperStart+1,0)
          Else
            UpperLines = max(min(size-UpperStart+1,cmd2),0)
          Call Uppercase UpperStart,UpperLines
          alt = alt+1
        End
        Else
          msg = 'Invalid command: "'MixedCmd'". Syntax: UPPercase <nnn|*>'
      End
    End
 
    When ABBREV('VIEW',cmd1) Then
    Do
      If cmd2 = '' Then
        dset = dataset
      Else
        dset = CheckName(cmd2)
      Address ISPEXEC 'CONTROL ERRORS RETURN'
      Address ISPEXEC "VIEW DATASET('"dset"')"
      Select
        When rc=4 Then
          msg = 'Dataset' dset 'not saved'
        When rc=12 Then
          msg = 'Dataset' dset 'is empty'
        When rc=14 Then
          msg = 'Member or dataset' dset 'in use'
        When rc=16 Then
          msg = 'No members in dataset' dset
        When rc=20 Then
          msg = 'Severe error during VIEW of' dset
        Otherwise
          ;
      End
    End
 
    When ABBREV('XEDIT',cmd1) Then
    Do
      If (cmd2 ^= '' | NrRing > 1) & cmd2 ^= '?' Then
      Do
        Select
          When cmd2 = '' Then
          Do
            call SaveRing CurRing
            If CurRing = NrRing then
              CurRing = 1
            Else
              CurRing = CurRing+1
            Call GetRing CurRing
          End
          When Substr(cmd2,1,1) = '-' Then
          Do
            incr = Strip(substr(cmd2,2))
            If incr = '' Then incr = 1
            If Datatype(incr,'WHOLE') = 1 Then
            Do
              call SaveRing CurRing
              CurRing = ((CurRing - incr - 1) // NrRing) + 1
              If CurRing <= 0 Then
                CurRing = CurRing + NrRing
              Call GetRing CurRing
            End
            Else
              msg = 'Invalid command. Syntax: Xedit <dataset|<-|+><nnn>>'
          End
          When Substr(cmd2,1,1) = '+' Then
          Do
            incr = Strip(substr(cmd2,2))
            If incr = '' Then i = 1
            If Datatype(incr,'WHOLE') = 1 Then
            Do
              call SaveRing CurRing
              CurRing = ((CurRing + incr - 1) // NrRing) + 1
              If CurRing <= 0 Then
                CurRing = CurRing + NrRing
              Call GetRing CurRing
            End
            Else
              msg = 'Invalid command. Syntax: Xedit <dataset|<-|+><nnn>>'
          End
          Otherwise
          Do
            If xtype = 'DIR' &,        /*member selected in directory?*/
               Index(cmd2,'.') = 0 & Index(cmd2,'*') = 0 & ,
               Index(cmd2,'(') = 0 & datatype(cmd2,'WHOLE') ^= 1 Then
              cmd2 = '('cmd2           /* yes, add '(' to get member  */
            call SaveRing CurRing
            Call GetDataset cmd2
          End
        End
      End
      Else
        msg = 'Dataset omitted. Syntax: Xedit <dataset|n>'
    End
 
    When ABBREV('XALL',cmd1) Then
    Do
      If xtype ^= 'FILE' Then          /* DIR or DLIST?               */
      Do
        If xtype = 'DIR' Then          /* display dataset list        */
          parse var dataset pds '(' .
        Do ii = 1 to size
          If xtype = 'DLIST' Then      /* display dataset list        */
            Call QueueCommand 'XEDIT' Word(line.ii,1)
          Else                         /* display directory list      */
          Do
            If xxgroup2||xxgroup3||xxgroup4 = '' Then
              Call QueueCommand 'XEDIT' pds'('Word(line.ii,1)')'
            Else
              Call QueueCommand 'XXEDIT' pds'('Word(line.ii,1)')' ,
                                xxgroup2 xxgroup3 xxgroup4
          End
        End
      End
      Else
        msg = Not_Allowed
    End
 
    When ABBREV('XEXEC',cmd1) Then
    Do
      PrevDataset = Dataset
      PrevNrRing = NrRing
      PrevNot_Allowed = Not_Allowed
      XexecDset = cmd2
      If cmd2 ^= '' Then
      Do
        cmd = 'XEDIT' cmd2
        call HandleCommand
      End
      If xtype ^= 'FILE' |,            /* invalid file for XEXEC?     */
         index(TRANSLATE(msg),' NOT ') > 0 Then
      Do
        If xtype ^= 'FILE' Then        /* message not yet set         */
          msg = PrevNot_Allowed
      End
      Else
      Do
        Do i = 1 to size
          If ABBREV('XEXEC',Translate(word(Line.i,1)),3) = 0 Then
          Do
            If Substr(Strip(Line.i),1,2) ^= '/*' Then
              Call QueueCommand CheckCmd(Strip(Line.i), PrevDataset)
          End
          Else
            say Line.i 'not allowed in "XEXEC"-file'
        End
      End
      If PrevNrRing ^= NrRing Then
      Do
        cmd = 'QQUIT'
        call HandleCommand
      End
      If PrevDataset ^= dataset Then
      Do
        cmd = 'XEDIT 'PrevDataset
        call HandleCommand
      End
    End
 
    When ABBREV('XLMF',cmd1) Then
    Do
      dset = CheckName(cmd2)
      Parse var dset project "." group "." type "(" mem ")"
 
      If Wordpos(right(group,3), 'DEV SYS REL') > 0 Then
      Do                               /* special naming for FIRE     */
        GroupPrefix = Left(group,Length(group)-3)
        If mem ^= '' Then
          Call QueueCommand "XXEDIT "project"."userid()"."type"("mem")" ,
                            GroupPrefix"DEV" GroupPrefix"SYS" GroupPrefix"REL"
        Else
          Call QueueCommand "XXEDIT "project"."userid()"."type ,
                            GroupPrefix"DEV" GroupPrefix"SYS" GroupPrefix"REL"
      End
      Else                             /* normal group names eg:      */
      Do                               /* JIS1300D, JIS1300S, etc     */
        If length(group) > 7 Then group = substr(group,1,7)
        If mem ^= '' Then
          Call QueueCommand "XXEDIT "project"."userid()"."type"("mem")" ,
                           group"D" group"S" group"B"
        Else
          Call QueueCommand "XXEDIT "project"."userid()"."type ,
                           group"D" group"S" group"B"
      End                              /* end normal group names      */
    End
 
    When ABBREV('XXEDIT',cmd1) Then
    Do
      Parse var cmd2 dset group2 group3 group4
      If dset ^= '' Then
        dset = CheckName(dset)
      Call HandleXXedit dset, group2, group3, group4
    End
 
    When cmd1 = 'XDEBUG' Then
    Do
      Interpret subword(MixedCmd,2)
    End
 
    Otherwise
    Do
      SavedCursor = Cursor
      SavedCsrpos = Csrpos
      ISPFcmd = MixedCmd
      cmdbuf = ''
      cmdlen = 100
      Address ISPEXEC 'VPUT (HELPCMD, DUMMYBUF, DUMMYLEN)'
      Address ISPEXEC 'DISPLAY PANEL(XEDIT) COMMAND(ISPFCMD)',
                      'RETBUFFR(CMDBUF) RETLGTH(CMDLEN)'
      If rc ^= 0 Then
        msg = 'Invalid command: "'MixedCmd'". Use PF1 for help.'
      Cursor = SavedCursor
      Csrpos = SavedCsrpos
    End
  End
ContinueAfterPC:
ContinueAfterTSO:
return
 
 
 
GetDataset:
  trace off
  msg = ''
  /********************************************************************/
  /* Get dataset name                                                 */
  /********************************************************************/
  If datatype(arg(1),'WHOLE') = 1 then
  Do
    Select
      When arg(1) > words(rings) Then
      Do
        msg = 'Only' words(rings) 'datasets in XEDIT-ring'
        CurRing = words(rings)
      End
      When arg(1) < 1 Then
        Nop
      Otherwise
        CurRing = arg(1)
    End
    Call GetRing CurRing
    Return
  End
 
  dset = CheckName(arg(1))
 
  Do i = 1 to NrRing
    r = word(rings,i)
    If ring.r.sdataset = dset Then
    Do
      CurRing = i
      Call GetRing CurRing
      Return
    End
  End
 
  Call CheckDataset dset
  parse var dset pds '(' mem ')'
 
  If result > 8 Then                   /* real error?                 */
    return 8                           /* yes                         */
 
  If result = 8 Then                   /* dataset does not exists?    */
  Do                                   /* yes, try list of datasets   */
    result = 0
    sysdsorg = 'DS'
    revpds = reverse(pds)
    Parse var revpds lastqual '.' rest
    If length(lastqual) = 8 Then       /* must also add a dot?        */
      dset = pds'.*'                   /* add wild card               */
    Else
      dset = pds'*'                    /* add wild card               */
    Do i = 1 to NrRing
      r = word(rings,i)
      If ring.r.sdataset = dset Then
      Do
        CurRing = i
        Call GetRing CurRing
        Return
      End
    End
  End
 
  If result = 0 Then                   /* member/dataset exists?      */
  Do                                   /* yes                         */
    Select
      When sysdsorg = 'DS' Then        /* dataset list?               */
      Do                               /* yes                         */
        Address ISPEXEC "LMDINIT LISTID(ID) LEVEL("dset")"
        dsname = ''
        i = 0
        Do until rc ^= 0
          Address ISPEXEC "LMDLIST LISTID("id")" ,
                          "STATS(YES) OPTION(LIST) DATASET(DSNAME)"
          If rc=0 Then
          Do
            If i = 0 Then
              drop Line.               /* forget old dataset          */
            i = i+1
            If zdlmigr = 'YES' Then
              zdlvol = 'MIGRAT'
            If zdldsorg = ':' Then
            Do
              zdldsorg = 'GDG'
              zdlrecfm = '?'
            End
            If zdldsorg = X2C('FF') Then
              zdldsorg = '?'
            Line.i = Left(Strip(dsname),44),
                     Left(Strip(zdldsorg),4),
                     Left(Strip(zdlrecfm),3)||,
                     Right(Strip(zdllrecl),5),
                     Right(Strip(zdlsize),6),
                     Right(Strip(zdlused),3),
                     Right(Strip(zdlext),2),
                     Right(Strip(zdlvol),6)
          End
        End
        Address ISPEXEC "LMDLIST LISTID("id")" ,
                        "STATS(YES) OPTION(FREE) DATASET(DSNAME)"
        Address ISPEXEC "LMDFREE LISTID("id")"
        If i = 0 Then
        Do
          msg = 'Dataset "'dset'" not found'
          Return 4
        End
        xtype = 'DLIST'                /*indicate it is a dataset list*/
        Size = i
        sysrecfm   = '**'              /* initialize system variables */
        syslrecl   = 79
        sysblksize = 0
        sysdsorg   = 'DS'
      End                              /* end dataset list            */
 
      When sysdsorg = 'PO' & (mem = '' | Index(mem,'*') > 0) Then
      Do                               /* directory of PDS!           */
        xtype = 'DIR'                  /*indicate it is a dataset list*/
        m1 = ''
        m2 = ''
        If Index(mem,'*') > 0 Then     /* wildcard specified?         */
          Parse var mem m1 '*' m2      /* yes, get first/last part    */
        l1 = length(m1)
        l2 = length(m2)
        drop Line.                     /* forget old dataset          */
        If xxgr.1^='' | xxgr.2^='' | xxgr.3^='' | xxgr.4^='' Then
          Address ISPEXEC "LMINIT DATAID(ID) PROJECT("xxpro")",
                          "GROUP1("xxgr.1") TYPE("xxtyp")",
                          "GROUP2("xxgr.2") GROUP3("xxgr.3")",
                          "GROUP4("xxgr.4")"
        Else
          Address ISPEXEC "LMINIT DATAID(ID) DATASET('"pds"')"
        Address ISPEXEC "LMOPEN DATAID("id")"
        memname = ''
        i = 0
        zllib = ''
        zlmod = ''
        zlcdate = ''
        zlmdate = ''
        zlmtime = ''
        zlcnorc = ''
        zlinorc = ''
        zluser = ''
        Do until rc ^= 0
          Address ISPEXEC "LMMLIST DATAID("id")" ,
                          "STATS(YES) OPTION(LIST) MEMBER(MEMNAME)"
          memname = Strip(memname)
          If rc=0 & Substr(memname,1,l1)=m1 & Right(memname,l2)=m2 Then
          Do
            i = i+1
            If zlinorc = 65535 Then zlinorc = '>=65535'
            If zlcnorc = 65535 Then zlcnorc = '>=65535'
 
            zlcdate = Y2K(zlcdate)
            zlmdate = Y2K(zlmdate)
 
            Line.i = Substr(memname,1,18)||,
                     Right(Strip(zllib),4)||,
                     Right(Strip(zlmod),4)||,
                     Right(Strip(zlcdate),11)||,
                     Right(Strip(zlmdate),11)||,
                     Right(Strip(zlmtime),6)||,
                     Right(Strip(zlcnorc),8)||,
                     Right(Strip(zlinorc),8)||,
                     Right(Strip(zluser),9)
          End
        End
        Size = i
        Address ISPEXEC "LMMLIST DATAID("id")" ,
                        "STATS(YES) OPTION(FREE) MEMBER(MEMNAME)"
        Address ISPEXEC "LMCLOSE DATAID("id")"
        Address ISPEXEC "LMFREE DATAID("id")"
      End
      When (sysdsorg = 'PO' & mem ^= '') | , /* member in pds or      */
           sysdsorg = 'PS' Then        /* sequential dataset?         */
      Do                               /* yes                         */
        cmd = "ALLOCATE FI(ZYXEDITQ) DATASET('"dset"') SHR REUSE"
        cmd                            /* allocate dataset            */
        if rc ^= 0 Then                /* allocate failed?            */
        Do                             /* yes                         */
          msg = 'Dataset "'dset'" not available'
          Return 16                    /* return to caller            */
        End                            /* end allocate failed         */
        Freedataset = 'Yes'            /* indicate free needed        */
 
        drop Line.                     /* forget old dataset          */
 
        InExecio = 'DISKR'
        'EXECIO * DISKR ZYXEDITQ (FINIS STEM LINE.'
 
ContinueAfterDISKR:
        InExecio = ''
        if rc ^= 0 Then
          'EXECIO 0 DISKR ZYXEDITQ (FINIS' /* close file              */
        'FREE FI(ZYXEDITQ)'
        Freedataset = 'No'             /* free nolonger needed        */
        xtype = 'FILE'                 /* it is a dataset or member   */
        size = line.0
        If mem ^= '' Then
        Do
          Address ISPEXEC "LMINIT DATAID(ID) DATASET('"pds"')"
          Address ISPEXEC "LMOPEN DATAID("id")"
          Address ISPEXEC "LMMFIND DATAID("id")" ,
                          "STATS(YES) MEMBER("mem")"
          Address ISPEXEC "LMCLOSE DATAID("id")"
          Address ISPEXEC "LMFREE DATAID("id")"
          timestamp = zlmdate'|'zlmtime'|'zlmsec
        End
      End
      Otherwise
      Do
        msg = dset 'is' sysdsorg 'which is not supported'
        return 8
      End
    End                                /* end select                  */
  End
  Else                                 /* member does not exist       */
  Do
    xtype = 'FILE'                     /* it is a dataset or member   */
    size = 0
    drop Line.                         /* forget old dataset          */
  End
 
  recfm = sysrecfm
  If Substr(recfm,1,1) = 'V' Then
    lrecl = syslrecl-4
  Else
    lrecl = syslrecl
  blksize = sysblksize
  dsorg   = sysdsorg
 
  Select
    When xtype = 'DLIST' Then          /* display dataset list        */
    Do
      If size = 0 Then msg = 'No datasets found'
      CurLine = 1
    End
    When xtype = 'DIR' Then            /* display directory          */
    Do
      If size = 0 Then msg = 'No members in dataset'
      CurLine = 1
    End
    Otherwise                          /* display file                */
    Do
      FullScale = '<...+....1'
      Do i = 2 to (lrecl%10)+1
        FullScale = FullScale||substr('....+....',1,10-length(i))||i
      End
      FullScale = Substr(Overlay('>',FullScale,lrecl),1,lrecl)
      CurLine = 0
    End                                /* end display file            */
  End                                  /* end select                  */
  command. = ''
  AutosaveDset = ''
  Parse var dset project'.'group'.'type'.'rest
  If rest = '' Then
    Parse var dset project'.'group'.'type'('rest
  If Index(type,'PL') > 0 | Index(type,'PS') > 0 |,
     Index(type,'MA') > 0 Then
    Language = 'PL1'
  Else
    Language = 'REXX'
  hex = 'OFF'
  dataset = dset
  parse var dataset . '(' member ')'
  alt = 0
  SaveAlt = 0
  TotalAlt = 0
  CurCol = 1
  StartCol = 1
  cursor = 'CMD'
  csrpos = 1
  SaveCursor = 'CMD'
  SaveCsrpos = 1
  SaveCmd = ''
  SavePrefixCmd = ''
  SaveC = ''
  NrPrefCmd = 0
  CutNrLines = -1                      /* no lines cut yet            */
  CutSquareStatus = ''                 /* start al over again         */
  tags = ' '
  tagchange  = 'OFF /*CHANGE*/ 63 72 IFBLANK'
  i = 1
  Do while wordpos(i,rings) > 0
    i = i+1
  End
  rings = rings' 'i' '
  NrRing = NrRing+1
  CurRing = NrRing
  r = word(rings,CurRing)
  ring.r.sdataset = dataset
  xxgroup1 = xxgr.1
  xxgroup2 = xxgr.2
  xxgroup3 = xxgr.3
  xxgroup4 = xxgr.4
  If sysdsorg = 'DS' | (sysdsorg = 'PO' & mem = '') Then
    case = 'MIXED IGNORE'              /* reset case for "non-file"'s */
 
Return 0
 
 
 
SaveDataset: Procedure expose Racf
  trace off
  If xtype ^= 'FILE' Then              /* nothing to save?            */
    return 0
 
  dset = CheckName(arg(1))             /* get dataset name            */
  Parse var dset pds '('member')'
 
  Call CheckDataset dset               /* check dataset existance     */
 
  If result > 4 Then
    return 8
 
  If lrecl > syslrecl Then
  Do
    msg = 'Record length of "'dset'" too small ('syslrecl')'
    Return 16
  End
 
  /********************************************************************/
  /* Check update authority                                           */
  /********************************************************************/
  Parse var pds group '.' .
  If Racf = 0 Then                     /* RACF checking off?          */
    Return 0
  If group ^= userid() Then            /* not private dataset?        */
  Do                                   /* yes, check authority        */
    x = outtrap('trapmsg.')
    "LISTDSD DATASET('"pds"') AUTHUSER GENERIC"
    x = outtrap('OFF')
    If rc ^= 0 Then
    Do
      drop trapmsg.
      Return CheckDiscreteProfile()
    End
    Else
    Do
      Do i=1 to trapmsg.0
        If subword(trapmsg.i,1,2) = 'YOUR ACCESS' Then
        Do
          i = i+2
          If word(trapmsg.i,1) = 'READ' | word(trapmsg.i,1) = 'NONE' Then
          Do
            drop trapmsg.
            Return CheckDiscreteProfile()
          End
          drop trapmsg.
          i = i+999
        End
      End
    End
  End
  If member ^= '' Then
  Do
    zlcdate = date('O')
    zlinorc = min(65535,Size)
    Address ISPEXEC "LMINIT DATAID(ID) DATASET('"pds"')"
    Address ISPEXEC "LMOPEN DATAID("id")"
    Address ISPEXEC "LMMFIND DATAID("id")" ,
                    "STATS(YES) MEMBER("member")"
  End
 
  cmd = "ALLOCATE FI(ZYXEDITQ) DATASET('"dset"') SHR"
  cmd                                  /* allocate dataset            */
  if rc ^= 0 Then                      /* allocate failed?            */
  Do                                   /* yes                         */
    msg = 'Dataset "'dset'" is in use'
    return 4                           /* return to caller            */
  End                                  /* end allocate failed         */
  Freedataset = 'Yes'                  /* indicate free needed        */
 
  truncated = 0
  trace off
  Do i = 1 to size
    If Length(Line.i) > lrecl Then
    Do
      truncated = truncated+1
      Line.i = substr(Line.i,1,lrecl)
    End
    /*If Length(Line.i) = 0 Then         .* LMPUT can not handle records*.*/
      /*Line.i = ' '                     .* of record length 0          *.*/
  End
  InExecio = 'DISKW'
  'EXECIO 'size' DISKW ZYXEDITQ (STEM LINE. OPEN FINIS'
ContinueAfterDISKW:
  InExecio = ''
  If rc = 1 Then
  Do
    msg = 'File saved, but line(s) were truncated'
    rc = 0
  End
 
  If rc ^= 0 Then                      /* write failed?               */
  Do                                   /* yes                         */
    'EXECIO 0 DISKW ZYXEDITQ (FINIS'   /* close the file              */
    'FREE FI(ZYXEDITQ)'                /* free dataset                */
    Freedataset = 'No'
    msg = 'Dataset "'dset'" is full. Use COMpress to compress it'
    Address ISPEXEC "LMCLOSE DATAID("id")"
    Address ISPEXEC "LMFREE DATAID("id")"
    return 16                          /* return to caller            */
  End                                  /* end write failed            */
 
  If truncated > 0 Then
    msg = 'File saved,' truncated 'line(s) truncated'
 
  /********************************************************************/
  /* Free dataset                                                     */
  /********************************************************************/
  'FREE FI(ZYXEDITQ)'
  Freedataset = 'No'                   /* free nolonger needed        */
 
  If member ^= '' Then
  Do
    If Datatype(zlmod,'WHOLE') ^= 1 Then zlmod = 99
    zlmod = Right(101+zlmod,2)
    If zlcdate = '' Then zlcdate = date('O')
    zlmdate = date('O')
    zlmtime = Substr(time(),1,5)
    zlmsec = Substr(time(),7,2)
    zlcnorc = min(65535,Size)
    If Datatype(zlinorc,'WHOLE') ^= 1 Then zlinorc = zlcnorc
    Address ISPEXEC "LMMSTATS DATAID("id")" ,
                    "MEMBER("member")" ,
                    "MODLEVEL("zlmod")" ,
                    "CREATED("zlcdate")" ,
                    "MODDATE("zlmdate")" ,
                    "MODTIME("zlmtime")" ,
                    "CURSIZE("zlcnorc")" ,
                    "INITSIZE("zlinorc")" ,
                    "USER("userid()")"
    Address ISPEXEC "LMCLOSE DATAID("id")"
    Address ISPEXEC "LMFREE DATAID("id")"
  End
return 0
 
 
 
CheckName: procedure expose dataset dsorg
trace off
/**********************************************************************/
/* Check dataset name. Handle partly specified dataset name.          */
/* Current dataset name is : INCDCSC.I095C.CLIST(XEDIT)               */
/* Input: .I095L.           Output: INCDCSC.I095L.CLIST               */
/*        '.I095L.()'               INCDCSC.I095L.CLIST(XEDIT)        */
/*        .FIS1L03D.(EXSEXB)        INCDCSC.FIS1L03D.CLIST(EXSEXB)    */
/*        MYPDF                     INCDCSC.I095L.CLIST(MYPDF)        */
/*        (BLAH                     INCDCSC.I095L.CLIST(BLAH)         */
/**********************************************************************/
  dset = strip(arg(1))
  If dset = '' Then
    return dataset
  Upper dset
  If substr(dset,1,1) = "'" Then
    Parse var dset "'"dset"'".
  parse var dset d1 '(' m1 ')'
  d1 = strip(d1)
  m1 = strip(m1)
  parse var dataset d2 '(' m2 ')'
  d2 = strip(d2)
  m2 = strip(m2)
  If substr(dset,1,1) = "(" Then
    return d2'('m1')'
  If index(d1,'.') > 0 Then
  Do
    dset = ''
    Do while index(d1,'.') > 0
      Parse var d1 n1'.'d1
      d1 = strip(d1)
      n1 = strip(n1)
      Parse var d2 n2'.'d2
      d2 = strip(d2)
      n2 = strip(n2)
      If n1 = '' Then
        dset = dset'.'n2
      Else
        dset = dset'.'n1
    End
    If d1 = '' Then
      dset = dset'.'d2
    Else
      If substr(d1,1,1) = '(' Then
        dset = dset'.'d2||d1
      Else
        dset = dset'.'d1
    dset = substr(dset,2)
  End
  Else
    dset = d1
  If index(arg(1),'(') > 0 Then
  Do
    If m1 = '' Then
    Do
      If m2 ^= '' Then
        dset = dset'('m2')'
    End
    Else
      dset = dset'('m1')'
  End
  If index(arg(1),'.') = 0 & index(arg(1),'(') = 0 &,
     dsorg = 'PO' Then
  Do
    Parse var dataset d1'('.')'
    d1 = strip(d1)
    dset = d1'('dset')'
  End
return dset
 
 
 
CheckDataset: procedure expose sysdsorg syslrecl sysrecfm sysdsorg ,
                               sysblksize msg Racf
trace off
/**********************************************************************/
/* Check if the passed dataset exists.                                */
/**********************************************************************/
  dset = arg(1)
  Parse var dset da '('mem')'
 
  If Index(da,'*') > 0 |,              /* dataset list requested?     */
     Index(dset,'.') = 0 Then
  Do                                   /* yes                         */
    sysdsorg = 'DS'                    /* fake LISTDS                 */
    return 0
  End
 
  drop trapmsg.
  x = outtrap('trapmsg.')
  "LISTDS '"da"'"
  x = outtrap('OFF')
  If rc ^= 0 Then
  Do
    Do j = 1 to trapmsg.0
      If Index(trapmsg.j,'ALREADY IN USE') > 0 Then
      Do
        msg = '"'dset'" is already in use by another user or job'
        Return 8
      End
    End
    msg = 'Dataset "'dset'" not found'
    Return 8
  End
  Do j = 1 to trapmsg.0
    Select
      When trapmsg.j = '--RECFM-LRECL-BLKSIZE-DSORG' Then
      Do
        j = j+1
        output = trapmsg.j
        Parse upper var output sysrecfm syslrecl sysblksize sysdsorg .
      End
      When trapmsg.j = '--LRECL--DSORG-' Then
      Do
        j = j+1
        output = trapmsg.j
        Parse upper var output syslrecl sysdsorg .
      End
      Otherwise
        Nop
    End
  End
  If sysdsorg = 'PS' & mem ^= '' Then
  Do
    msg = dset 'is a sequential dataset, but a member-name is specified'
    Return 12
  End
  If sysdsorg ^= 'PO' & sysdsorg ^= 'PS' Then
  Do
     msg = dset 'is a' sysdsorg 'which is not supported'
    Return 12
  End
  If (sysdsorg = 'PS' | (mem ^= '' & Index(mem,'*') = 0)) & ,
     WordPos(sysrecfm,'F FA FB FBA FBM FM V VA VB VBA VBM VM') = 0 Then
  Do
    msg = 'Record format "'sysrecfm'" of' dset 'not supported'
    Return 12
  End
 
  If mem ^= '' & Index(mem,'*') = 0 Then
  Do
    msgstat = msg('OFF')
    result = SYSDSN("'"dset"'")
    msgstat = msg(msgstat)
 
    Select
      When result = 'OK' Then Nop
      When result = 'PROTECTED DATASET' Then
      Do
        msg = 'You have no read access on' dset
        Return 12
      End
      When result = 'MEMBER NOT FOUND' Then
      Do
        msg = 'Member "'mem'" does not exist'
        Return 4
      End
      When Substr(result,1,20) = 'INVALID DATASET NAME' Then
      Do
        msg = "Invalid dataset name '"dset"'"
        Return 12
      End
      Otherwise
      Do
        msg = dset': 'result
        Return 16
      End
    End
  End
  Else                                 /* no member given or wildcard */
  Do                                   /* in member name              */
    /******************************************************************/
    /* Check read authority                                           */
    /******************************************************************/
    Parse var dset group '.' .
    If group = userid() Then           /* own dataset?                */
      Return 0                         /* yes, must have read auth.   */
    If Racf = 0 Then                   /* RACF checking off?          */
      Return 0                         /* yes, bypass LISTDSD         */
    x = outtrap('trapmsg.')
    "LISTDSD DATASET('"da"') AUTHUSER GENERIC"
    x = outtrap('OFF')
    If rc ^= 0 Then
    Do
      msg = 'You have no read authority for 'da
      return 12
    End
    Trace   /* Janko */
  End
 
return 0
 
 
 
CheckDiscreteProfile: Procedure expose Racf
  If Racf = 0 Then
    Return 0
  x = outtrap('trapmsg.')
  "LISTDSD DATASET('"pds"') AUTHUSER"
  x = outtrap('OFF')
  If rc ^= 0 Then
  Do
    msg = 'You have no update authority for 'pds
    return 4
  End
  Else
  Do
    Do i=1 to trapmsg.0
      If subword(trapmsg.i,1,2) = 'YOUR ACCESS' Then
      Do
        i = i+2
        If word(trapmsg.i,1) = 'READ' | word(trapmsg.i,1) = 'NONE' Then
        Do
          drop trapmsg.
          msg = 'You have no update authority for 'pds
          return 4
        End
        drop trapmsg.
        i = i+999
      End
    End
  End
Trace   /* Janko */
Return 0
 
 
 
CheckTempDataset: procedure
  TempDset = "'"userid()".XEDIT.TEMP$$$'"
  result = LISTDSI(TempDset)
  If sysreason = 0 Then
  Do
    say 'Dataset' TempDset 'needed for' arg(1) 'already exists.'
    say 'Do you want to delete it? (yes/No)'
    Parse Upper Pull answer
    If ABBREV('YES',answer) Then
    Do
      msgstat = msg('off')
      'DELETE' TempDset
      msgstat = msg(msgstat)
    End
    Else
      TempDset = ''
  End
return TempDset
 
 
 
AutosaveDset:
  If AutosaveDset = '' Then
  Do
    Do i = 1 to 999 ,
       while LISTDSI("'"userid()".AUTOSAVE.XEDIT"||,
             substr('000',1,3-length(i))||i||"'") = 0
    End
    AutosaveDset = ,
      userid()".AUTOSAVE.XEDIT"substr("000",1,3-length(i))||i
    "ALLOCATE FI(ZYXEDITQ) DA('"AutosaveDset"') SPACE(10,100)",
        "TRACKS LRECL("lrecl") BLKSIZE(0) DSORG(PS) NEW REUSE"
  End
  Else
    "ALLOCATE FI(ZYXEDITQ) DA('"AutosaveDset"') SPACE(10,100)" ,
        "TRACKS LRECL("lrecl") BLKSIZE(0) DSORG(PS) SHR REUSE"
  Freedataset = 'Yes'
  InExecio = 'AUTOSAVE'
  'EXECIO 'size' DISKW ZYXEDITQ (STEM LINE. OPEN FINIS'
 
ContinueAfterAutosave:
  InExecio = ''
  If rc = 0 Then
  Do
    If msg = '' Then
      msg = dataset 'autosaved in' AutosaveDset
  End
  Else
  Do
    msg = 'Autosave failed in 'AutosaveDset' (EXECIO RC='rc')'
    'EXECIO 0 DISKW ZYXEDITQ (FINIS'  /* close the file              */
  End
  totalalt = totalalt+alt
  alt = 0
  'FREE FI(ZYXEDITQ)'
  Freedataset = 'No'
return
 
 
DetermineIndent: procedure expose language
  Line1 = arg(1)
  Line2 = arg(2)
  indent = verify(Line1,' ')
  If indent > 0 & indent <= 40  Then
  Do
    fword = translate(word(line1,1))
    If fword='DO' | fword='DO;' | fword='IF' | fword='THEN' |,
       fword='WHEN' | fword='SELECT' Then
      indent = indent+2
  End
  Else                                 /* indent = 0                  */
  Do
    indent = verify(line2,' ')
    If indent > 40 Then indent = 1
    If indent = 0 Then indent = 1
    If indent = 1 & Language = 'PL1' Then
      indent = 2                       /* do not use col 1 in PL/1    */
  End
return indent
 
 
 
Y2K:
trace off
yy = Left(arg(1),2)
cc = Left(date('S'),2)
ccyy = Substr(date('S'),3,2)
Select
  When arg(1) = '' Then
    Return ''
  When yy > 80 & ccyy < 20 Then
    Return cc-1||arg(1)
  When yy < 20 & ccyy > 80 Then
    Return cc+1||arg(1)
  Otherwise
    Return cc||arg(1)
End
return arg(1)
 
 
 
GetAttr:
  color = word(arg(1),1)
  hi = word(arg(1),2)
  Select
    When ABBREV('BLUE',color) Then
      result = 'BLUE'
    When ABBREV('GREEN',color) Then
      result = 'GREEN'
    When ABBREV('PINK',color) Then
      result = 'PINK'
    When ABBREV('RED',color) Then
      result = 'RED'
    When ABBREV('TURQUOISE',color) Then
      result = 'TURQ'
    When ABBREV('WHITE',color) Then
      result = 'WHITE'
    When ABBREV('YELLOW',color) Then
      result = 'YELLOW'
    Otherwise
    Do
      msg = 'Invalid color' color
      result = Word(arg(2),1)
    End
  End
  Select
    When hi = '' Then
      result = result ''
    When ABBREV('BLINK',hi) Then
      result = result 'BLINK'
    When ABBREV('REVERSE',hi) Then
      result = result 'REVERSE'
    When ABBREV('USCORE',hi) Then
      result = result 'USCORE'
    Otherwise
    Do
      msg = 'Invalid hilight' hi
      result = result Word(arg(2),2)
    End
  End
return result
 
 
AddLines:
trace off
  al = arg(1)                          /* line to add lines after     */
  nr = arg(2)                          /* number of lines to add      */
  if nr = '' Then nr = 1
  if al < curline Then curline=curline+nr
  if al > size Then al = size
  If size = 0 Then
  Do b = 1 to nr
    Line.b = ''
  End
  Else
  Do
    Do b = size to al+1 by -1
      c = b+nr
      Line.c = Line.b
      command.c = command.b
    End
    Do b = al+1 to al+nr
      Line.b = ''
      Command.b = ''
    End
    Do c = 1 to words(tags)
      t = word(tags,c)
      If tag.t > al Then
        tag.t = tag.t+nr
    End
    Do c = 1 to words(PrefixPenCmds)
      pc = word(PrefixPenCmds,c)
      If pending.pc > al Then
        pending.pc = pending.pc+nr
    End
  End
  Size = Size+nr
return
 
 
 
DelLines:
trace off
  dl = arg(1)                          /* first line to delete        */
  nr = arg(2)                          /* number of lines to delete   */
  If nr = '' Then nr = 1
  If dl = 0 Then
  Do
    dl = dl+1
    nr = nr-1
  End
  If dl+nr-1 > size Then nr = size-dl+1
  Do b = dl to size-nr
    c = b+nr
    Line.b = Line.c
    command.b = command.c
  End
  Do b = size-nr+1 to size
    Line.b = ''
    command.b = ''
  End
  Size = Size-nr
  If dl < curline Then curline = max(1,curline-nr)
  Do c = 1 to words(tags)
    t = word(tags,c)
    If tag.t >= dl & tag.t < dl+nr Then
    Do
      tags = Delword(tags,c,1)
      c = c-1
    End
    Else
      If tag.t > dl Then
        tag.t = tag.t-nr
  End
  Do c = 1 to words(PrefixPenCmds)
    pc = word(PrefixPenCmds,c)
    If pending.pc >= dl & pending.pc < dl+nr Then
      pending.pc = 0
    Else
      If pending.pc > dl Then
        pending.pc = pending.pc-nr
  End
return
 
 
 
CopyLines:
trace off
  cl = arg(1)                           /* first line to copy          */
  cn = min(arg(2), size-cl+1)           /* number of lines to copy     */
  ca = arg(3)                           /* line to copy lines after    */
  if cn = '' Then cn = 1
  Call AddLines ca, cn
  If ca < cl Then
    cl = cl+cn
  Do c = cl to cl+cn-1
    ca = ca+1
    Line.ca = Line.c
    Call TagChange ca
  End
return
 
 
 
MoveLines:
trace off
  ml = arg(1)                           /* first line to move          */
  mn = min(arg(2), size-ml+1)           /* number of lines to move     */
  ma = arg(3)                           /* line to move lines after    */
  if mn = '' Then mn = 1
  If ml <= ma & ma <= ml+mn-1 Then
  Do
    msg = "Incorrect move: can't move lines" ml 'to' ml+mn-1 'after' ma
    return
  End
  If ml+mn < curline & ma > curline Then curline=max(1,curline-mn)
  If ma<curline & ml > curline Then curline=curline+mn
  c = ml
  Do b = 1 to mn
    TempLine.b = Line.c
    TempCommand.b = Command.c
    c = c+1
  End
  If ml < ma Then
  Do
    c = ml
    Do b = ml+mn to ma
      Line.c = Line.b
      Command.c = Command.b
      c = c+1
    End
    c = ma-mn+1
  End
  Else
  Do
    c = ml+mn-1
    Do b = ml-1 to ma+1 by -1
      Line.c = Line.b
      Command.c = Command.b
      c = c-1
    End
    c = ma+1
  End
  Do b = 1 to mn
    Line.c = TempLine.b
    Call TagChange c
    Command.c = TempCommand.b
    c = c+1
  End
  Do c = 1 to words(tags)
    t = word(tags,c)
    If tag.t >= ml & tag.t < ml+mn Then
    Do
      If ml < ma Then
        tag.t = tag.t+ma-ml-mn+1
      Else
        tag.t = tag.t+ma-ml+1
    End
    Else
    Do
      If ma > ml & tag.t >= ml+mn & tag.t <= ma Then
        tag.t = tag.t-mn
      If ma < ml & tag.t > ma & tag.t < ml Then
        tag.t = tag.t+mn
    End
  End
  Do c = 1 to words(PrefixPenCmds)
    pc = word(PrefixPenCmds,c)
    If ma > ml & pending.pc >= ml+mn & pending.pc <= ma Then
      pending.pc = pending.pc-mn
    If ma < ml & pending.pc > ma & pending.pc < ml Then
      pending.pc = pending.pc+mn
  End
return
 
 
 
ShiftlinesRight:
trace off
  sl = arg(1)                          /* start line to shift right   */
  sn = arg(2)                          /* number of lines to shift    */
  sc = arg(3)                          /* number of columns to shift  */
  Do kk = sl to sl+sn-1
    ll = index(Line.kk,'/*')
    Line.kk = Strip(Substr('',1,sc)||Line.kk,'T')
    If ll > 0 Then                     /* comment in line?            */
    Do                                 /* yes                         */
      If Substr(Line.kk,ll,sc) ^= '' Then /*not enough space to shift?*/
      Do                               /* yes                         */
                                       /* available for shift         */
        as = Max(Verify(Reverse(Substr(Line.kk,1,ll+sc-1)),' ')-2,0)
                                       /* can comment be shrunk?      */
        If Substr(Reverse(line.kk),1,sc+2-as) = '/*' Then
        Do                             /* yes, delete available shift */
          Line.kk = Delstr(Line.kk,ll+sc-as,as)
                                       /* shrink comment              */
          Line.kk = Delstr(Line.kk,Length(Line.kk)-(sc-as)-1,sc-as)
          Call TagChange kk
        End
        Else                           /* comment can not be shrunk!  */
        Do
          Call AddLines kk,1
          sn = sn+1
          mm = kk+1
          Line.mm = Strip(Substr('',1,verify(line.kk,' ')-sc)|| ,
                         Substr(line.kk,ll,sc),'T')
          Line.kk = Delstr(Line.kk,ll,sc)
          Call TagChange kk
          Call TagChange mm
        End
      End
      Else                             /* enough space to shift!      */
      Do
        Line.kk = Delstr(Line.kk,ll,sc)
        Call TagChange kk
      End
    End
    Else
    Do
      If Length(Line.kk) > lrecl Then
      Do
        mm = kk+1
        Call AddLines kk,1
        sn = sn+1
        Line.mm = Substr('',1,verify(line.kk,' ')-sc)|| ,
                 Substr(line.kk,lrecl+1)
        Line.kk = Strip(Substr(Line.kk,1,lrecl),'T')
        Call TagChange kk
        Call TagChange mm
      End
    End
  End
  alt = alt+1
return
 
 
 
ShiftlinesLeft:
trace off
  sl = arg(1)                          /* start line to shift right   */
  sn = arg(2)                          /* number of lines to shift    */
  sc = arg(3)                          /* number of columns to shift  */
  Do kk = sl to sl+sn-1
    ll = index(Line.kk,'/*')
    If ll > 1 Then
      Line.kk = Substr(Insert('',Line.kk,ll-1,Pcnt1),Pcnt1+1)
    Else
      Line.kk = Substr(Line.kk,Pcnt1+1)
    Line.kk = Strip(Line.kk,'T')
    If ll > 40 & Right(Line.kk,2) = '*/' Then
    Do
      nn = min(ll-40, Pcnt1)
      Line.kk = Substr(Line.kk,1,ll-nn-1)||,
                Substr(Line.kk,ll,Length(Line.kk)-ll-1)||,
                Substr('',1,nn)||'*/'
    End
    Call TagChange kk
  End
  alt = alt+1
return
 
 
 
CommentLines:
/**********************************************************************/
/* Put line in comment or remove comment                              */
/**********************************************************************/
trace off
  cl = arg(1)                          /* first line to change comment*/
  cn = arg(2)                          /* number of lines to change   */
  ct = 0                               /* number of truncated lines   */
  Do xx = cl to cl+cn-1
    If Line.xx ^= '' Then
    Do
      LeftComm  = Pos('/*',Line.xx)
      RightComm = LastPos('*/',Line.xx)
      FirstColl = Pos(Strip(Line.xx,'L'),Line.xx)
      LastColl  = Length(Strip(Line.xx,'T'))
      If LeftComm = FirstColl & RightComm = LastColl-1 Then
      Do                               /* remove comment              */
        Line.xx = Substr(Line.xx,1,LeftComm-1)||,
            Substr(Line.xx,LeftComm+2,RightComm-LeftComm-2)
        Do while Pos('.*',Line.xx) > 0
          Line.xx = Overlay('/',Line.xx,Pos('.*',Line.xx))
        End
        Do while Pos('*.',Line.xx) > 0
          Line.xx = Overlay('/',Line.xx,Pos('*.',Line.xx)+1)
        End
      End
      Else                             /* put line in comments        */
      Do
        Do while Pos('/*',Line.xx) > 0
          Line.xx = Overlay('.',Line.xx,Pos('/*',Line.xx))
        End
        Do while Pos('*/',Line.xx) > 0
          Line.xx = Overlay('.',Line.xx,Pos('*/',Line.xx)+1)
        End
        Line.xx = Substr(Line.xx,1,FirstColl-1)'/*'||,
            Substr(Line.xx,FirstColl,LastColl-FirstColl+1)'*/'
        If Length(Line.xx) > Lrecl Then
          ct = ct+1
      End
      Call TagChange xx
    End
  End
  If ct > 0 Then
    msg = ct 'lines truncated'
  alt = alt+1
return
 
 
 
BeginOfLine:
trace off
  If cursor = 'DAXEDIT' Then
  Do
    If Hex = 'ON' Then
    Do
      If curline = 0 Then
       i = (CursorLine+4)%3+curline-1
      Else
       i = (CursorLine+2)%3+curline-1
    End
    Else
      i = CursorLine+curline-1
    If i <= 0 | i > size Then
    Do
      msg = 'Cursor not on valid field'
      Return
    End
    curcol = verify(line.i,' ')
    If curcol = 0 Then curcol = 1
    If CurCol < StartCol | CurCol >= StartCol+73 Then
    Do
      If Curcol > 72 Then
        StartCol = Curcol-30
      Else
        StartCol = 1
    End
    CursorPos = curcol-startcol+1
    CursorArea = 'File'
  End
  Else
   msg = 'Cursor not on valid field'
return
 
 
 
EndOfLine:
trace off
  If Cursor = 'DAXEDIT' Then
  Do
    If Hex = 'ON' Then
    Do
      If curline = 0 Then
       i = (CursorLine+4)%3+curline-1
      Else
       i = (cursorLine+2)%3+curline-1
    End
    Else
      i = CursorLine+curline-1
    If i <= 0 | i > size Then
    Do
      msg = 'Cursor not on valid field'
      Return
    End
    If CursorArea = 'File' &,
       cursorPos+StartCol-1 = min(lrecl,length(strip(line.i,'T'))+1) Then
    Do
      If i = size Then
      Do
        i = 1
        CursorLine = 1
        curline = 1
      End
      Else
      Do
        i = i+1
        If Hex = 'ON' Then
          CursorLine = CursorLine+3
        Else
          CursorLine = CursorLine+1
 
        If CursorLine > Vdepth Then
        Do
          CursorLine = 1
          Curline = i
        End
      End
    End
    curcol = min(lrecl,length(strip(line.i,'T'))+1)
    If CurCol < StartCol | CurCol >= StartCol+73 Then
    Do
      If Curcol > 72 Then
        StartCol = min(lrecl-72,Curcol-30)
      Else
        StartCol = 1
    End
    CursorPos = curcol-startcol+1
    CursorArea = 'File'
  End
  Else
   msg = 'Cursor not on valid field'
return
 
 
 
Uppercase:
trace off
  ul = arg(1)                          /* first line to uppercase     */
  un = arg(2)                          /* number of lines to change   */
  Do xx = ul to ul+un-1
    UpperLine = Line.xx
    If Index(UpperLine,'/*') > 0 &,
       Index(UpperLine,'*/') > Index(UpperLine,'/*') Then
    Do
      parse var UpperLine txt1'/*'comment'*/'txt2
      txt1 = translate(,
         txt1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
      txt2 = translate(,
         txt2, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
      Line.xx = txt1'/*'comment'*/'txt2
    End
    Else
      Line.xx = translate(,
         Line.xx, 'ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ','abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì')
    Call TagChange xx
  End
return
 
 
 
Lowercase:
trace off
  ul = arg(1)                          /* first line to Lowercase     */
  un = arg(2)                          /* number of lines to change   */
  Do xx = ul to ul+un-1
    UpperLine = Line.xx
    If Index(UpperLine,'/*') > 0 &,
       Index(UpperLine,'*/') > Index(UpperLine,'/*') Then
    Do
      parse var UpperLine txt1'/*'comment'*/'txt2
      txt1 = translate(,
        txt1,'abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì','ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ')
      txt2 = translate(,
        txt2,'abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì','ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ')
      Line.xx = txt1'/*'comment'*/'txt2
    End
    Else
      Line.xx = translate(,
        Line.xx,'abcdefghijklmnopqrstuvwxyzâäàáãåçñéêëèíîïì','ABCDEFGHIJKLMNOPQRSTUVWXYZÂÄÀÁÃÅÇÑÉÊËÈÍÎÏÌ')
    Call TagChange xx
  End
return
 
 
 
CheckCmd: procedure expose Nrsynonyms synonym. SynLen. SynCmd.
trace off
  CheckC = arg(1)
  dset = arg(2)
 
  If translate(Substr(CheckC,1,2))^='SY' Then /* not a synonym command*/
  Do
    cmd1 = translate(CheckC)
    Cmd1Len = Verify(cmd1,'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%?!\/','NoMatch')-1
    If Cmd1Len <= 0 Then Cmd1Len = Length(Cmd1)
    Do i = 1 to NrSynonyms,
      Until ABBREV(Synonym.i, cmd1, SynLen.i)
      cmd1 = substr(cmd1,1,Max(Cmd1Len, SynLen.i))
    End
    If i <= NrSynonyms Then
      CheckC = SynCmd.i||Substr(CheckC,Length(Cmd1)+1)
 
    parse var dset dset '(' mem ')'
    parse var dset pr '.' gr '.' ty '.' .
    replace.1 = '&DATASET';  by.1 = "'"dset"'"
    replace.2 = '&MEMBER';   by.2 = mem
    replace.3 = '&PROJECT';  by.3 = pr
    replace.4 = '&GROUP';    by.4 = gr
    replace.5 = '&TYPE';     by.5 = ty
    replace.6 = '/'
    If mem = '' | Index(mem,'*') > 0 Then
      by.6 = "'"dset"'"
    Else
      by.6 = "'"dset"("mem")'"
    LastReplace = 6
    If index(CheckC,'/') > 0 Then
    Do
      i = verify(Translate(CheckC),'ABCDEFGHIJKLMNOPQRSTUVWXYZ' )
      cmd = Strip(Substr(Translate(CheckC),1,i-1))
      If Abbrev('CHANGE',cmd) | Abbrev('LOCATE',cmd,2) | ,
         Abbrev('TAGCHANGE',cmd,3) | Abbrev('DELETELINES',cmd,7) | ,
         Substr(cmd,1,3) = 'COL' | Abbrev('PC',cmd,2) Then
        LastReplace = 5
      If Abbrev('PFKEY',cmd,2) Then
        LastReplace = 0
    End
    Do i = 1 to LastReplace
      Do while index(translate(CheckC),replace.i) > 1
        J = index(Translate(CheckC),replace.i)
        CheckC = substr(CheckC,1,j-1)||by.i||,
                 substr(CheckC,j+Length(replace.i))
      End
    End
  End                                  /* not a synonym command       */
return CheckC
 
 
 
SplitJoin:
trace off
  If cursor = 'DAXEDIT' & CursorArea = 'File' Then
  Do
    If Hex = 'ON' Then
    Do
      If curline = 0 Then
       i = (CursorLine+4)%3+curline-1
      Else
       i = (CursorLine+2)%3+curline-1
    End
    Else
      i = CursorLine+curline-1
    If i <= 0 | i > size Then
    Do
      msg = 'Cursor not on valid field'
      Return
    End
    alt = alt+1
    j = i+1
    If startcol+CursorPos-1 > length(Strip(line.i,'T')) Then
    Do
      If line.j = '' Then
        Call DelLines j,1
      Else
      Do
        line.i = Substr(line.i,1,startcol+CursorPos-2)||,
                 Substr(line.j,verify(line.j,' '))
        If length(line.i) > lrecl Then
        Do
          Line.j = Substr(Line.i,lrecl+1)
          Line.i = Strip(Substr(Line.i,1,lrecl),'T')
        End
        Else
          Call DelLines j,1
      End
      Call TagChange i
    End
    Else
    Do
      Call AddLines i,1
      line.j = Substr('',1,verify(line.i,' ')-1)|| ,
               Substr(line.i,startcol+CursorPos-1)
      line.i = Substr(line.i,1,startcol+CursorPos-2)
      Call TagChange i
      Call TagChange j
    End
  End
  Else
   msg = 'Cursor not on valid field'
return
 
 
 
TagChange:
trace off
  If word(tagchange,1) = 'OFF' Then return
  TagLine = arg(1)
  parse var tagchange TagOnOff TagString TagFrom TagTo TagOption
  If Substr(TagString,1,2) = '/*' & Right(TagString,2) = '*/' & ,
     Pos('/*', Substr(line.Tagline,1,TagFrom+2)) > 0 & ,
     Pos('*/', Substr(line.Tagline,TagTo-2)) > 0 Then
  Do
    Parse var TagString '/*' TagString '*/'
    TagTo = TagTo-2
  End
  TagFrom = TagTo-Length(TagString)+1
  If TagOption = 'IFBLANK' & ,
     Substr(line.TagLine, TagFrom, TagTo-TagFrom+1) ^= '' | ,
     line.TagLine = '' Then
    return
  line.Tagline = Overlay(TagString,line.TagLine,TagFrom)
Return
 
 
 
UnTagChange:
trace off
  ul = arg(1)                          /* first line to untag         */
  un = arg(2)                          /* number of lines to untag    */
  parse var tagchange TagOnOff TagString TagFrom TagTo TagOption
  Do xx = ul to ul+un-1
    If Substr(TagString,1,2) = '/*' & Right(TagString,2) = '*/' & ,
       Pos('/*', Substr(line.xx,1,TagFrom)) > 0 & ,
       Pos('*/', Substr(line.xx,TagTo-1)) > 0 Then
    Do
      Parse var TagString '/*' UnTagString '*/'
      TagClear = Substr('',1,Length(UnTagString))
      UnTagTo = TagTo-2
      UnTagFrom = TagFrom+2
    End
    Else
    Do
      UnTagString = TagString
      TagClear = Substr('',1,Length(TagString))
      UnTagTo = TagTo
      UnTagFrom = TagFrom
    End
    TagPos = Pos(UnTagString,Substr(line.xx,1,TagTo),TagFrom)
    If TagPos > 0 Then
      line.xx = Overlay(TagClear,line.xx,TagPos)
  End
Return
 
 
 
SaveRing:
trace off
  r = arg(1)
  r = word(rings,r)
  Do i = 1 to size
    ring.r.sline.i = Line.i
    ring.r.scommand.i = command.i
  End
  ring.r.sdataset        = dataset
  ring.r.sxxgroup1       = xxgroup1
  ring.r.sxxgroup2       = xxgroup2
  ring.r.sxxgroup3       = xxgroup3
  ring.r.sxxgroup4       = xxgroup4
  ring.r.sautosavedset   = AutosaveDset
  ring.r.sautosave       = autosave
  ring.r.scase           = case
  ring.r.snulls          = nulls
  ring.r.slanguage       = language
  ring.r.shex            = hex
  ring.r.shorizontal     = horizontal
  ring.r.ssize           = size
  ring.r.ssaveCmd        = saveCmd
  ring.r.ssavePrefixCmd  = savePrefixCmd
  ring.r.ssaveC          = saveC
  ring.r.snrprefcmd      = nrprefcmd
  ring.r.scurline        = curline
  ring.r.scurcol         = curcol
  ring.r.sstartcol       = startcol
  ring.r.scursor         = cursor
  ring.r.sCursorLine     = CursorLine
  ring.r.sCursorPos      = CursorPos
  ring.r.scutnrlines     = cutnrlines
  ring.r.scutpasteoffset = cutpasteoffset
  ring.r.scutsquareoffset= cutsquareoffset
  ring.r.scutsquarestatus= cutsquarestatus
  ring.r.ssavecursor     = savecursor
  ring.r.slrecl          = lrecl
  ring.r.srecfm          = recfm
  ring.r.sblksize        = blksize
  ring.r.sdsorg          = dsorg
  ring.r.sxtype          = xtype
  ring.r.salt            = alt
  ring.r.stotalalt       = totalalt
  ring.r.sfullscale      = fullscale
  ring.r.stimestamp      = timestamp
  ring.r.stagchange      = tagchange
  ring.r.stags           = tags
  Do i = 1 to words(tags)
    t = word(tags,i)
    ring.r.stag.t = tag.t
  End
return
 
 
 
GetRing:
trace off
  r = arg(1)
  r = word(rings,r)
  dataset        = ring.r.sdataset
  parse var dataset . '(' member ')'
  xxgroup1       = ring.r.sxxgroup1
  xxgroup2       = ring.r.sxxgroup2
  xxgroup3       = ring.r.sxxgroup3
  xxgroup4       = ring.r.sxxgroup4
  AutosaveDset   = ring.r.sautosavedset
  autosave       = ring.r.sautosave
  case           = ring.r.scase
  nulls          = ring.r.snulls
  language       = ring.r.slanguage
  hex            = ring.r.shex
  horizontal     = ring.r.shorizontal
  size           = ring.r.ssize
  saveCmd        = ring.r.ssaveCmd
  savePrefixCmd  = ring.r.ssavePrefixCmd
  saveC          = ring.r.ssaveC
  nrprefcmd      = ring.r.snrprefcmd
  curline        = ring.r.scurline
  curcol         = ring.r.scurcol
  startcol       = ring.r.sstartcol
  cursor         = ring.r.scursor
  CursorLine     = ring.r.scursorline
  CursorPos      = ring.r.scursorpos
  cutpasteoffset = ring.r.scutpasteoffset
  cutsquareoffset= ring.r.scutsquareoffset
  cutsquarestatus= ring.r.scutsquarestatus
  savecursor     = ring.r.ssavecursor
  lrecl          = ring.r.slrecl
  recfm          = ring.r.srecfm
  blksize        = ring.r.sblksize
  dsorg          = ring.r.sdsorg
  xtype          = ring.r.sxtype
  alt            = ring.r.salt
  totalalt       = ring.r.stotalalt
  fullscale      = ring.r.sfullscale
  timestamp      = ring.r.stimestamp
  tagchange      = ring.r.stagchange
  tags           = ring.r.stags
  Do i = 1 to words(tags)
    t = word(tags,i)
    tag.t = ring.r.stag.t
  End
  Do i = 1 to size
    Line.i = ring.r.sline.i
    command.i = ring.r.scommand.i
  End
return
 
 
 
DropRing:
trace off
  r = arg(1)
  r = word(rings,r)
  Drop ring.r.sdataset
  Drop ring.r.sxxgroup1
  Drop ring.r.sxxgroup2
  Drop ring.r.sxxgroup3
  Drop ring.r.sxxgroup4
  Drop ring.r.sautosavedset
  Drop ring.r.sautosave
  Drop ring.r.scase
  Drop ring.r.snulls
  Drop ring.r.slanguage
  Drop ring.r.shex
  Drop ring.r.shorizontal
  Drop ring.r.ssize
  Drop ring.r.ssaveCmd
  Drop ring.r.ssavePrefixCmd
  Drop ring.r.ssaveC
  Drop ring.r.snrprefcmd
  Drop ring.r.scurline
  Drop ring.r.scurcol
  Drop ring.r.sstartcol
  Drop ring.r.scursor
  Drop ring.r.scursorline
  Drop ring.r.scursorpos
  Drop ring.r.scutnrlines
  drop ring.r.scutpasteoffset
  drop ring.r.scutsquareoffset
  drop ring.r.scutsquarestatus
  Drop ring.r.ssavecursor
  Drop ring.r.slrecl
  Drop ring.r.srecfm
  Drop ring.r.sblksize
  Drop ring.r.sdsorg
  Drop ring.r.sxtype
  Drop ring.r.salt
  Drop ring.r.stotalalt
  Drop ring.r.sfullscale
  Drop ring.r.stimestamp
  Drop ring.r.stagchange
  Drop ring.r.stags
  Do i = 1 to words(tags)
    t = word(tags,i)
    Drop ring.r.stag.t
  End
  Do i = 1 to size
    Drop ring.r.sline.i
    Drop ring.r.scommand.i
  End
return
 
 
QueueCommand:
  Parse Arg Qcmd
  NrQueuedCmds = NrQueuedCmds+1
  QueuedCmd.NrQueuedCmds = Qcmd
Return
 
 
HandleQueuedCommands:
If xdebug = 'Y' Then trace r
  QcmdNr = 1
  Do While QcmdNr <= NrQueuedCmds
    cmd = QueuedCmd.QcmdNr
    Call HandleCommand
    Call HandlePrefixCommands
    QcmdNr = QcmdNr + 1
  End
  NrQueuedCmds = 0
Return
 
 
RecallCmd:
trace off
  PrevCursor = Cursor
  PrevCsrpos = Csrpos
  cursor = 'R1'
  csrpos = '1'
  cmd = ''
  R1  = RecallCmd.1;           R51 = RecallCmd.51
  R2  = RecallCmd.2;           R52 = RecallCmd.52
  R3  = RecallCmd.3;           R53 = RecallCmd.53
  R4  = RecallCmd.4;           R54 = RecallCmd.54
  R5  = RecallCmd.5;           R55 = RecallCmd.55
  R6  = RecallCmd.6;           R56 = RecallCmd.56
  R7  = RecallCmd.7;           R57 = RecallCmd.57
  R8  = RecallCmd.8;           R58 = RecallCmd.58
  R9  = RecallCmd.9;           R59 = RecallCmd.59
  R10 = RecallCmd.10;          R60 = RecallCmd.60
  R11 = RecallCmd.11;          R61 = RecallCmd.61
  R12 = RecallCmd.12;          R62 = RecallCmd.62
  R13 = RecallCmd.13;          R63 = RecallCmd.63
  R14 = RecallCmd.14;          R64 = RecallCmd.64
  R15 = RecallCmd.15;          R65 = RecallCmd.65
  R16 = RecallCmd.16;          R66 = RecallCmd.66
  R17 = RecallCmd.17;          R67 = RecallCmd.67
  R18 = RecallCmd.18;          R68 = RecallCmd.68
  R19 = RecallCmd.19;          R69 = RecallCmd.69
  R20 = RecallCmd.20;          R70 = RecallCmd.70
  R21 = RecallCmd.21;          R71 = RecallCmd.71
  R22 = RecallCmd.22;          R72 = RecallCmd.72
  R23 = RecallCmd.23;          R73 = RecallCmd.73
  R24 = RecallCmd.24;          R74 = RecallCmd.74
  R25 = RecallCmd.25;          R75 = RecallCmd.75
  R26 = RecallCmd.26;          R76 = RecallCmd.76
  R27 = RecallCmd.27;          R77 = RecallCmd.77
  R28 = RecallCmd.28;          R78 = RecallCmd.78
  R29 = RecallCmd.29;          R79 = RecallCmd.79
  R30 = RecallCmd.30;          R80 = RecallCmd.80
  R31 = RecallCmd.31;          R81 = RecallCmd.81
  R32 = RecallCmd.32;          R82 = RecallCmd.82
  R33 = RecallCmd.33;          R83 = RecallCmd.83
  R34 = RecallCmd.34;          R84 = RecallCmd.84
  R35 = RecallCmd.35;          R85 = RecallCmd.85
  R36 = RecallCmd.36;          R86 = RecallCmd.86
  R37 = RecallCmd.37;          R87 = RecallCmd.87
  R38 = RecallCmd.38;          R88 = RecallCmd.88
  R39 = RecallCmd.39;          R89 = RecallCmd.89
  R40 = RecallCmd.40;          R90 = RecallCmd.90
  R41 = RecallCmd.41;          R91 = RecallCmd.91
  R42 = RecallCmd.42;          R92 = RecallCmd.92
  R43 = RecallCmd.43;          R93 = RecallCmd.93
  R44 = RecallCmd.44;          R94 = RecallCmd.94
  R45 = RecallCmd.45;          R95 = RecallCmd.95
  R46 = RecallCmd.46;          R96 = RecallCmd.96
  R47 = RecallCmd.47;          R97 = RecallCmd.97
  R48 = RecallCmd.48;          R98 = RecallCmd.98
  R49 = RecallCmd.49;          R99 = RecallCmd.99
  R50 = RecallCmd.50;
 
  Address ISPEXEC 'VPUT ('AllR')'
 
  Address ISPEXEC 'ADDPOP'
  Do until pfkey = 'PF03' | pfkey = 'PF15' | cmd ^= ''
    Address ISPEXEC 'VPUT (CURSOR,CSRPOS)'
    Address ISPEXEC 'DISPLAY PANEL(XEDITREC)'
    If rc > 8 Then
    Do
      If symbol('ZERRLM') = 'VAR' Then
        Say 'ISPF error: 'ZERRLM',cursor='cursor', csrpos='csrpos
      cursor = 'R1'
      csrpos = '1'
      Address ISPEXEC 'VPUT (CURSOR,CSRPOS)'
      Address ISPEXEC 'DISPLAY PANEL(XEDITREC)'
      If rc ^= 0 Then
        pfkey = 'PF03'
    End
    Address ISPEXEC 'VGET (PFKEY,CURSOR,CSRPOS)'
    Address ISPEXEC 'VGET ('AllR')'
    Select
      When pfkey = '' | pfkey = 'PF05' | pfkey = 'PF17' Then
      Do
        cursor = strip(cursor)
        If Substr(cursor,1,1) = 'R' Then cmd = Value(cursor)
      End
      Otherwise
        nop
    End
  End
  Address ISPEXEC 'REMPOP'
  Cursor = PrevCursor
  Csrpos = PrevCsrpos
  If cmd ^= '' & cmd ^= '?' &,
     ABBREV('RECALL',Word(Translate(cmd),1)) = 0 Then
  Do
    SaveCmd = cmd
    If pfkey = '' Then
    Do
      CommandIssued = 'Yes'
      Call SaveRecallCmd
      If substr(cmd,1,1) = '&' Then
      Do
        cmd = substr(cmd,2)
        KeepCommand = 'On'
      End
      Call HandleCommand
    End
    IF pfkey = 'PF05' | pfkey = 'PF17' Then
      KeepCommand = 'On'
  End
  Cursor = Cursor
  Csrpos = Csrpos
return
 
 
 
DisplayRing:
trace off
  PrevCursor = Cursor
  PrevCsrpos = Csrpos
  cursor = 'R'curring
  csrpos = '1'
  cmd = ''
  If NrRing > 99 Then
    msg = 'You have more than 99 datasets in the XEDIT-ring'
  Else
    msg = ''
  Do i = 1 to 99
    If i <= NrRing Then
    Do
      r = word(rings,i)
      Interpret 'R'i '= ring.r.sdataset'
    End
    Else
      Interpret 'R'i '= ""'
  End
 
  Address ISPEXEC 'VPUT ('AllR')'
 
  Address ISPEXEC 'ADDPOP'
 
  Do until pfkey = 'PF03' | pfkey = 'PF15' | cmd ^= ''
    Address ISPEXEC 'VPUT (CURSOR,CSRPOS,MSG)'
    Address ISPEXEC 'DISPLAY PANEL(XEDITRNG)'
    If rc > 8 Then
    Do
      If symbol('ZERRLM') = 'VAR' Then
        Say 'ISPF error: 'ZERRLM',cursor='cursor', csrpos='csrpos
      cursor = 'R1'
      csrpos = '1'
      Address ISPEXEC 'VPUT (CURSOR,CSRPOS)'
      Address ISPEXEC 'DISPLAY PANEL(XEDITREC)'
      If rc ^= 0 Then
        pfkey = 'PF03'
    End
    Address ISPEXEC 'VGET (PFKEY,CURSOR,CSRPOS)'
    If pfkey = '' Then
    Do
      cursor = strip(cursor)
      If Substr(cursor,1,1) = 'R' & Datatype(substr(cursor,2)) = 'NUM' Then
        cmd = 'x' substr(cursor,2)
    End
  End
  Address ISPEXEC 'REMPOP'
  msg = ''
  Cursor = PrevCursor
  Csrpos = PrevCsrpos
  If cmd ^= '' Then
    Call HandleCommand
return
 
 
 
DisplayTags:
trace off
  PrevCursor = Cursor
  PrevCsrpos = Csrpos
  cursor = 'R'curring
  csrpos = '1'
  cmd = ''
  If words(tags) > 99 Then
    msg = 'You have more than 99 tags in this dataset'
  Else
    msg = ''
  j = 0
  Do i = 1 to Min(99, Words(tags))
    t = word(tags,i)
    If Datatype(tag.t,'W') = 1 Then
    Do
      j = j+1
      linenr = tag.t
      Interpret 'R'j '= substr(t,1,4)||format(linenr,5)"  "line.linenr'
      TagCmd.j = '.'t
    End
  End
 
  If j = 0 Then
  Do
    msg = 'There are no tags in this file'
    return
  End
 
  Do j = j+1 to 99
    Interpret 'R'j '= ""'
    TagLine.j = ''
  End
 
  Address ISPEXEC 'VPUT ('AllR')'
 
  Address ISPEXEC 'ADDPOP'
 
  Do until pfkey = 'PF03' | pfkey = 'PF15' | cmd ^= ''
    Address ISPEXEC 'VPUT (CURSOR,CSRPOS,MSG)'
    Address ISPEXEC 'DISPLAY PANEL(XEDITTAG)'
    If rc > 8 Then
    Do
      If symbol('ZERRLM') = 'VAR' Then
        Say 'ISPF error: 'ZERRLM',cursor='cursor', csrpos='csrpos
      cursor = 'R1'
      csrpos = '1'
      Address ISPEXEC 'VPUT (CURSOR,CSRPOS)'
      Address ISPEXEC 'DISPLAY PANEL(XEDITTAG)'
      If rc ^= 0 Then
        pfkey = 'PF03'
    End
    Address ISPEXEC 'VGET (PFKEY,CURSOR,CSRPOS)'
    If pfkey = '' Then
    Do
      cursor = strip(cursor)
      If Substr(cursor,1,1) = 'R' & Datatype(substr(cursor,2)) = 'NUM' Then
      Do
        CursorNr = substr(cursor,2)+0
        cmd = Tagcmd.CursorNr
      End
    End
  End
  Address ISPEXEC 'REMPOP'
  msg = ''
  Cursor = PrevCursor
  Csrpos = PrevCsrpos
  If cmd ^= '' Then
    Call HandleCommand
return
 
 
 
SaveRecallCmd:
trace off
  If cmd ^= '' & cmd ^= '?' &,
     ABBREV('RECALL',Word(Translate(cmd),1)) = 0 & cmd ^= ''Then
  Do
    Do i = 1 to 99 Until RecallCmd.i = cmd
    End
    Do j = i-1 to 1 by -1
      k = j+1
      RecallCmd.k = RecallCmd.j
    End
    RecallCmd.1 = cmd
  End
return
 
 
 
HandleXXedit:
trace off
  xxdset = arg(1)
  parse var xxdset xxpro '.' xxgr1 '.' xxtyp '(' xxmem ')'
  xxgr2  = arg(2)
  xxgr3  = arg(3)
  xxgr4  = arg(4)
  xxdst  = ''
  xxall = 'xxpro xxgr1 xxgr2 xxgr3 xxgr4 xxtyp xxmem xxdst xxcursor'
  SavedCursor = Cursor
  SavedCsrpos = Csrpos
  Select
    When xxdset = '' Then
    Do
      Address ISPEXEC 'VGET ('xxall') PROFILE'
      xxOK = 'No'
      xxFound = 'No'
      cursor = xxcursor
    End
    When xxpro='' | xxgr1='' | xxtyp='' | Pos('.',xxmem) > 0 Then
    Do
      Address ISPEXEC 'VGET ('xxall') PROFILE'
      xxdst = arg(1)
      cursor = 'XXDST'
      Call CheckXEDITX
    End
    Otherwise
    Do
      cursor = 'XXMEM'
      Call CheckXEDITX
    End
  End
  Address ISPEXEC 'ADDPOP'
  Do While xxOK='No' & xxFound='No' & pfkey^='PF03' & pfkey^='PF15'
    csrpos = '1'
    Address ISPEXEC 'VPUT (CURSOR CSRPOS MSG)'
    Address ISPEXEC 'VPUT ('xxall')'
    Address ISPEXEC 'DISPLAY PANEL(XEDITX)'
    If rc > 8 Then
    Do
      If symbol('ZERRLM') = 'VAR' Then
        Say 'ISPF error: 'ZERRLM',cursor='cursor', csrpos='csrpos
      cursor = ''
      csrpos = '1'
      Address ISPEXEC 'VPUT (CURSOR,CSRPOS)'
      Address ISPEXEC 'DISPLAY PANEL(XEDITX)'
    End
    msg = ''
    Address ISPEXEC 'VGET ('xxall')'
    Address ISPEXEC 'VGET (PFKEY,CURSOR)'
    xxcursor = cursor
    Address ISPEXEC 'VPUT ('xxall') PROFILE'
    Select
      When pfkey = 'PF03' | pfkey = 'PF15' Then
        nop
      When pfkey = '' Then
        Call CheckXEDITX
      Otherwise
        nop
    End
  End
  Address ISPEXEC 'REMPOP'
  Cursor = SavedCursor
  Csrpos = SavedCsrpos
  pfkey = ''
return
 
 
CheckXEDITX:
trace off
  xxOK = 'No'                          /* not all OK yet              */
  xxFound = 'No'                       /* member not yet found        */
  xxgr. = ''                           /* do not use xxgr.* yet       */
  If xxdst ^= '' & cursor = 'XXDST' Then
  Do
    xxdst = CheckName(xxdst)
    Call CheckDataset xxdst
    If result < 8 Then                 /* no real error?              */
    Do
      cmd = 'XEDIT' xxdst
      Call HandleCommand
      If msg = '' Then
        xxOK = 'Yes'
    End
  End
  Else
  Do
    Select
      When xxpro = '' Then
      Do
        msg = 'Specify the project qualifier'
        cursor = 'XXPRO'
      End
      When xxgr1 = '' & xxgr2 = '' & xxgr3 = '' & xxgr4 = '' Then
      Do
        msg = 'Specify the group qualifier'
        cursor = 'XXGR1'
      End
      When xxtyp = '' Then
      Do
        msg = 'Specify the type qualifier'
        cursor = 'XXTYP'
      End
      Otherwise
      Do
        xx = 0
        If xxgr1 ^= '' Then
        Do
          xx = xx+1
          xxgr.xx = xxgr1
        End
        If xxgr2 ^= '' Then
        Do
          xx = xx+1
          xxgr.xx = xxgr2
        End
        If xxgr3 ^= '' Then
        Do
          xx = xx+1
          xxgr.xx = xxgr3
        End
        If xxgr4 ^= '' Then
        Do
          xx = xx+1
          xxgr.xx = xxgr4
        End
        xxOK = 'Yes'                   /* assume all OK               */
        Do xx = 1 to 4 Until xxOK = 'No' | xxFound = 'Yes'
          If xxgr.xx ^= '' Then
          Do
            Call CheckDataset xxpro'.'xxgr.xx'.'xxtyp
            If result >= 8 | sysdsorg = 'DS' THEN
            Do
              cursor = 'XXGR'xx
              xxOK = 'No'
            End
            Else
            Do
              If xxmem ^= '' & index(xxmem, '*') = 0 Then
              Do
                msgstat = msg('OFF')
                If sysdsn("'"xxpro"."xxgr.xx"."xxtyp"("xxmem")'") = "OK" Then
                Do
                  xxFound = 'Yes'
                  cmd = 'XEDIT' xxpro'.'xxgr.xx'.'xxtyp'('xxmem')'
                  Call HandleCommand
                End
                msgstat = msg(msgstat)
              End
            End
          End
        End                            /* end for all groups          */
        If xxOK = 'Yes' & xxFound = 'No' Then
        Do
          If xxmem = '' Then
            cmd = 'XEDIT' xxpro'.'xxgr.1'.'xxtyp
          Else
            cmd = 'XEDIT' xxpro'.'xxgr.1'.'xxtyp'('xxmem')'
          Call HandleCommand
        End
      End
    End                                /* end select                  */
  End
  xxgr. = ''                           /* reset groups for XEDIT      */
return
 
 
AskConfirmation:
  SavedCursor = Cursor
  SavedCsrpos = Csrpos
  SavedId = Id
  SavedDset = Dset
  cursor = 'OPTION1'
  csrpos = '1'
  msg = ''
  Address ISPEXEC 'ADDPOP'
  Do until pfkey = 'PF03' | pfkey = 'PF15' | ,
           cursor = 'OPTION1' | cursor = 'OPTION2'
    Address ISPEXEC 'VPUT (CURSOR,CSRPOS,DATASET,MSG)'
    Address ISPEXEC 'DISPLAY PANEL(XEDITCNF)'
    If rc > 8 Then
    Do
      If symbol('ZERRLM') = 'VAR' Then
        Say 'ISPF error: 'ZERRLM',cursor='cursor', csrpos='csrpos
      cursor = 'OPTION1'
      csrpos = '1'
      panel = 'XEDHELP'
      Address ISPEXEC 'VPUT (CURSOR,CSRPOS)'
      Address ISPEXEC 'DISPLAY PANEL(XEDITCNF)'
      If rc ^= 0 Then
        pfkey = 'PF03'
    End
    Address ISPEXEC 'VGET (PFKEY,CURSOR)'
    Select
      When pfkey = 'PF03' | pfkey = 'PF15' Then
        LockRequested = 'No'
      When CURSOR = 'OPTION2' Then
        Nop
      Otherwise
      Do
        SavedDataset = dataset
        cmd = 'QQUIT'
        call HandleCommand
        cmd = 'XEDIT' SavedDataset
        call HandleCommand
        cursor = 'OPTION2'
      End
    End
  End
  Address ISPEXEC 'REMPOP'
  Cursor = SavedCursor
  Csrpos = SavedCsrpos
  Id = SavedId
  Dset = SavedDset
  pfkey = ''
return
 
 
 
Initializations:
  sdataset        = 'dataset'
  sxxgroup1       = 'xxgroup1'
  sxxgroup2       = 'xxgroup2'
  sxxgroup3       = 'xxgroup3'
  sxxgroup4       = 'xxgroup4'
  sautosavedset   = 'autosavedset'
  sautosave       = 'autosave'
  scase           = 'case'
  snulls          = 'nulls'
  slanguage       = 'language'
  shex            = 'hex'
  shorizontal     = 'horizontal'
  ssize           = 'size'
  scurline        = 'curline'
  sline           = 'line'
  scommand        = 'command'
  ssavecmd        = 'savecmd'
  ssaveprefixcmd  = 'saveprefixcmd'
  ssavec          = 'savec'
  snrprefcmd      = 'nrprefcmd'
  scurcol         = 'curcol'
  sstartcol       = 'startcol'
  scursor         = 'cursor'
  scursorline     = 'cursorline'
  scursorpos      = 'cursorpos'
  scutnrlines     = 'cutnrlines'
  scutpasteoffset = 'cutpasteoffset'
  sCutSquareOffset= 'CutSquareOffset'
  sCutSquareStatus= 'CutSquareStatus'
  ssavecursor     = 'savecursor'
  slrecl          = 'lrecl'
  srecfm          = 'recfm'
  sblksize        = 'blksize'
  sdsorg          = 'dsorg'
  sxtype          = 'xtype'            /* FILE, DIR, DLIST            */
  salt            = 'alt'
  stotalalt       = 'totalalt'
  sfullscale      = 'fullscale'
  stimestamp      = 'timestamp'
  stagchange      = 'tagchange'
  stags           = 'tags'
  stag            = 'tag'
 
  FileIn     = X2C('01')              /* for dynamic area            */
  FileOut    = X2C('02')
  PrefixIn   = X2C('03')
  PrefixOut  = X2C('04')
  TofOut     = X2C('05')
  MemberIn   = X2C('06')
  MemberOut  = X2C('07')
  DatasetIn  = X2C('08')
  DatasetOut = X2C('09')
  ScaleIn    = X2C('10')
  ScaleOut   = X2C('11')
  UserMod    = X2C('38')
 
  Displayable = " âäàáãåçñ¢.<(+|&éêëèíîïìß!$*);^-/ÂÄÀÁÃÅÇÑ¦,%_>?øÉÊËÈÍÎÏÌ`:#@'"||,
     '="Øabcdefghi«»ðýþ±°jklmnopqrªºæ¸Æ¤µ~stuvwxyz¡¿Ð[Þ®¬£¥·©§¶¼½¾Ý¨¯]´×{ABCDEFGHI­ôöòóõ}JKLMNOPQR¹ûüùúÿ\÷STUVWXYZ²ÔÖÒÓÕ0123456789³ÛÜÙÚ'
 
  rings = ''
  CurRing = 0
  NrRing = 0
  NrSynonyms = 0
  NrQueuedCmds = 0
  AllR = 'R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 ' ||,
         'R11 R12 R13 R14 R15 R16 R17 R18 R19 R20 ' ||,
         'R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 ' ||,
         'R31 R32 R33 R34 R35 R36 R37 R38 R39 R40 ' ||,
         'R41 R42 R43 R44 R45 R46 R47 R48 R49 R40 ' ||,
         'R51 R52 R53 R54 R55 R56 R57 R58 R59 R50 ' ||,
         'R61 R62 R63 R64 R65 R66 R67 R68 R69 R60 ' ||,
         'R71 R72 R73 R74 R75 R76 R77 R78 R79 R70 ' ||,
         'R81 R82 R83 R84 R85 R86 R87 R88 R89 R80 ' ||,
         'R91 R92 R93 R94 R95 R96 R97 R98 R99'
  Address ISPEXEC 'VGET ('AllR') PROFILE'
  Recallcmd. = ''
  xxgr. = ''
  Do i = 1 to 99
    Recallcmd.i = Value('R'i)
  End
  cmd = 'XEDIT' parms
  Call SaveRecallCmd
  PutLines = 0
  PrefixPenCmds = ' -- >> << (( )) CC DD FP KK LL LLC MM PPD PP RR TT UTT UU UUC "" '
  pcmd_fp = 'FP'                       /* pending F or P prefix-cmd   */
  PrefixCmds=' ..... - > < ( ) / \ /* A B C D ELSE F DO FOR G I IF '||,
             'K L LC LEN M O PD P PUT SI SELEC R WHEN WHILE T U UC UT UNTIL X XE " '
 
  PenCmd = ''
  Cmd = ''
  PrevHorCmd = ''
  Address ISPEXEC 'VPUT (CMD)'
  PenLine = 0
  Address ISPEXEC 'VGET (ZSCREEND)'
  Vdepth = ZscreenD-4
  CursorLine = 1
  DB2subsystem = ''
 
  Address ISPEXEC 'CONTROL ERRORS RETURN'
 
  ArrowA     = 'YELLOW REVERSE'
  CmdA       = 'WHITE         '
  FileA      = 'GREEN         '
  IDlineA    = 'TURQ   REVERSE'
  MsgA       = 'YELLOW REVERSE'
  ScaleA     = 'YELLOW        '
  PrefixA    = 'TURQ          '
  MemberA    = 'TURQ          '
  DatasetA   = 'TURQ          '
  PFkeysA    = 'RED    REVERSE'
  TofA       = 'YELLOW        '
  Xprefix    = 'LEFT'
  statistics = 'OFF'
  autosave   = 30
  case       = 'MIXED IGNORE'
  hex        = 'OFF'
  horizontal = 'ON'
  nulls      = 'OFF'
  tabs       = '43'
  tabline    = 'OFF'
  timezone   = '+ 00:00'
  CutNrLines = -1                      /* no lines cut                */
  CutSquareStatus = 'CutDone'          /* start al over again         */
  F01   = 'PF01'
  F02   = 'PF02'
  F03   = 'PF03'
  F04   = 'PF04'
  F05   = 'PF05'
  F06   = 'PF06'
  F07   = 'PF07'
  F08   = 'PF08'
  F09   = 'PF09'
  F10 = 'PF10'
  F11 = 'PF11'
  F12 = 'PF12'
  F13 = 'PF13'
  F14 = 'PF14'
  F15 = 'PF15'
  F16 = 'PF16'
  F17 = 'PF17'
  F18 = 'PF18'
  F19 = 'PF19'
  F20 = 'PF20'
  F21 = 'PF21'
  F22 = 'PF22'
  F23 = 'PF23'
  F24 = 'PF24'
 
  PFCmd.F01 = 'HELP'
  PFCmd.F02 = '='
  PFCmd.F03 = 'QUIT'
  PFCmd.F04 = 'BOL'
  PFCmd.F05 = 'SPLITJOIN'
  PFCmd.F06 = 'EOL'
  PFCmd.F07 = 'UP'
  PFCmd.F08 = 'DOWN'
  PFCmd.F09 = 'TOP'
  PFCmd.F10 = 'LEFT'
  PFCmd.F11 = 'RIGHT'
  PFCmd.F12 = 'BOT'
  PFCmd.F13 = 'HELP'
  PFCmd.F14 = 'SPLIT'
  PFCmd.F15 = 'QUIT'
  PFCmd.F16 = 'BOL'
  PFCmd.F17 = 'SPLITJOIN'
  PFCmd.F18 = 'EOL'
  PFCmd.F19 = 'UP'
  PFCmd.F20 = 'DOWN'
  PFCmd.F21 = 'SWAP'
  PFCmd.F22 = 'LEFT'
  PFCmd.F23 = 'RIGHT'
  PFCmd.F24 = 'RETRIEVE'
  PFkeyLine = '1=Help 2=Repeat 3=Quit 4=BOL 5=SplJo 6=EOL 7=Up 8=Down' ,
              '9=Top 10=<- 11=-> 12=Bot'
 
  RexxIf.1 = 8                           /* number of lines to insert   */
  RexxIf.2 = 1                           /* line of cursor (relative)   */
  RexxIf.3 = 3                           /* column of cursor (relative) */
  RexxIf.4 = ' DO WHEN IF THEN '         /* words increase indentation  */
  RexxIf.5 = ''                          /*words to decrease indentation*/
  RexxIf.6 = 'If ... Then'
  RexxIf.7 = 'Do'
  RexxIf.8 = ''
  RexxIf.9 = 'End'
  RexxIf.10= 'Else'
  RexxIf.11= 'Do'
  RexxIf.12= ''
  RexxIf.13= 'End'
 
  RexxElse.1 = 4
  RexxElse.2 = 3
  RexxElse.3 = 2
  RexxElse.4 = ''
  RexxElse.5 = ' END '
  RexxElse.6 = 'Else'
  RexxElse.7 = 'Do'
  RexxElse.8 = ''
  RexxElse.9 = 'End'
 
  RexxDo.1 = 3
  RexxDo.2 = 1
  RexxDo.3 = 3
  RexxDo.4 = ' DO '
  RexxDo.5 = ''
  RexxDo.6 = 'Do'
  RexxDo.7 = ''
  RexxDo.8 = 'End'
 
  RexxFor.1 = 3
  RexxFor.2 = 1
  RexxFor.3 = 3
  RexxFor.4 = ' DO WHEN IF THEN '
  RexxFor.5 = ''
  RexxFor.6 = 'Do . = . to . by .'
  RexxFor.7 = ''
  RexxFor.8 = 'End'
 
  RexxUntil.1 = 3
  RexxUntil.2 = 1
  RexxUntil.3 = 9
  RexxUntil.4 = ' DO WHEN IF THEN '
  RexxUntil.5 = ''
  RexxUntil.6 = 'Do Until ...'
  RexxUntil.7 = ''
  RexxUntil.8 = 'End'
 
  RexxWhile.1 = 3
  RexxWhile.2 = 1
  RexxWhile.3 = 9
  RexxWhile.4 = ' DO WHEN IF THEN '
  RexxWhile.5 = ''
  RexxWhile.6 = 'Do While ...'
  RexxWhile.7 = ''
  RexxWhile.8 = 'End'
 
  RexxSelec.1 = 10
  RexxSelec.2 = 2
  RexxSelec.3 = 7
  RexxSelec.4 = ' DO WHEN IF THEN '
  RexxSelec.5 = ''
  RexxSelec.6 = 'Select'
  RexxSelec.7 = '  When ... Then'
  RexxSelec.8 = '  Do'
  RexxSelec.9 = ''
  RexxSelec.10= '  End'
  RexxSelec.11= '  Otherwise'
  RexxSelec.12= '  Do'
  RexxSelec.13= ''
  RexxSelec.14= '  End'
  RexxSelec.15= 'End'
 
  RexxWhen.1 = 4
  RexxWhen.2 = 1
  RexxWhen.3 = 5
  RexxWhen.4 = ''
  RexxWhen.5 = ' END '
  RexxWhen.6 = 'When ... Then'
  RexxWhen.7 = 'Do'
  RexxWhen.8 = ''
  RexxWhen.9 = 'End'
 
  PliIf.1 = 8                            /* number of lines to insert   */
  PliIf.2 = 1                            /* line of cursor (relative)   */
  PliIf.3 = 3                            /* column of cursor (relative) */
  PliIf.4 = ' DO WHEN IF THEN '          /* words increase indentation  */
  PliIf.5 = ''                           /*words to decrease indentation*/
  PliIf.6 = 'IF ... THEN'
  PliIf.7 = 'DO;'
  PliIf.8 = ''
  PliIf.9 = 'END;'
  PliIf.10= 'ELSE'
  PliIf.11= 'DO;'
  PliIf.12= ''
  PliIf.13= 'END;'
 
  PliElse.1 = 4
  PliElse.2 = 3
  PliElse.3 = 2
  PliElse.4 = ''
  PliElse.5 = ' END '
  PliElse.6 = 'ELSE'
  PliElse.7 = 'DO;'
  PliElse.8 = ''
  PliElse.9 = 'END;'
 
  PliDo.1 = 3
  PliDo.2 = 1
  PliDo.3 = 3
  PliDo.4 = ' DO '
  PliDo.5 = ''
  PliDo.6 = 'DO;'
  PliDo.7 = ''
  PliDo.8 = 'END;'
 
  PliFor.1 = 3
  PliFor.2 = 1
  PliFor.3 = 3
  PliFor.4 = ' DO WHEN IF THEN '
  PliFor.5 = ''
  PliFor.6 = 'DO . = . TO . BY . ;'
  PliFor.7 = ''
  PliFor.8 = 'END;'
 
  PliUntil.1 = 3
  PliUntil.2 = 1
  PliUntil.3 = 11
  PliUntil.4 = ' DO WHEN IF THEN '
  PliUntil.5 = ''
  PliUntil.6 = 'DO UNTIL ( ... );'
  PliUntil.7 = ''
  PliUntil.8 = 'END;'
 
  PliWhile.1 = 3
  PliWhile.2 = 1
  PliWhile.3 = 11
  PliWhile.4 = ' DO WHEN IF THEN '
  PliWhile.5 = ''
  PliWhile.6 = 'DO WHILE ( ... );'
  PliWhile.7 = ''
  PliWhile.8 = 'END;'
 
  PliSelec.1 = 10
  PliSelec.2 = 1
  PliSelec.3 = 7
  PliSelec.4 = ' DO WHEN IF THEN '
  PliSelec.5 = ''
  PliSelec.6 = 'SELECT <( ... )> ;'
  PliSelec.7 = '  WHEN ( ... )'
  PliSelec.8 = '  DO;'
  PliSelec.9 = ''
  PliSelec.10= '  END;'
  PliSelec.11= '  OTHERWISE'
  PliSelec.12= '  DO;'
  PliSelec.13= ''
  PliSelec.14= '  END;'
  PliSelec.15= 'END;'
 
  PliWhen.1 = 4
  PliWhen.2 = 1
  PliWhen.3 = 7
  PliWhen.4 = ''
  PliWhen.5 = ' END '
  PliWhen.6 = 'WHEN ( ... )'
  PliWhen.7 = 'DO;'
  PliWhen.8 = ''
  PliWhen.9 = 'END;'
 
return
 
 
/**********************************************************************/
/* Error exits                                                        */
/**********************************************************************/
Syntax:
  If rc=0 Then rc = 'SYNTAX'
  If InterpretTest = 'Yes' Then        /* first interpret failed?     */
  Do                                   /* yes                         */
    InterpretSupported = 'No'
    InterpretTest = 'No'
    Signal ContinueAfterInterpretTest
  End
  If InPC = 'Yes' Then
  Do
    InPC = 'No'
    msg = 'PC: 'cmd2' is not an arithmetical expression'
    Signal ContinueAfterPC
  End
  If InHorComputation = 'Yes' Then
  Do
    InHorComputation = 'No'
    Say 'Line' i':' computation 'is not an arithmetical expression'
    Signal ContinueAfterComputation
  End
  If Freedataset = 'Yes' Then
    'FREE FI(ZYXEDITQ)'
  Freedataset = 'No'
  ErrorMsg='Syntax error in' ident 'on line' sigl', rc='rc '('errortext(rc)')'
  Signal HandleInternalError
 
 
 
Failure:
  If rc=0 Then rc = 'FAILURE'
  If InExecio = 'DISKR' Then
    Signal ContinueAfterDISKR
  If InExecio = 'DISKW' Then
    Signal ContinueAfterDISKW
  If InExecio = 'AUTOSAVE' Then
    Signal ContinueAfterAutosave
  If Freedataset = 'Yes' Then
    'FREE FI(ZYXEDITQ)'
  If InTSOcmd = 'Yes' Then
    Signal ContinueAfterTSO
  If InPipe = 'Yes' Then
    Signal ContinueAfterPipe
  Freedataset = 'No'
  ErrorMsg='Error condition raised on line 'sigl', rc'=rc
  Signal HandleInternalError
 
Halt:
  If rc=0 Then rc = 'HALT'
  If Freedataset = 'Yes' Then
    'FREE FI(ZYXEDITQ)'
  Freedataset = 'No'
  ErrorMsg = 'canceled on line 'sigl', parms='parms
  Signal HandleInternalError
 
 
HandleInternalError:
  say ErrorMsg
  Address ISPEXEC 'VGET (ZSYSID)'
  say 'XEDIT: Do you want to autosave all your files in the ring (Yes/No)?'
  Parse Upper Pull answer
  If ABBREV('YES',answer) Then
  Do
    Do i = 1 to NrRing
      Call GetRing i
      If xtype = 'FILE' Then
        Call AutosaveDset
    End
  End
  Else
  Do
    Do i = 1 to NrRing
      r = word(rings,i)
      If symbol('ring.r.sautosavedset') = 'VAR' & ,
         ring.r.sautosavedset ^= '' Then
        "DELETE '"ring.r.sautosavedset"'"
    End
  End
x = dropispf(load_info);Exit 16        /* return to caller            */
/* --------------------  rexx procedure  -------------------- *
 * Name:      DropISPF                                        *
 *                                                            *
 * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *
 *            that were created by the LoadISPF function.     *
 *                                                            *
 * Syntax:    rc = dropispf(load_info)                        *
 *                                                            *
 * Author:    Janko                                           *
 *                                                            *
 * History:                                                   *
 *            12/05/18 - Creation                             *
 * ---------------------------------------------------------- */
 DropISPF: Procedure
 arg load_info
 Address ISPEXEC
 do until length(load_info) = 0
    parse value load_info with dd libd load_info
    if left(libd,6) = "ALTLIB" then do
       if libd = "ALTLIBC" then lib = "CLIST"
                           else lib = "EXEC"
       Address TSO,
         "Altlib Deact Application("lib")"
       end
    else "libdef" libd
    address tso "free f("dd")"
    end
 return 0
/* --------------------  rexx procedure  -------------------- *
 * Name:      LoadISPF                                        *
 *                                                            *
 * Function:  Load ISPF elements that are inline in the       *
 *            REXX source code.                               *
 *                                                            *
 * Syntax:    rc = loadispf()                                 *
 *                                                            *
 *            The inline ISPF resources are limited to        *
 *            ISPF Messages, Panels, and Skeletons,           *
 *                 CLISTs and EXECs are also supported.       *
 *                                                            *
 *            The inline resources must start in column 1     *
 *            and use the following syntax:                   *
 *                                                            *
 *            >START    used to indicate the start of the     *
 *                      inline data                           *
 *                                                            *
 *            >END    - used to indicate the end of the       *
 *                      inline data                           *
 *                                                            *
 *            Each resource begins with a type record:        *
 *            >type name                                      *
 *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *
 *                     name is the name of the element        *
 *                                                            *
 * Sample usage:                                              *
 *          -* rexx *-                                        *
 *          load_info = loadispf()                            *
 *          ... magic code happens here (your code) ...       *
 *          Address ISPEXEC                                   *
 *          do until length(load_info) = 0                    *
 *             parse value load_info with dd libd load_info   *
 *             if left(libd,6) = "ALTLIB" then do             *
 *                if libd = "ALTLIBC" then lib = "CLIST"      *
 *                                    else lib = "EXEC"       *
 *                Address TSO,                                *
 *                  "Altlib Deact Application("lib")"         *
 *                end                                         *
 *             else "libdef" libd                             *
 *             address tso "free f("dd")"                     *
 *             end                                            *
 *          exit                                              *
 *          >Start inline elements                            *
 *          >Panel panel1                                     *
 *          ...                                               *
 *          >Msg msg1                                         *
 *          ...                                               *
 *          >End of inline elements                           *
 *                                                            *
 * Returns:   the list of ddnames allocated for use along     *
 *            with the libdef's performed or altlib           *
 *                                                            *
 *            format is ddname libdef ddname libdef ...       *
 *                   libdef may be altlibc or altlibe         *
 *                   for altlib clist or altlib exec          *
 *                                                            *
 * Notes:     Entire routine must be included with REXX       *
 *            exec - inline with the code.                    *
 *                                                            *
 * Comments:  The entire rexx program is processed from the   *
 *            last record to the first to find the >START     *
 *            record at which point all records from that     *
 *            point on are processed until the >END           *
 *            statement or the end of the program is found.   *
 *                                                            *
 *            It is *strongly* suggested that the inline      *
 *            elements be at the very end of your code so     *
 *            that the search for them is faster.             *
 *                                                            *
 *            Inline ISPTLIB or ISPLLIB were not supported    *
 *            because the values for these would have to be   *
 *            in hex.                                         *
 *                                                            *
 * Author:    Lionel B. Dyck                                  *
 *                                                            *
 * History:                                                   *
 *            01/23/19 - Use ISPTlib for ISPSlib - Janko      *
 *            05/10/16 - correction for clist and exec        *
 *            04/19/16 - bug correction                       *
 *            06/04/04 - Enhancements for speed               *
 *            08/05/02 - Creation                             *
 *                                                            *
 * ---------------------------------------------------------- *
 * Disclaimer: There is no warranty, either explicit or       *
 * implied with this code. Use it at your own risk as there   *
 * is no recourse from either the author or his employeer.    *
 * ---------------------------------------------------------- */
 LoadISPF: Procedure
 
 parse value "" with null kmsg kpanel kskel first returns ,
                     kclist kexec
/* ------------------------------------------------------- *
 * Find the InLine ISPF Elements and load them into a stem *
 * variable.                                               *
 *                                                         *
 * Elements keyword syntax:                                *
 * >START - start of inline data                           *
 * >CLIST name                                             *
 * >EXEC name                                              *
 * >MSG name                                               *
 * >PANEL name                                             *
 * >SKEL name                                              *
 * >END   - end of all inline data (optional if last)      *
 * ------------------------------------------------------- */
 last_line = sourceline()
 do i = last_line to 1 by -1
    line = sourceline(i)
    if translate(left(line,6)) = ">START " then leave
    end
 rec = 0
/* --------------------------------------------------- *
 * Flag types of ISPF resources by testing each record *
 * then add each record to the data. stem variable.    *
 * --------------------------------------------------- */
 do j = i+1 to last_line
    line = sourceline(j)
    if translate(left(line,5)) = ">END "   then leave
    if translate(left(line,7)) = ">CLIST " then kclist = 1
    if translate(left(line,6)) = ">EXEC "  then kexec  = 1
    if translate(left(line,5)) = ">MSG "   then kmsg   = 1
    if translate(left(line,7)) = ">PANEL " then kpanel = 1
    if translate(left(line,6)) = ">SKEL "  then kskel  = 1
    rec  = rec + 1
    data.rec = line
    end
 
/* ----------------------------------------------------- *
 * Now create the Library and Load the Member(s)         *
 * ----------------------------------------------------- */
 Address ISPExec
/* ----------------------------- *
 * Assign dynamic random ddnames *
 * ----------------------------- */
 clistdd = "lc"random(999)
 execdd  = "le"random(999)
 msgdd   = "lm"random(999)
 paneldd = "lp"random(999)
 skeldd  = "ls"random(999)
 
/* ---------------------------------------- *
 *  LmInit and LmOpen each resource library *
 * ---------------------------------------- */
 if kclist <> null then do
    call alloc_dd clistdd
    "Lminit dataid(clist) ddname("clistdd")"
    "LmOpen dataid("clist") Option(Output)"
    returns = strip(returns clistdd ALTLIBC)
    end
 if kexec <> null then do
    call alloc_dd execdd
    "Lminit dataid(exec) ddname("execdd")"
    "LmOpen dataid("exec") Option(Output)"
    returns = strip(returns execdd ALTLIBE)
    end
 if kmsg <> null then do
    call alloc_dd msgdd
    "Lminit dataid(msg) ddname("msgdd")"
    "LmOpen dataid("msg") Option(Output)"
    returns = strip(returns msgdd ISPMLIB)
    end
 if kpanel <> null then do
    call alloc_dd paneldd
    "Lminit dataid(panel) ddname("paneldd")"
    "LmOpen dataid("panel") Option(Output)"
    returns = strip(returns paneldd ISPPLIB)
    end
 if kskel <> null then do
    call alloc_dd skeldd
    "Lminit dataid(skel) ddname("skeldd")"
    "LmOpen dataid("skel") Option(Output)"
    returns = strip(returns skeldd ISPTLIB)      /* ISPTLIB instead */
    end
 
/* ----------------------------------------------- *
 * Process all records in the data. stem variable. *
 * ----------------------------------------------- */
 do i = 1 to rec
    record = data.i
    recordu = translate(record)
    if left(recordu,5) = ">END " then leave
    if left(recordu,7) = ">CLIST " then do
       if first = 1 then call add_it
       type = "Clist"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,6) = ">EXEC " then do
       if first = 1 then call add_it
       type = "Exec"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,5) = ">MSG " then do
       if first = 1 then call add_it
       type = "Msg"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,7) = ">PANEL " then do
       if first = 1 then call add_it
       type = "Panel"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,6) = ">SKEL " then do
       if first = 1 then call add_it
       type = "Skel"
       first = 1
       parse value record with x name
       iterate
       end
   /* --------------------------------------------*
    * Put the record into the appropriate library *
    * based on the record type.                   *
    * ------------------------------------------- */
    Select
      When type = "Clist" then
           "LmPut dataid("clist") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(255)"
      When type = "Exec" then
           "LmPut dataid("exec") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(255)"
      When type = "Msg" then
           "LmPut dataid("msg") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(80)"
      When type = "Panel" then
           "LmPut dataid("panel") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(80)"
      When type = "Skel" then
           "LmPut dataid("skel") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(80)"
      Otherwise nop
      end
    end
 if type <> null then call add_it
/* ---------------------------------------------------- *
 * Processing completed - now lmfree the allocation and *
 * Libdef the library.                                  *
 * ---------------------------------------------------- */
 if kclist <> null then do
    Address TSO,
    "Altlib Act Application(Clist) File("clistdd")"
    "LmFree dataid("clist")"
    end
 if kexec <> null then do
    Address TSO,
    "Altlib Act Application(Exec) File("execdd")"
    "LmFree dataid("exec")"
    end
 if kmsg <> null then do
    "LmFree dataid("msg")"
    "Libdef ISPMlib Library ID("msgdd") Stack"
    end
 if kpanel <> null then do
    "Libdef ISPPlib Library ID("paneldd") Stack"
    "LmFree dataid("panel")"
    end
 if kskel <> null then do
    "Libdef ISPTlib Library ID("skeldd") Stack"  /* ISPTLIB instead */
    "LmFree dataid("skel")"
    end
 return returns
 
/* --------------------------- *
 * Add the Member using LmmAdd *
 * based upon type of resource *
 * --------------------------- */
 Add_It:
 Select
    When type = "Clist" then
         "LmmAdd dataid("clist") Member("name")"
    When type = "Exec" then
         "LmmAdd dataid("exec") Member("name")"
    When type = "Msg" then
         "LmmAdd dataid("msg") Member("name")"
    When type = "Panel" then
         "LmmAdd dataid("panel") Member("name")"
    When type = "Skel" then
         "LmmAdd dataid("skel") Member("name")"
    Otherwise nop
    end
 type = null
 return
 
/* ------------------------------ *
 * ALlocate the temp ispf library *
 * ------------------------------ */
 Alloc_DD:
 arg dd
 Address TSO
 if pos(left(dd,2),"lc le") > 0 then
 "Alloc f("dd") unit(sysda) spa(15,15) dir(15)",
    "recfm(v b) lrecl(255) blksize(32760)"
 else
 "Alloc f("dd") unit(sysda) spa(15,15) dir(15)",
    "recfm(f b) lrecl(80) blksize(23440)"
 return
>START
/*
>Panel XEDIT
)PANEL KEYLIST(XEDIT,XED1)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDIT                                          **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Main pane of XEDIT: display dataset, member    **/
/**                   list and dataset list.                         **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR
+ type(text)     color(&arrowC)   just(asis) caps(off) hilite(&arrowH)
_ type(input)    color(&cmdC)     just(asis) caps(off) hilite(&cmdH)
% type(output)   color(&IDlineC)  just(asis) caps(off) hilite(&IdlineH)
^ type(output)   color(&PFkeysC)  just(asis) caps(off) hilite(&PFkeysH)
01 type(datain)  color(&fileC) just(asis) caps(off) hilite(&fileH) pad(&padC)
02 type(dataout) color(&fileC) just(asis) caps(off) hilite(&fileH) pad(&padC)
03 type(datain)  color(&prefixC)  just(asis) caps(off) hilite(&prefixH)
04 type(dataout) color(&prefixC)  just(asis) caps(off) hilite(&prefixH)
12 type(datain)  color(&prefixHC) just(asis) caps(off) hilite(&prefixHH)
05 type(dataout) color(&tofC)     just(asis) caps(off) hilite(&tofH)
06 type(datain)  color(&datasetC) just(asis) caps(off) hilite(&datasetH)
07 type(dataout) color(&datasetC) just(asis) caps(off) hilite(&datasetH)
08 type(datain)  color(&memberC)  just(asis) caps(off) hilite(&memberH)
09 type(dataout) color(&memberC)  just(asis) caps(off) hilite(&memberH)
10 type(datain)  color(&msgC)     just(asis) caps(off) hilite(&msgH)
11 type(dataout) color(&msgC)     just(asis) caps(off) hilite(&msgH)
 S  TYPE(CHAR) COLOR(&searchC) HILITE(&searchH)
 H  TYPE(CHAR) COLOR(&hexC) HILITE(&hexH)
| area(dynamic)  usermod(38)
¦ area(dynamic)  extend(on) scroll(on) usermod(38)
)BODY SMSG(header) LMSG(header) EXPAND(//) WIDTH(&ZSCREENW)
%header/ /
+====>_cmd/ /
|scale/ /                                                                      |
¦DAXEDIT,SHXEDIT / /                                                           ¦
^pfkeys/ /
)INIT
.HELP = XEDHELP
vget (cmd,cursor,csrpos,ZSCREENW)
vget (daxedit,shxedit,fileC,fileH,filen,prefixC,prefixH,prefixHC,prefixHH)
vget (hiarw,hicmd,hiidl,himem,himsg,hipfk)
.cursor = &cursor
.csrpos = &csrpos
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
&vdepth = lvline(daxedit)              /* visual depth of screen      */
vput (daxedit,vdepth,cmd,pfkey,cursor,csrpos)
)END
>Panel XEDHELP
)PANEL KEYLIST(XEDHELP,XED5)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDHELP                                        **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display HELP main menu.                        **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR
  ~ type(input) color(white) caps(off)
  ^ type(text) color(turq) caps(off)
  $ type(text) color(white) caps(off)
  ¦ area(dynamic) extend(on)
  | type(text) color(white) caps(off) hilite(reverse)
  } type(output) color(yellow) caps(off)
  ` area(scrl) extend(on)
)BODY DEFAULT(#+{) CMD() LMSG(MSG) SMSG(MSG)
|XEDIT Help Main Menu                                                          +
`HELP                                                                          `
}MSG
|F1=Topic help             PF3=End Help                                        +
)AREA HELP
+
$XEDIT+is a VM XEDIT-like editor that is able to edit datasets of any record-
+length. With$XEDIT you can even edit OpenEdition files.
$XEDIT+can be invoked from the ISPF command line with:
+  ^TSO XEDIT <dataset(member)>  +or
+  ^TSO XEDIT project.*.type
+  ^TSO XEDIT path
+or by typing a^XEDIT+before the sequential dataset in^DSLIST+(=3.4)
+or by typing a^XEDIT+before the member "member list" (option^m+of DSLIST).
+
+Put your cursor on one of the following topics, and press F1.
+
+ ~OPTION1
+ ~OPTION2
+ ~OPTION3
+ ~OPTION4
+ ~OPTION5
+ ~OPTION6
+
+If you have any problems/questions/requests about$XEDIT+please address them to:
+  George van der Klauw
+  Telephone : (31) (0)20-5138336
+  E-Mail    : george_klauw@nl.ibm.com
+
)INIT
&OPTION1 = 'General information'
&OPTION2 = 'Commands'
&OPTION3 = 'Prefix commands'
&OPTION4 = 'Horizontal editing commands'
&OPTION5 = 'PF-keys'
&OPTION6 = 'Xedit news'
)PROC
)HELP
FIELD(OPTION1 ) PANEL(XEDHELP1)
FIELD(OPTION2 ) PANEL(XEDHELP2)
FIELD(OPTION3 ) PANEL(XEDHELP3)
FIELD(OPTION4 ) PANEL(XEDHELP4)
FIELD(OPTION5 ) PANEL(XEDHELP5)
FIELD(OPTION6 ) PANEL(XEDHELP6)
)END
>Panel XEDHELP1
)PANEL KEYLIST(XEDHELP1,XED6)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDHELP1                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display general XEDIT help.                    **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR
  ç type(text) color(white)
  | type(text) color(green)
  @ type(text) color(turq)
  ^ type(text) color(red)    hilite(reverse)
  ¬ type(text) color(red)
  $ type(text) color(yellow)
  { type(text) color(turq)   hilite(reverse)
  ! type(text) color(yellow) hilite(reverse)
  # type(text) color(yellow)
  ` area(scrl) extend(on)
  ~ type(text) color(white) caps(off) hilite(reverse)
  } type(output) color(yellow) caps(off)
)BODY DEFAULT(¢¦?) CMD() LMSG(MSG) SMSG(MSG)
~XEDIT Help General Information                                                ¢
`HELP                                                                          `
}MSG
~PF3=Help main menu                 PF7=Backward          PF8=Forward
)AREA HELP
ç                                                                              ¦
¢XEDIT¦is a very user-friendly, VM XEDIT-like editor that allows you to edit
¦almost any dataset you would like to edit (including VSAM datasets and
¦OpenEdition/Unix files and directories). XEDIT comprises of an¢EDIT-screen,¦a
¢DIRECTORY-screen, DATASETS-screen¦and a¢'OpenEdition Directory'-screen.¦
¦The¢EDIT-screen¦layout is as follows:
¦
{2:PROJECT.GROUP.TYPE(MEMBER)                       FB 80 Size=46 Alt=12 UKMVSXX
!====>çcommand area
#     $<...+....1....+....2....+....3....+....4....+....5....+....6....+....7...
@    1|This is the first line of the member 'MEMBER' of the PDS named
@    2|'PROJECT.GROUP.TYPE'.
@     |
@  ...|       ...
@     |
@   20|This is the twentieth line of this dataset.
^1=Help 2=Repeat 3=Quit 4=BOL 5=SplJo 6=EOL 7=Up 8=Down 9=Top 10=<- 11=-> 12=Bot
¦
¦The first line of the screen contain dataset information such as: ring number,
¦name, record format and length, size, and the number of alterations made.
¦The second line is the command area. The third line is the message area and
¦displays a scale. When a scale is displayed, it can be overtyped with¢horizon-
¢tal editing¦commands.
¦The prefix area consists of columns 1 to 5 starting at line 4. The bottom-line
¦displays the usage of PFkeys 1 to 12. PFkey settings and the text displayed in
¦the bottom-line can be customized.
¦Highlighting is done for search strings (by default in~white reverse¦) and
¦non-displayable hexadecimal data (by default in¬red¦).
¦
¦The¢DIRECTORY-screen¦is similar to the EDIT-screen, it's  layout is as follows:
¦
{2:PROJECT.GROUP.TYPE                         FB 80 Member 1 to 21 of 21 UKMVSXX
!====>çcommand area
$Member    Member    Member    Member    Member    Member    Member    Member
@MEMBER1   OTHERMEM
@MEMBER2
@MEMBER3
@  ...       ...
@MEMBER19
@MEMBER20
^1=Help 2=Rep 3=Quit 4=Del 5=Refresh 6=Ren 7=Up 8=Down 9=Top 10=St 11=Xed 12=Bot
¦
¦The first line of the screen contain dataset information such as: ring number,
¦name, record format and length, and the number of members in the PDS.
¦The second line is the command area. The third line is the message area.
¦The last line displays the usage of PFkeys 1 to 12.
¦If you are interested in the statistics of members, you can use the command
@STatistics on¦to display it as follows:
¦
{2:PROJECT.GROUP.TYPE                         FB 80 Member 1 to 21 of 21 UKMVSXX
!====>çcommand area
$Member   AliasOf Lib VV.MM    Created   Modified  Time    Size    Init     User
@MEMBER1            1 01.95 1998/01/15 1998/04/23 10:32      43      16  GEORGE
@MEMBER2            1 01.74 1998/03/27 1998/05/29 15:32       9       9  GEORGE
@MEMBER3            1 01.26 1999/12/02 1999/12/02 10:07      47      47  GEORGE
@  ...                .   .      .         .        .         .       .  .
@MEMBER19           1 01.70 1994/07/25 1998/04/23 10:31       7       7  MARIE
@MEMBER20           1 01.53 1997/12/11 1998/01/15 07:28      11      11  JILL
^1=Help 2=Rep 3=Quit 4=Del 5=Refresh 6=Ren 7=Up 8=Down 9=Top 10=St 11=Xed 12=Bot
¦
¦The member names can be overtyped with a command. For example overtyping
¦MEMBER1 with@XMIT YOURVM.USER1 DA(/) SEQUENTIAL¦is equivalent to
@XMIT YOURVM.USER1 DA('PROJECT.GROUP.TYPE(MEMBER1)') SEQUENTIAL¦¦on the command
¦line.@=¦can be used to repeat the previous command.
¦
¦The¢DATASETS-screen¦is similar to the DIRECTORY-screen, it's  layout is as
¦follows:
¦
{2:PROJECT.*.TYPE                                  Dataset 1 to 21 of 21 UKMVSXX
!====>çcommand area
$Dataset                                      Org  Fm Lrecl Tracks %Us XT Volume
@PROJECT.DSET1.TYPE                           PO   VB   256     60   6  1 SDVL17
@PROJECT.DSET2.TYPE                           PO   U      0      2 100  1 SDVL17
@PROJECT.YOURDSET.TYPE                        PO   FB    80      2 100  1 SDVL17
@  ...                                        .    .      .      .   .  . .
@PROJECT.Z.TYPE                               PO   FB    80     21 100  1 MIGRAT
@PROJECT.ZZZZ.TYPE                            PO   FB    80     15  33  1 SDVL23
^1=Help 2=Rep 3=Quit 4=Del 5=Refresh 6=Ren 7=Up 8=Down 9=Top 10=-> 11=Xed 12=Bot
¦
¦The first line of the screen contain dataset information such as: ring number,
¦name, and the number of datasets displayed.
¦The second line is the command area. The third line is the message area.
¦The last line displays the usage of PFkeys 1 to 12.
¦The dataset names can be overtyped with a command. For example overtyping
¦PROJECT.DSET1.TYPE with@ex /¦(or@ex¦) is equivalent to@ex 'PROJECT.DSET.TYPE'
¦the command line.@=¦can be used to repeat the previous command.
¦
¦The¢'OpenEdition Directory'-screen¦is similar to the DATASETS-screen, it's
¦layout is as follows:
¦
{2:/u/oedfltu                                         File 1 to 28 of 28 UKMVSXX
!====>çcommand area
$DUsrGrpOth Lnk Owner    Group        Size Modified       File
@-rw-------   1 OEDFLTU  OEDFLTG      1705 20040304104757 .sh_history
@-rwxr-xr-x   1 OEDFLTU  OEDFLTG      4096 20030108164502 a.out
@drwx------   2 OEDFLTU  OEDFLTG         0 20031027130136 testdir
@  ...        .   ...      ...         ...      ...       ...
@-rw-r--r--   1 OEDFLTU  OEDFLTG       547 20031003140427 idare.envvars
@-rwx------   1 OEDFLTU  OEDFLTG    175956 20040220144508 idare.jar
^1=Help 2=Rep 3=Quit 4=Del 5=Refresh 6=Ren 7=Up 8=Down 9=Top 10=-> 11=Xed 12=Bot
¦
¦The first line of the screen contain file information such as: ring number,
¦path, and the number of files displayed.
¦The second line is the command area. The third line is the message area.
¦The last line displays the usage of PFkeys 1 to 12.
¦The file names can be overtyped with a command. For example overtyping
¦a.out with@b¦is equivalent to@b a.out¦the command line.
@=¦can be used to repeat the previous command.
 
¦All Commands in¢XEDIT¦can be abbreviated to the least significant part of the
¦command. It is sufficient to type@A 1¦for@ADD 1¦to add a line, and it is
¦sufficient to type@AU ON 20¦for@AUTOSAVE ON 20¦to save your updates automa-
¦tically if you have made 20 or more alterations.
¦
¦In¢XEDIT¦a dataset may be partially specified. This means that if you are
¦for example editing the member@JOHN¦of the PDS@MARIE.TSO.CLIST¦and you want
¦to edit the member@GEORGE¦you just enter the command:
@       X GEORGE
¦If wanted to edit the member@JILL¦in the dataset@MARIE.TSO.JCL¦use:
@       X ..JCL(JILL)
¦If wanted to edit the member@JOHN¦in the dataset@MARIE.TSO.JCL¦use:
@       X ..JCL()
¦If wanted to list all members in the dataset@MARIE.TSO.CLIST¦use:
@       X ..CLIST
¦If wanted to list all dataset that match @MARIE.*.CLIST¦use:
@       X .*.CLIST
¦
¦In¢XEDIT¦an OpenEdition file or directory may be partially specified and ONE
¦wildcard (*) can be used. This means that if you are editing a file
@/u/john/test.c¦and you want to edit@/u/marie/test.c¦you can enter one of the
¦following commands:
@       X //marie/           or
@       X ../marie/test.c    or
@       X /u/marie/test.c    or
¦In OpenEdition file and directory name can be very long and are case-sensitive.
¦In¢XEDIT¦it is sufficient to specify only a significant part of the file or
¦directory. For example, if you want to edit a file like:
@       /u/marie/ThisIsAVeryLongNameDirectory/AndAVeryLongNameFile
¦It is sufficient to enter the following command:
@       X /u/marie/thisis/anda*
¦
¦
¢XEDIT¦also allows you to edit in HEX (use the command HEX ON or just H).
¦Strings can also be specified in HEX. For instance the search command:
@       /x'f1f2f3f4'
¦searches for the first occurrence of the string "1234". And the change command:
@       c/x'f1f2f3f4'/x'81828384'/ * *
¦changes all occurrences of "1234" into "abcd".
¦
¢XEDIT¦can also be tailored to your person preference (e.g. set the prefix area
¦on the right of your screen:@PREfix Rigth¦or@STatistics ON¦). Commands like
¦this can be stored in your¢XEDIT¦profile in the sequential dataset
@&ZUSER..XEDIT.PROFILE.
¦
)INIT
)PROC
)END
>Panel XEDHELP2
)PANEL KEYLIST(XEDHELP1,XED6)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDHELP2                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display help for line commands.                **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR
  ¢ type(text) color(turq) caps(off)
  ! type(text) color(white) caps(off)
  ` area(scrl) extend(on)
  ~ type(text) color(white) caps(off) hilite(reverse)
  } type(output) color(yellow) caps(off)
)BODY DEFAULT({+_) CMD() LMSG(MSG) SMSG(MSG)
~XEDIT Help for Commands                                                       +
`HELP                                                                          `
}MSG
~PF3=Help main menu                 PF7=Backward          PF8=Forward
)AREA HELP
+In!XEDIT+commands you can use variables that are replace by XEDIT. Variable-
+replacement can be turned on and off via the command¢XVar <On|OFf>.
¢/        !-+Is replaced by the current dataset (and member if applicable)
            +This is not done for search commands like:¢/+,¢^/+,¢\+,¢^\+,
            ¢LOCATE+,¢DELETELINES+,¢CHANGE+,¢PC+,¢XPIPE+and all horizontal
            +editing command.
¢%        !-+Is replaced by the current file (OpenEdition)
¢&DS      !-+Is replaced by the current dataset name (and member if applicable)
            +without quotes
¢&DATAS   !-+Is replaced by the current dataset name
¢&G       !-+Is replaced by the current group qualifier
¢&P       !-+Is replaced by the current project qualifier
¢&T       !-+Is replaced by the current type qualifier
¢&M       !-+Is replaced by the current member name
¢&MP      !-+Is replaced by the current member name, but the last character of
            +the member name is changed into a 'P'
+Note: this can be extremely usefull when defining synonyms and XEXECs.
+
+The XEDIT commands are:
¢nnn                !-+Go¢nnn+lines down
¢-nnn               !-+Go¢nnn+lines up
¢¦nnn               !-+Go to line¢nnn
¢.xxx               !-+Go to the line tagged with bookmark¢xxx
¢?                  !-+Recall previous commands in a pop-up window
¢/xxx               !-+Search forwards for string¢xxx
                      +If no string¢xxx+is specified the search is performed on
                      +the word pointed to by the cursor.
                      +See also the¢ARbchar+command.
¢^/xxx              !-+Search forwards for a line not containing string¢xxx
                      +If no string¢xxx+is specified the search is performed on
                      +the word pointed to by the cursor.
                      +See also the¢ARbchar+command.
¢\xxx               !-+Search backwards for string¢xxx
                      +If no string¢xxx+is specified the search is performed on
                      +the word pointed to by the cursor.
                      +See also the¢ARbchar+command.
¢^\xxx              !-+Search backwards for a line not containing string¢xxx
                      +If no string¢xxx+is specified the search is performed on
                      +the word pointed to by the cursor.
                      +See also the¢ARbchar+command.
¢=                  !-+Repeat the last entered command
¢Add <nnn>          !-+Add¢nnn+lines after the current line
¢ALLOcate           !-+Go to the allocate dataset panel (ISPF option 3.2)
¢ALLOCNew <dset>    !-+Allocate a new dataset with properties of the currently
                      +edited dataset.
¢ARbchar <OFF|ON <c>>
                    !-+Define arbitrary character for search commands like:¢/+,
                      ¢^/+,¢\+,¢^\+,¢LOCATE+,¢DELETELINES+and¢CHANGE+)
                      +Default: ARBCHAR ON $
                      +This allows you to do commands like:
                      ¢  c/the $ sheep/all $ dogs/ *
                      +which will change!the black sheep+into!all black dogs+,
                      +but also!the white sheep+into!all white dogs+.
                      +The command¢c/end$/end/ *+will delete all characters
                      +after the word!end+.
¢AUTHorization <dset>
                    !-+Check your authorization for the dataset¢dset
¢AUtosave <On|OFf> nnn
                    !-+Automatically save the dataset after¢nnn+alterations
¢BOL                !-+Move the cursor to the Begin Of the Line.
¢                     +If the cursor is already at the Begin Of the Line, the
                      +cursor is moved to the Begin Of the Line of the next line
¢BOOkmarks          !-+Display all bookmarks (tags) in the current dataset
¢BOTtom             !-+Go to the bottom of the dataset
¢BRAll              !-+Browse all datasets in the dataset-list or all members in
                      +the directory-list
¢Browse <dset>      !-+Browse the specified dataset (ISPF BROWSE)
¢BYtes              !-+Display the size of the dataset in bytes
¢CAse <Mixed|Lower|Upper> <Respect|Ignore>
                    !-+Control how letters are translated in commands and text
¢Change/xxx/yyy/ <nnn> <mmm>
                    !-+Change¢mmm+occurrences of string¢xxx+into string
                      ¢yyy+on¢nnn+lines starting from the current line.
                      ¢The default value for¢nnn+and¢mmm+is 1.
                      +Instead of a number you can also specify a bookmark (see
                      ¢.xxx+) for¢nnn+.
                      +Instead of¢/+you can also use¢&CLETTER   +or¢%.
                      +See also the¢ARbchar+and¢REPeat+commands.
¢CHEckpli           !-+Check for PL/1 comment/quote balancing or margin errors
¢CHMod path mode    !-+Change the mode of the OpenEdition file or directory.
                      +The mode must be specified as three octalDigits.
                      +If you do not specify a mode a popup is displayed.
¢
!Note+that the horizontal edition commands below (COL* except COLOR and COLUMN
+work on the horizontal range set by the command HORIZONTAL and/or the prefix
+commands H and HH.
¢COLAdd col count <string>
                    !-+Add or delete characters after the specified column in
                      +the dataset.
                      +Try: "COLA 5 9 blah blah" and "COLA 5 -9" to undo it.
¢COLBlank from count!-+Blank out¢count+columns starting from¢from
¢COLCopy from count after
                    !-+Copy¢count+columns starting from¢from+after¢after
¢COLCAscade from count
                    !-+Cascade the¢count+characters in the columns starting from
                      ¢from+over the next line if a character is blank.
¢COLEmulate start string
                    !-+Place¢string+in all lines starting with column¢start
¢COLJustify <Left|Right> <space> <from> <to>
                    !-+Justify all lines in the columns¢from+to¢to+to the left
                    !-+or right leaving maximal¢space+blanks
¢COLLower from count!-+Translate columns lower case starting¢from+for¢count
¢COLMove from count after
                    !-+Move¢count+columns starting from¢from+after¢after
¢COLNum from count <startnum>
                    !-+Set a number of¢count+digits after column¢from±if column
                      +is blank
¢COLNUMBer from count <startnum>
                    !-+Set a number of¢count+digits after column¢from+(overwrite
                      +nonblank data)
¢COLSum from count  !-+Add up all number in the columns starting¢from+for¢count
¢COLOr area color hi!-+Change the color of the panel area to the specified color
                      ¢area !=+Arrow   !-+====> on second screen-line
                              +Cmdline !-+after ====> on second screen-line
                              +Datasets!-+when in a dataset-list
                              +Filearea!-+contents of the data set
                              +Idline  !-+first screen-line
                              +Members !-+when in a PDS member-list
                              +Nondisp !-+non-displayable contents of data set
                              +MSgline !-+third screen-line if message displayed
                              +Prefix  !-+containing line-numbers (horizontal
                                         +editing NOT active on that line)
                              +PREFIXH !-+containing line-numbers (horizontal
                                         +editing IS active on that line)
                              +PFkeys  !-+last screen-line
                              +Scale   !-+third screen-line if no msg displayed
                              +SEarch  !-+found search string in filearea
                              +Tofeof  !-+top- and end-of-file line
                      ¢color!=+Blue, Green, Pink, Red, Turquoise, White, Yellow
                      ¢hi   !=+Blink, Reverse, Uscore
¢COLOVerlay after string
                    !-+Replace blanks with¢string+in all lines starting in
                      +column¢start
¢COLUmn nnn         !-+Display column¢nnn+as the first column
¢COLUPper from count!-+Translate columns upper case starting ta¢from+for ¢count
¢COLWordflow from ct!-+Place all words in¢ct+columns starting at¢from
¢COMment <nnn>      !-+Put¢nnn+lines in comments (/* and */) or Remove comments
¢COMPress <dset>    !-+Compress the partitioned dataset¢dset
                      +If¢dset+is omitted the current dataset is compressed
¢COPy               !-+Move/Copy Utility (ISPF option 3.3)
¢CUtpaste           !-+Cut and paste text pointed to by the cursor
¢CUTSquare          !-+Cut a square piece of text pointed to by the cursor
¢Down <nnn|Csr>     !-+Go¢nnn+lines down or depending on the cursor position
¢Dataset dset       !-+Change the name of the dataset being edited
¢DElete <nnn>       !-+Delete¢nnn+lines starting with the current line
¢DELETEDuplicate <col1> <col2>
                    !-+Delete all duplicate lines in columns¢col1+to¢col2
                      +starting with the current line
¢DELETEUnique <col1> <col2>
                    !-+Delete all unique lines in columns¢col1+to¢col2
                      +starting with the current line
¢DELETELines <^>/string</>
                    !-+Delete all lines starting with the current line that
                      +do (or do not) contain the specified string (specify one
                      +blank to select blank lines).
¢DELETEDuplicates   !-+Delete all duplicate lines starting with the current line
¢DUplicate          !-+Find the next duplicate line after the current line
¢DRing              !-+Display all datasets in the XEDIT-ring in a popup-window
¢DTags              !-+Display all tags (bookmarks) in the current dataset
¢Edit <dset>        !-+Edit the specified dataset (ISPF EDIT)
¢EDITAll            !-+Edit all datasets in the dataset-list or all members in
                      +the directory-list
¢EOL                !-+Move the cursor to the End Of the Line.
¢                     +If the cursor is already at the End Of the Line, the
                      +cursor is moved to the End Of the Line of the next line
¢EXec <dset>        !-+Execute the specified clist (default is current dataset)
¢DIrectory          !-+Display the directory of the current PDS
¢FIEld grp <field pos len>
                    !-+You can use this command to easily look at the fields
                      +in a record. You first have to define the fields e.g.
                      ¢  FIELD address name     1 50
                      ¢  FIELD address Town    51 60
                      ¢  FIELD address street 111 80
                      +Then you edit the dataset with the data and you can
                      +active the fields by:
                      ¢  FIELD address
                      +You can then use the¢FLD+prefix command to edit the
                      +fields in the selected record.
¢File <dset|path>   !-+Store the file in the dataset¢dset+or file¢path+and exit
¢File <nnn>         !-+Perform¢nnn!File+commands
¢FINdduplicate <col1> <col2>
                    !-+Go to next line that is equal to the next line in colums
                      ¢col1+to¢col2
¢FINDUnique <col1> <col2>
                    !-+Go to next line that is NOT equal to the next line in
                      +columns¢col1+to¢col2
¢FRing              !-+Save all dataset in the XEDIT-ring and exit
¢FPRevious          !-+File current dataset and go to the previously edited file
¢Get <dset>         !-+If¢dset+is omitted copy the "Clip-board" after the
                      +current line, otherwise copy the specified¢dset+after the
                      +current line
¢Group xxx          !-+Change the group-qualifier to¢xxx
¢Hex <On|OFf>       !-+Display lines also in HEX
¢HELp               !-+Display help for XEDIT (type HEL in stead of HELP)
¢HOrizontal <On|OFf> <nnn <mmm|*> >
                    !-+Enable/disable horizontal editing and set the horizontal
                      +editing range on the lines^nnn+to^mmm
¢Info <dataset>     !-+Display allocation information for the dataset
¢INSert nnn         !-+Add¢nnn+lines before the current line
¢IShell <path>      !-+Invoke the OpenEdition ISPF shell with the spedified path
¢INPut string       !-+Add one line and fill it with¢string
¢ICprint <dataset>  !-+Print the dataset
¢ISpf               !-+Go to the ISPF main menu (press F3 to return to XEDIT)
¢LAnguage <Rexx|Pl1|PLI|CObol>
                    !-+Set language of prefix commands IF, ELSE, WHILE, SELECT..
¢Lef <nnn|Csr>      !-+Move¢nnn+columns to the left or depending on cursor pos.
                      +(LEFT full out doesn't work)
¢LIbrary            !-+Library Utility (ISPF option 3.1)
¢LISt <dset>        !-+Display a dataset list that match the^dset+pattern (3.4)
¢LISTAlc            !-+Insert line that list the current dataset allocation
¢LOcate <^></|\>string
                    !-+Search forward or backward for a line containing¢string
                      +(or NOT containing¢string+)
                      +If no string¢xxx+is specified the search is performed on
                      +the word pointed to by the cursor.
                      +See also the¢ARbchar+command.
¢LOWercase <nnn|*>  !-+Translate the next^nnn+lines to lower case, but not the
                      +comments
¢LOWERWord          !-+Translate the word pointed to by the cursor to lower case
¢LOCk               !-+Take an LMF lock on the current member
¢LRecl nnn          !-+Set the record length to¢nnn+(NOTE the record length of
                      +the dataset is not changed!)
¢Maxline            !-+Display which line is the longest line
¢MInline            !-+Display which line is the shortest line
¢MEmber xxx         !-+Change the member-name to¢xxx
¢MSg xxx            !-+Display the text¢xxx+on the message line
¢Nondisp            !-+Search for the next non-displayable character
¢NUlls <On|OFf>     !-+Pad lines with X'00' (nulls on) or X'40' (nulls off)
¢Pastesquare        !-+Paste the text just 'Cutsquared' at the cursor position
¢PFkey PFnn cmd     !-+Set the XEDIT PFkey¢PFnn+to command¢cmd
¢PFKEYLine text     !-+Set the XEDIT PFkey-line (on the bottom) to¢text
¢PGm path <parms>   !-+run the OpenEdition program specified in¢path+with¢parms
¢PRefix <Left|Right>!-+Set the prefix area on the left or right of the screen
¢PREFIXCmd <nnn> cmd!-+Set prefix command¢cmd+on line¢nnn+(default current line)
¢PROject xxx        !-+Change the project-qualifier to¢xxx
¢PC <expression>    !-+Personal calculator. Try 'PC ?' or 'PC 123*33-86'
¢PUt <nnn|*>        !-+Store¢nnn+lines into the "Clip-board"
¢PUTAdd <nnn|*>     !-+Append¢nnn+lines to the "Clip-board"
¢QUEry <Alt|ARbchar|AUtosave|Case|Language|Nulls|Pfkeys|Ring|Synonyms|TABs|
¢       TAGChange|TAGS|*>
                    !-+Display the current XEDIT settings (default is RING)
¢Quit               !-+End editing this dataset if no changes made
¢Quit <nnn>         !-+Perform¢nnn+Quit commands
¢QPRevious          !-+Quit current dataset and go to the previously edited file
¢QQuit              !-+End editing this dataset regardless of any changes made
¢QQuit <nnn>        !-+Perform¢nnn+QQuit commands
¢QQPRevious         !-+QQuit current dataset and go to the previous edited file.
¢QRing              !-+End editing all datasets if no changes made
¢QQRing             !-+End editing all datasets regardless of any changes made
¢Recall             !-+Recall previous commands in a pop-up window
¢REPeat Change|Locate
                    !-+Repeat the last¢CHANGE-command+or locate the next change.
                      +Analog to the ISPF RCHANGE and RFIND commands.
¢RESet              !-+Reset all prefix commands
¢RIgh <nnn|Csr>     !-+Go¢nnn+columns to the right or depending on cursor pos.
                      +(RIGHT full out does not work)
¢Save <dset|path>   !-+Store the file in the dataset¢dset+or file¢path
¢SCale <text>       !-+Display¢<text>+on the scale line (line 3 on the panel).
                      +If¢<text>+is in the format¢/string/+the string is
                      +repeated as many time as possible.
                      +For example try: &SCALE
                      +If¢<text>+is omitted the standard scale is displayed.
                      +Can be handy when the file has fixed columns of data.
¢SDsf <DA|O|H|LOG>  !-+Go to SDSF
¢SEarch             !-+Go to the search-For Utility (ISPF option 3.14)
¢SEARCHWord         !-+Search for the next occurrence of the word pointed to by
                      +the cursor.
¢SHell path         !-+run the OpenEdition shell command specified in¢path
¢SOrt <A|D> <col1 <col2>>
                    !-+Sort the whole dataset in Ascending or Descending order
                      +on the columns¢col1+to¢col2
                      +In directory, dataset-list or OpenEdition directory
                      +screens¢col1+can be the title of a column displayed (e.g.
                      +Created, Size or User)
¢SPlitjoin          !-+Join or split the line at the cursor position
¢SRing              !-+Save all datasets in the XEDIT-ring
¢SSid <DB2sys>      !-+Set the DB2 subsystem-ID for the¢SQL+prefix area command
¢STatistics <On|OFf>!-+Display member statistics (On) or give overview of all
                      +members in a PDS (Off)
¢SUbmit <dset>      !-+Submit the specified dataset (default is current dataset)
¢SUPerc             !-+Go to SuperC Compare Utility (ISPF option 3.12)
¢SYn name n cmd     !-+Define¢name+as a synonym for the command¢cmd.+At least¢n
                      +characters of¢name+must be specified. In¢cmd+:
                      ¢/        +- is replaced by the current dataset and member
                      ¢&D       +- is replaced by the current dataset name
                      ¢&G       +- is replaced by the current group name
                      ¢&P       +- is replaced by the current project name
                      ¢&T       +- is replaced by the current type name
                      ¢&M       +- is replaced by the current member name
                      +Note: this can be extremely usefull when using¢XEXEC
                      +Try: syn blah 4 c|aa|&M | * *     ¢<ENTER>
                      +     blah                         ¢<ENTER>
¢Tab                !-+Go to the next tab
¢TABS n1 <n2 ... nx>!-+Define column numbers for tab settings
¢TABLine <On|OFf>   !-+Display the tabs on the scale with a "T" for every tab
¢TAGchange <On|OFf> string from to <Ifblank|Always>
                    !-+Place the specified¢string+in position¢from+to¢to+in
                      +every line if a change is made in that line.
                      +If the¢Ifblank+option is selected the¢string+is only
                      +inserted if position¢from+to¢to+is blank.  I
                      +If the¢Always+option is selected this is done even if
                      +position¢from+to¢to+is not blank.
                      !Note:+if the¢string+starts with!/*+and ends with!*/+it is
                      +      "comment sensitive", i.e. if position¢from+to¢to+is
                      +      in a comment the!/*+and!*/+are left out.
                      +      See also the¢t+and¢tt+prefix commands (to intentio-
                      +      nally tag a line even is TAGCHANGE is OFF).
                      +      Underscores in the ¢string+are replace by blanks.
                      +Default: TAGCHANGE OFF /*&CHANGE.*/ 61 72 IFBLANK
¢TO                 !-+Search for the procedure called (identified by the word
                      +after CALL or PERFROM) or the chapter in the table of
                      +contents on the next line. The tag ".from" is set on the
                      +line selected line, so you can easily return to the
                      +"calling" of the procedure, section or TOC.
¢TOP                !-+Go to the top of the dataset
¢TSo cmd            !-+Execute TSO command¢cmd
                      !Note:+if you want to use dataset-name substitution (re-
                      +      place¢/+in the¢cmd+by the current dataset-name)
                      +      use the abbreviation¢TS+instead of¢TSO+.
¢TRap cmd           !-+Trap the output of TSO command¢cmd+and add them after
                      +the current line (try for instance TRAP HELP ALLOCATE)
¢TYpe xxx           !-+Change the type-qualifier to¢xxx
¢Up <nnn|Csr>       !-+Go¢nnn+lines up or depending on the cursor position
¢UPPercase <nnn|*>  !-+Translate the next^nnn+lines to upper case, but not the
                      +comments
¢UPPERWord          !-+Translate the word pointed to by the cursor to upper case
¢Variable <struct>  !-+You can use this command to easily look at the variables
                      +in a record as defined by in PL/1 or COBOL program.
                      +You should use this command while editing the source of
                      +a program (PL/1 or COBOL). You must have defined a
                      +synonym for the compile-listing e.g:
                      ¢  syn COMPLIST  5 x ..LISTING(
                      +That will be scanned to locate and parse the structure
                      ¢struct+to determine the fields in the structure.
                      +Then go to the dataset with the record you want to
                      +analyze and type¢Variable struct+again. This will
                      +activate the variables and set the scale accordingly.
                      +You can then use the¢var+prefix command to look at the
                      +variables in the selected record.
¢VARPosition <strct>!-+Display the variables and the position and lengths.
                      +See also¢Variable <struct>
¢Right nnn          !-+Move¢nnn+columns to the right (default 40)
¢Xedit < dset|path|<-|&PL><nnn> >
                    !-+Edit the specified dataset.
                      ¢Xedit dset!:+Edit dataset¢dset
                                   +NOTE that¢dset+can also be a VSAM dataset.
                                   +NOTE that¢dset+can also be a GDG, e.g.:
                                   ¢x hlq.blah.gdg(0)+ or¢ x hlq.blah.gdg(-4)
                      ¢Xedit path!:+Edit OpenEdition file or directory¢path
                                   +To edit an MVS dataset next, you have to
                                   +prefix the dataset with a quote (').
                      ¢Xedit nnn !:+Edit the nnn-th dataset in the XEDIT-ring
                      ¢Xedit &PN !:+Edit the "current plus nnn"-th dataset in
                                   +the XEDIT-ring
                      ¢Xedit -nnn!:+Edit the "current minus nnn"-th dataset in
                                   +the XEDIT-ring
                      ¢Xedit -   !:+Edit the previous dataset in the XEDIT-ring
                      ¢Xedit &PL !:+Edit the next dataset in the XEDIT-ring
                      ¢Xedit     !:+Edit the next dataset in the XEDIT-ring
¢XEXex <dset>       !-+Treat all lines in the dataset¢dset+as XEDIT commands
                      +Note: commands are translated (like in¢synonym+)
¢XFind member <DDname>
                    !-+Edit a member in the currently allocated libraries.
                      +If a DDname is omitted all allocated libraries are
                      +searched for the specified member.
¢XList <member>     !-+Edit a member in a list of libraries.
                      +If a member is omitted or does not exist a pop with the
                      +list of libraries is displayed (so you can update it).
¢XLMf project.group.type<(member)>
                      +Depending on the¢group+it is equivalent to the command:
                      +XXEDIT !XXEDIT project.&ZUSER..type(member)¢groups
                      +Where¢groups+is defined as:
                      !group    groups
                      !=======  ========================
                      ¢DEVELOP  DEVELOP  SYSTEM  SHIPPED
                      ¢DEV      DEV      SYS     REL
                      ¢other    group'D' group'S' group'B'
¢XPIPE pipecommand  !-+Execute the specified PIPE-command.
                      !Note+that the stem¢line.+contains the contents of the
                      +file being edited.
                      +For example the command:
                      ¢  xpipe stem line. | snake 4 | stem line.
                      +Puts the contents of the file in 4 columns.
¢XPrevious          !-+Go to the previously edited file in the ring.
¢XVar <On|OFf|Set var = value>
                    !-+Turn variable translation on or off (see also at the top
                      +of this scrollable panel).
                      +With the¢Set+option you can define variables that then
                      +can be used in Xedit commands.
                      +This can be extremely handy with the¢z+prefix command.
                      +If you have for example in a JCL:
                      ¢  //       &XVARDSN
                      +and you have defined the following in you .XEDIT.PROFILE
                      ¢  &XVARPROJ
                      ¢  &XVARLVL
                      +Then if you specify the prefix command¢z+on that JCL line
                      +the command¢XEDIT PROJA.DEV.UTIL(MEM)+is executed
¢XXedit <project.group1.type<(member)> <group2> <group3> <group4> >
                      +Edit the specified¢member+in¢project.group1..type+or in
                      ¢project.group2.type+or in¢project.group3.type+or in
                      ¢project.group4.type+(wherever it is found first)
                      +If no member is specified a combined directory list is
                      +displayed. If no dataset is specified a pop-up is shown.
)INIT
&DS = '&&DSET'
&DATAS = '&&DATASET'
&M = '&&MEMBER'
&MP = '&&MEMBERP'
&G = '&&GROUP'
&T = '&&TYPE'
&P = '&&PROJECT'
&SCALE = 'Scale /    +    |/'
&CLETTER = '@ # ¢ \ ¦ |'
&CHANGE = '_CHANGE_'
&PL = '+'
&PN = '+nnn'
&XVARDSN  = 'DSN=&&HLQ..&&LVL.UTIL(MEM),'
&XVARPROJ = 'XVAR SET &&HLQ. = PROJA'
&XVARLVL  = 'XVAR SET &&LVL. = DEV'
)PROC
)END
>Panel XEDHELP3
)PANEL KEYLIST(XEDHELP1,XED6)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDHELP3                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display help for prefix commands.              **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR
  ^ type(text) color(turq) caps(off)
  ` area(scrl) extend(on)
  ~ type(text) color(white) caps(off) hilite(reverse)
  } type(output) color(yellow) caps(off)
)BODY CMD() LMSG(MSG) SMSG(MSG)
~XEDIT Help for Prefix Commands                                                %
`HELP                                                                          `
}MSG
~PF3=Help main menu                 PF7=Backward          PF8=Forward
)AREA HELP
+The XEDIT prefix-commands are:
%NOTE that the^nnn%and^mmm%in the commands below are optional. When the command
does not have an^mmm%the^nnn%may also may be specified before the command.
^/        %-+Make the specified line the current line (first line displayed)
^\        %-+Make the specified line the last line displayed
^=        %-+Repeat the previous prefix command
^&MIN.    %-+Put line(s) in SQL comments (starting with &MM.) or Remove comments
^&MM.     %-+Block-put or remove SQL comments
^.xxx     %-+Tag this line with the bookmark^xxx
^nnn)mmm  %-+Shift^nnn+lines^mmm+position to the right
^nnn))    %-+Block-shift lines^nnn+position to the right
^nnn(mmm  %-+Shift^nnn+lines^mmm+position to the left
^nnn((    %-+Block-shift lines^nnn+position to the left
^nnn>mmm  %-+Shift^nnn+lines^mmm+position to the right respecting comments^/* */
^nnn>>    %-+Block shift+lines^nnn+position to the right respecting comments
^nnn<mmm  %-+Shift^nnn+lines^mmm+position to the left respecting comments^/* */
^nnn<<    %-+Block shift+lines^nnn+position to the left respecting comments
^nnn/*    %-+Make comments^/*+and^*/+ on the next^nnn+lines                     */
^Annn     %-+Add^nnn+lines after the specified line
^B        %-+Append a comment box after the specified line
^BRnnn    %-^BROWSE+the dataset named on the next^nnn+lines
^BBR      %-+Block^BROWSE+the dataset named on the selected lines
^Cnnn     %-+Copy the next^nnn+lines before/after the specified line
^CC       %-+Block-copy lines before/after the specified line
^CLnnn    %-+Translate the comment text (between /* and */) to lowercase
^CCL      %-+Block-translate the comment text (between /* and */) to lowercase
^CMP      %-+Compare the selected line with the next line ('?' the scale will
            +indicate where the difference are)
^CUnnn    %-+Translate the comment text (between /* and */) to uppercase
^CCU      %-+Block-translate the comment text (between /* and */) to uppercase
^Dnnn     %-+Delete the next^nnn+lines starting at the specified line
^DD       %-+Block-delete lines
^DO       %-+Add a "Do"-statement after the specified line
^Ennn     %-+Emulate the specified line onto the next^nnn+lines (see also^O+)
^EXnnn    %-+Execute the^XEDIT+command on the next^nnn+lines
^EEX      %-+Block-execute the^XEDIT+commands on the selected lines
^F        %-+Copy/Move the line(s) following the specified line
^FLDnnn   %-+Display the fields on the next^nnn+lines
            +See also the^FIELD+command
^FOR      %-+Add a "Do . to . by ."-statement after the specified line
^FROM     %-+Search for the first occurrence where the procedure is called.
            +The procedure is identified by the PROC, END or SECTION keyword
            +on the line of the prefix command.
            +The tags ".from" and ".to" is set on the line selected line,
            +so you can easily return to the "calling" of the procedure, section
            +or TOC. Also the tags ".frmnn" and ".tonn" are set to provide a
            +history tags (see DTAgs to display the tags).
^ELSE     %-+Add an "Else"-statement after the specified line
^G        %-+Copy the contents of the "Clip-board" after the specified line
^Hnnn     %-+Select the next^nnn+line as horizontal editing lines, i.e.
            +horizontal editing lines only work on these lines.
^HH       %-+Block select line as horizontal editing lines, i.e. horizontal
            +editing lines only work on these lines.
^HEXnnn   %-+For^nnn+lines change the contents of the line to HEX for "non-HEX
            +lines" and vice versa ("HEX-line" only contains 1234567890ABCDEF).
^HHEX     %-+Block change the contents of the line to HEX for non-HEX lines and
            +vice versa.
^Innn     %-+Add^nnn+lines before the specified line
^IF       %-+Add an "If Then Else"-statement after the specified line
^Knnn     %-+Put line(s) in comments (/* and */) or Remove comments
^KK       %-+Block-put or remove comments
^Lnnn     %-+Translate the next^nnn+lines to lower case
^LCnnn    %-+Translate the next^nnn+lines to lower case, but not the comments
^LENnnn   %-+Display the length of next^nnn+lines
^LISTnnn  %-+Display a dataset list that match the^dset+pattern in
            +next^nnn+lines
^LL       %-+Block-translate lines to lower case
^LLC      %-+Block-translate lines to lower case, but not the comments
^Mnnn     %-+Move the next^nnn+lines before/after the specified line
^Onnn     %-+Overlay the specified line on the following^nnn+lines (see also^E+)
^P        %-+Copy/Move the line(s) preceding the specified line
^PROC     %-+Define the synonym PROCLIB for the mentioned dataset on the line:
            +  SYNONYM PROCLIB 4 XEDIT <dataset>
            +See also prefix command^z
^PAnnn    %-+Append the next^nnn+lines to the "Clip-board"
^PDnnn    %-+Put the next^nnn+lines in the "Clip-board" and deleted them
^PUTnnn   %-+Put the next^nnn+lines in the "Clip-board"
^PP       %-+Block-put lines in the "Clip-board"
^PPA      %-+Block-append lines to the "Clip-board"
^PPD      %-+Block-put lines in the "Clip-board" and delete them
^Rnnn     %-+Repeat the specified line^nnn+times
^RR       %-+Block repeat lines
^SELEC    %-+Add a "Select When Otherwise"-statement after the specified line
^SI       %-+Structure input: add a new line every time ENTER is pressed
^SQL      %-+Execute the SQL-statement on this line and following lines upto the
            +next semicolon (;). See also the line command^SSID.
^Tnnn     %-+Insert the tagchange^string+in to the next^nnn+lines even if
            ^TAGCHANGE+is^OFF+(The IFBLANK/ALWAYS option IS respected).
            +See also the^TAGCHANGE+command.
^TO       %-+Search for the called procedure (identified by the word after CALL
            +or PERFROM) or the chapter in the table of contents on the selected
            +line. The tags ".from" and ".to" is set on the line selected line,
            +so you can easily return to the "calling" of the procedure, section
            +or TOC. Also the tags ".frmnn" and ".tonn" are set to provide a
            +history tags (see DTAgs to display the tags).
^TT       %-+Block tagchange string insert (see above)
^TTSO     %-+Block execute the TSO-statements
^TSOnnn   %-+Execute the TSO-statements on the next^nnn+lines
^Unnn     %-+Translate the next^nnn+lines to upper case
^UUC      %-+Block-translate lines to upper case, but not the comments
^UCnnn    %-+Translate the next^nnn+lines to upper case, but not the comments
^UTnnn    %-+Delete the tagchange^string+in to the next^nnn+lines.
            +See also the^TAGCHANGE+command.
^UTT      %-+Block delete the tagchange^string
^UU       %-+Block-translate lines to upper case
^VARnnn   %-+Display the variables on the next^nnn+lines
            +See also the^VARIABLE+command
^nnnWmmm  %-+Put the words on the next^nnn+lines in column 1 to^mmm+(defaul=70)
^nnnWW    %-+Block put the words in column 1 to^nnn+(default=70)
^WHEN     %-+Add a "When"-statement after the specified line
^Xnnn     %-^XEDIT+the dataset named on the next^nnn+lines
^XX       %-+Block^XEDIT+the dataset named on the selected lines
^XAEnnn   %-+Translate the next^nnn+lines from ASCII to EBCDIC
^XFnnn    %-+Edit the member mentioned in the selected line via XFIND.
            +This is especially handy for clists and panels
            %Text in record              XEDIT command
            ^CALL xxxx                   XFIND xxxx
            ^MEMBER=xxxx                 XFIND xxxx
            ^PROC=xxxx                   XFIND xxxx
            ^INCLUDE xxxx                XFIND xxxx
            ^COPY xxxx                   XFIND xxxx
            ^PLAN(xxxx                   XFIND xxxM
            ^EXEC xxxx                   XFIND xxxx
            ^(xxxx)                      XFIND xxxx
            ^.IM xxxx                    XFIND xxxx
^XEAnnn   %-+Translate the next^nnn+lines from EBCDIC to ASCII
^XEnnn    %-+Execute the^XEDIT+command on the next^nnn+lines
^XLnnn    %-+Edit the member mentioned in the selected line via XLIST.
            +This is especially handy in jobs and procs where you can have:
            %Text in record              XEDIT command
            ^CALL xxxx                   XLIST xxxx
            ^MEMBER=xxxx                 XLIST xxxx
            ^PROC=xxxx                   XLIST xxxx
            ^INCLUDE xxxx                XLIST xxxx
            ^COPY xxxx                   XLIST xxxx
            ^PLAN(xxxx                   XLIST xxxM
            ^EXEC xxxx                   XLIST xxxx
            ^(xxxx)                      XLIST xxxx
            ^.IM xxxx                    XLIST xxxx
^XLMFnnn  %-^XLMF+the dataset named on the next^nnn+lines
^XXE      %-+Block-execute the^XEDIT+commands on the selected lines
^XXLMF    %-+Block^XLMF+the dataset named on the selected lines
^Znnn     %-+Zoom into the member mentioned in the selected line
            +(XEDIT variables can be used to change JCL-variables and
            +synonyms are needed to trap the generate XEDIT commands see
            +the commands SYNONYM and XVAR for more information on this).
            +This is especially handy in jobs and procs where you can have:
            %Text in record              XEDIT command generated (synonym)
            ^CALL xxxx                   type(xxxx)
            ^MEMBER=xxxx                 PROCLIB(xxxx)
            ^INCLUDE xxxx                INCLUDE(xxxx)
            ^COPY xxxx                   INCLUDE(xxxx)
            ^PROC=xxxx                   PROCLIB(xxxx)
            ^EXEC xxxx                   PROCLIB(xxxx)
            ^PLAN(xxxx                   PLAN(xxxM)
            ^IGD104I xxxx RETAINED, ...  XEDIT xxxx
            ^q1.q2.q3(xxxx)              q3(xxxx)
            ^DSN=xxxx                    XEDIT xxxx
            ^DSNAME=xxxx                 XEDIT xxxx
            ^DSET=xxxx                   XEDIT xxxx
            ^.IM xxxx                    XEDIT xxxx
)INIT
&MIN = '-'
&MM  = '--'
)PROC
)END
>Panel XEDHELP4
)PANEL KEYLIST(XEDHELP1,XED6)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDHELP4                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display help for horizontal editing commands   **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR
  ^ type(text) color(turq) caps(off)
  ` area(scrl) extend(on)
  ~ type(text) color(white) caps(off) hilite(reverse)
  } type(output) color(yellow) caps(off)
  # type(text) color(yellow)
  @ type(text) color(turq)
  $ type(text) color(green)
)BODY DEFAULT(%¢¦) CMD() LMSG(MSG) SMSG(MSG)
~XEDIT Help for Horizontal Editing Commands                                    %
`HELP                                                                          `
}MSG
~PF3=Help main menu                 PF7=Backward          PF8=Forward
)AREA HELP
¢Horizontal editing command can be specified by overtyping the scale. There are
¢two ways to specify a "count":
% *¢Repeat the same command letter (e.g. add 6 columns: aaaaaa)
% *¢Specify a count after the command (e.g. add 6 columns: a6)
¢
¢By default the horizontal editing command work on the whole file. With the
¢prefix command^H¢and^HH¢a range of lines can be selected on which the
¢horizontal editing commands work. If such a range is selected the line-numbers
¢of lines outside of this range are displayed in a different color (specified
¢on the^COLOR PREFIX <color> <hilite>¢command (e.g. line zero has that color)
¢This range is marked by the tags%.HorB¢and%.HorE¢. The settings of these tags
¢can be displayed with the^DTAG¢command.
¢
¢A temporary restriction is that only one horizontal editing command is handled
¢when you press ENTER.
¢
¢The XEDIT horizontal editing command are:
^"<n>      %-¢Repeat^n¢columns starting with the selected column
^+<n>      %-¢Accumulate all numbers in the selected columns
^+<n> =<n> %-¢Accumulate all numbers in the selected columns by the +-signs and
             ¢place the result in the columns marked by the =-signs
^=         %-¢Repeat the previous horizontal editing command
^?         %-¢Redisplay the previous horizontal editing command
^/         %-¢Scroll to the right to make that column the first displayed column
^\         %-¢Scroll to the left to make that column the last displayed column
^a<n>      %-¢Add^n¢columns after the selected column
^b<n>      %-¢Blank out^n¢columns
^c<n>      %-¢Copy^n¢columns before the%p¢or after the%f
^d<n>      %-¢Delete^n¢columns starting with the selected column
^e<string> %-¢Replace^string¢in the selected columns
^f         %-¢Move or copy columns after the selected column
^i<n>      %-¢Insert^n¢columns before the selected column
^j<l|r><n> %-¢Justify all lines to the left or right leaving maximal^n¢blanks
^jj<l|r><n>%-¢Justify all lines in the columns to the next%j¢to the left or
^            ¢right leaving maximal^n¢blanks
^o<string> %-¢Replace blanks with^string¢in the selected columns
^m<n>      %-¢Move^n¢columns before the%p¢or after the%f
^n<n>      %-¢Put numbers in the^n¢columns (do NOT overwrite non-blank data)
^N<n>      %-¢Put numbers in the^n¢columns (DO overwrite non-blank data)
^l<n>      %-¢Translate^n¢columns to lowercase starting with the selected column
^p         %-¢Move or copy columns before the selected column
^r<n>      %-¢Repeat^n¢columns starting with the selected column
^s         %-¢Sort the file on the selected column in ascending order
^S         %-¢Sort the file on the selected column in decending order
^u<n>      %-¢Translate^n¢columns to uppercase starting with the selected column
^w<n>      %-¢Place all words in the next^n¢columns
^y<n>      %-¢Cascade the characters in the selected columns on to the next line
             ¢if the character on the next line is blank
^Y<n> =<n> %-¢Use the specified column as part of an arithmetical expression
^            ¢Place the arithmetical expression in the specified column(s)
^            ¢For examples of usage of^Y¢and^=¢, see below.
^            ¢Note that any REXX function can be used.
¢
%Note:¢if you only want to horizontal edit part of a dataset, you can use the
¢prefix command^ppd¢to "cut" that part out of the dataset and then use^put¢to
¢to get it into a dummy dataset. Then you can do your horizontal editing, and
^put¢and^get¢again to copy it back to your dataset.
¢
¢To clarify the use of^Y¢and^=¢the example below shows the horizontal editing
¢command and its result.
%BEFORE:
#      <.YYYYYYYYY./.+.trunc(YYYYY).3....=========.===..5....+....6....+....7...
@    1$     234               6.5
@    2$    2**3              3
@    3$  Date('B')           66//7
¢
%AFTER:
#      <...+....1....+....2....+....3....+....4....+....5....+....6....+....7...
@    1$     234               6.5               39.000
@    2$    2**3              3                   2.667
@    3$  Date('B')           66//7          242902.333
¢
¢If you leave out the^=========.===¢the result will not be place in the file,
but will be displayed on your screen.
)PROC
)END
>Panel XEDHELP5
)PANEL KEYLIST(XEDHELP1,XED6)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDHELP4                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display help for Function keys.                **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR
  ^ type(text) color(turq) caps(off)
  ` area(scrl) extend(on)
  ~ type(text) color(white) caps(off) hilite(reverse)
  } type(output) color(yellow) caps(off)
)BODY CMD() LMSG(MSG) SMSG(MSG)
~XEDIT Help for PFkeys                                                         %
`HELP                                                                          `
}MSG
~PF3=Help main menu                 PF7=Backward          PF8=Forward
)AREA HELP
%XEDIT+uses a standard keylist, PFkeys can be customized with the command:
%      PFKEY PFnn command
+The bottom-line containing a description of the PFkeys can also be customized:
%      PFKEYLine text
+The default PFkey settings on the EDIT-screen are defined as follows:
^PF1  %=+Display help-information
^PF2  %=+Repeat the last command entered
^PF3  %=+Quit
^PF4  %=+Move the cursor to the FIRST non-blank of the line pointed to by
+        the cursor
^PF5  %=+Split or join the line pointed to by the cursor
^PF6  %=+Move the cursor to the LAST non-blank of the line pointed to by
+        the cursor
^PF7  %=+Move one page UP
^PF8  %=+Move one page DOWN
^PF9  %=+Go to the TOP of the file
^PF10 %=+Move 30 columns to the LEFT
^PF11 %=+Move 30 columns to the RIGHT
^PF12 %=+Go to the BOTTOM of the file
+
+The PFkeys on the DIRECTORY-, and DATASETS-screen are defined as follows:
^PF1  %=+Display help-information
^PF2  %=+Repeat the last command entered
^PF3  %=+Quit
^PF4  %=+Delete all members/datasets whose names were cleared
^PF5  %=+Refresh the displayed member- or dataset list
^PF6  %=+Rename all members/datasets whose names were changed
^PF7  %=+Move one page UP
^PF8  %=+Move one page DOWN
^PF9  %=+Go to the TOP of the member- or dataset list
^PF10 %=+LEFT/RIGHT for DATASETS-screen, STATISTICS DIRECTORY-screen
^PF11 %=+XEDIT member/dataset pointed to by the cursor
^PF12 %=+Go to the BOTTOM of the member- or datset list
+
%Note:+ENTER can be used to move the cursor to the command area and back.
)PROC
)END
>Panel XEDHELP6
)PANEL KEYLIST(XEDHELP1,XED6)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDHELP5                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display the latest news about XEDIT.           **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR
  ¢ type(text) color(turq) caps(off)
  ` area(scrl) extend(on)
  ~ type(text) color(white) caps(off) hilite(reverse)
  # type(text) color(red) caps(off)
  { type(text) color(blue) caps(off)
  } type(output) color(yellow) caps(off)
  @ type(text) color(yellow)
)BODY              CMD() LMSG(MSG) SMSG(MSG)
~XEDIT News                                                                    %
`HELP                                                                          `
}MSG
~PF3=Help main menu                 PF7=Backward          PF8=Forward
)AREA HELP
{In@XEDIT release 1.7{support for terminal wider than 80 characters is added,
{
{and VSAM datasets can be edited.
{Highlighting is done for search strings (by default in~white reverse{) and
{non-displayable hexadecimal data (by default in#red{).
{
{Also the following line commands were added:
¢ALLOCNew <dset>
           !-{Allocate a new dataset with properties of the currently edited
             {dataset.
¢ARbchar <OFF|ON <c>>
           %-{Define arbitrary character for search commands like:¢/{,
             ¢^/{,¢\{,¢^\{,¢LOCATE{,¢DELETELINES{and¢CHANGE{)
             {This allows you to do commands like:¢c/the $ sheep/all $ dogs/ *
             {which will change%the black sheep{into%all black dogs{, but also
             %the white sheep{into%all white dogs{. The command¢c/end$/end/ *
             {will delete all characters after the word%end{.
¢AUTHorization <dset>
           %-{Check your authorization for the dataset¢dset{
¢BYtes     %-{Display the size of the dataset in bytes
¢COLCAscade from count
           %-{Cascade the¢count{characters in the columns starting from¢from
             {over the next line if a character is blank.
¢DTags     %-{Display all tags in the current dataset
¢INFo <dataset>
           %-{Display allocation information for the dataset
¢ISpf      %-{Go to the ISPF main menu (press F3 to return to XEDIT)
¢LOWERWord %-{Translate the word pointed to by the cursor to lower case
¢MAxline   %-{Display which line is the longest line
¢Nondisp   %-{Search for the next non-displayable character
¢PUTAdd <nnn|*>
           %-{Append¢nnn{lines to the "Clip-board"
¢SCale <text>
           %-{Display¢<text>{on the scale line (line 3 on the panel).
             {If¢<text>{is omitted the standard scale is displayed.
             {Can be handy when the file has fixed columns of data.
¢UPPERWord %-{Translate the word pointed to by the cursor to upper case
¢XPIPE pipecommand
           %-{Execute the specified PIPE-command.
             %Note{that the stem¢line.{contains the contents of the file being
             {edited. For example the command:
             ¢  xpipe stem line. | snake 4 | stem line.
             {Puts the contents of the file in 4 columns.
¢XVar <On|OFf>
           %-{Turn variable translation on or off.
¢FPRevious %-{File current dataset and go to the previously edited file in ring.
¢QPRevious %-{Quit current dataset and go to the previously edited file in ring.
¢QQPRevious%-{QQuit current dataset and go to the previously edited file in ring
¢XPrevious %-{Go to the previously edited file in the ring.
{
{The following prefix commands were added to%XEDIT:
¢Hnnn      %-{Select the next¢nnn{line as horizontal editing lines, i.e.
             {horizontal editing lines only work on these lines.
¢HH        %-{Block select line as horizontal editing lines, i.e. horizontal
             {editing lines only work on these lines.
¢HEXnnn    %-{For¢nnn{lines change the contents of the line to HEX for "non-HEX
             {lines" and vice versa ("HEX-line" only contains 1234567890ABCDEF).
¢HHEX      %-{Block change the contents of the line to HEX for non-HEX lines and
             {vice versa.
¢nnnLIST   %-{Display a dataset list that match the¢dset{pattern in the next¢nnn
             {lines
¢nnnPA     %-{Append the next¢nnn{lines to the "Clip-board"
¢PPA       %-{Block-append lines to the "Clip-board"
¢nnnWmmm   %-{Put the words on the next¢nnn{lines in column 1 to¢mmm{(defaul=70)
¢nnnWW     %-{Block put the words in column 1 to¢nnn{(default=70)
¢TTSO      %-{Block execute the TSO-statements
¢nnnTSO    %-{Execute the TSO-statements on the next¢nnn{lines
¢XX        %-{Block XEDIT the dataset named on the selected lines
¢EXX       %-{Block-execute the^XEDIT{commands on the selected lines
¢XXE       %-{Block-execute the^XEDIT{commands on the selected lines
{
{The following horizontal commands were added to%XEDIT:
¢+<n> =<n> %-{Accumulate all numbers in the selected columns by the +-signs and
             ¢place the result in the columns marked by the =-signs
¢y<n>      %-{Cascade the characters in the selected columns on to the next line
             {if the character on the next line is blank
¢
¢
¢
¢
{In@XEDIT release 1.6{the following line commands were added:
{
¢DRing     %-{Display all datasets in the XEDIT-ring in a popup-window
¢BRAll     %-{Browse all datasets in the dataset-list or all members in the
¢            {directory-list
¢CHEckpli  %-{Check for PL/1 comment/quote balancing or margin errors
¢DELETEDuplicate
¢          %-{Delete all duplicate lines starting with the current line
¢EDITAll   %-{Edit all datasets in the dataset-list or all members in the
¢            {directory-list
¢File <nn> %-{Perform¢nn{File commands
¢FINdduplicate
¢          %-{Find the next duplicate line after the current line
¢FINDUnique%-{Find the next unique line after the current line
¢LIBrary   %-{Library Utility (ISPF option 3.1)
¢Quit <nn> %-{Perform¢nn{Quit commands
¢QQuit <nn>%-{Perform¢nn{QQuit commands
¢COPy      %-{Move/Copy Utility (ISPF option 3.3)
¢SEarch    %-{Search-For Utility (ISPF option 3.14)
¢SSid <DB2>%-{Set the DB2 subsystem-ID for the¢SQL{prefix area command
¢SUPerc    %-{SuperC Compare Utility (ISPF option 3.12)
¢TAGchange <On|OFf> string from to <Ifblank|Always>
¢          %-{Place the specified¢string{in position¢from{to¢to{in every line if
¢            {a change is made in that line.
¢            {If the¢Ifblank{option is selected the¢string{is only inserted if
¢            {position¢from{to¢to{is blank.
¢            {If the¢Always{option is selected this is done even if position
¢            ¢from{to¢to{is not blank.
¢            %Note:{if the¢string{starts with%/*{and ends with%*/{it is
¢            {      "comment sensitive", i.e. if position¢from{to¢to{is in a
¢            {      comment the%/*{and%*/{are left out.
¢            {      See also the¢t{and¢tt{prefix commands (to intentionally
¢            {      tag a line even is TAGCHANGE is OFF).
¢            {Default: TAGCHANGE OFF /*CHANGE*/ 63 72 IFBLANK
¢TImezone <{|-> hh:mm
¢            {Adjust time displayed on the upper right conner.
¢TRap cmd  %-{Trap the output of TSO command¢cmd{and add them after the current
¢            {line.
{
{The following prefix commands were added to%XEDIT:
¢nnnLEN    %-{Display the length of next¢nnn{lines
¢nnnT      %-{Insert the tagchange¢string{in to the next¢nnn{lines even if
{            ¢TAGCHANGE{is¢OFF{(The IFBLANK/ALWAYS option IS respected).
¢SQL       %-{Execute the SQL-statement on this line and following lines upto
{            {the next semicolon (;). See also the line command^SSID.
¢TT        %-{Block tagchange string insert (see above)
¢nnnUT     %-{Delete the tagchange¢string{in to the next¢nnn{lines.
¢            {See also the^TAGCHANGE{command.
¢UTT       %-{Block delete the tagchange¢string
¢-Xedit    %-{Go to the previous file in the EDIT-ring.
{
{
{
{In@XEDIT release 1.5{the following horizontal editing commands were added:
{
¢/         %-{Scroll to the right to make that column the first displayed column
¢\         %-{Scroll to the left to make that column the last displayed column
¢w<n>      %-{Place all words in the next¢n{columns
{
{
{
{In@XEDIT release 1.4{the following horizontal editing commands were added:
{
¢=         %-{Repeat the previous horizontal editing command
¢?         %-{Redisplay the previous horizontal editing command
¢j<l|r><n> %-{Justify all lines to the left or right leaving maximal¢n{blanks
¢jj<l|r><n>%-{Justify all lines in the columns to the next%j{to the left or
¢            {right leaving maximal¢n{blanks
¢Y<YY..Y>  %-{Use the specified column as part of an arithmetical expression
¢            {Note that any REXX function can be used.
¢=<==..=>  %-{Place the arithmetical expression in the specified column(s)
{
{The following line commands were added to%XEDIT:
¢Browse <dset>      %-{Browse the specified dataset (ISPF BROWSE)
¢COLJUstify <Left|Right> <space> <from> <to>
¢                   %-{Justify all lines in the columns¢from{to¢to{to the left
¢                   %-{or right leaving maximal¢space{blanks
¢Edit <dset>        %-{Edit the specified dataset (ISPF EDIT)
¢List <dset>        %-{Display a dataset list that match the^dset{pattern (3.4)
¢HOrizontal <On|OFf> <nnn <mmm|*> >
                    %-{Enable/disable horizontal editing and set the horizontal
                      {editing range on the lines^nnn{to^mmm
{
{The following prefix command was added to%XEDIT:
¢XE        %-{Execute the%XEDIT{command on the specified line
{
{
{
{In@XEDIT release 1.3{the horizontal editing is available.
{
{See the topic%Horizontal editing commands{on the XEDIT Help Main Menu.
{
{
{
{In@XEDIT release 1.2{the following commands were added to%XEDIT:
{
¢Tab                %-{Go to the next tab
¢TABS n1 <n2 ... nx>%-{Define column numbers for tab settings
¢TABLine <On|OFf>   %-{Display the tabs on the scale with a "T" for every tab
{
{The restriction that only PF1 to PF12 could be used has been releaved. You can
{now also assign commands to PF13 to PF24. Through the use of keylists, PFkey
{settings of XEDIT nolonger affect other applications
{
{
{
{In@XEDIT release 1.1{it is possible to specify a pattern for a member-list:
{
{For example you could now issue the following command:
¢          X GEORGE.TSO.CLIST(A*)  {or¢  X GEORGE.TSO.CLIST(B*C)
{
{The following commands where added to%XEDIT:
{
¢XXedit <project.group1.type<(member)> <group2> <group3> <group4> >
¢          {Edit the specified¢member{in¢project.group1..type{or in
¢          ¢project.group2.type{or in¢project.group3.type{or in
¢          ¢project.group4.type{(wherever it is found first)
¢          {If no member is specified a combined directory list is
¢          {displayed. If no dataset is specified a pop-up is shown.
¢          {Try¢XX{on the command line.
¢DELETELines <^>/string</>
¢          {Delete all lines starting with the current line that do (or do not)
¢          {contain the specified string (specify one blank to select blank
¢          {lines).
{
{The following prefix-commands where added to%XEDIT:
{
¢nnnLC     {Translate the next¢nnn{lines to lower case, but not the comments
¢LLC       {Block-translate lines to lower case, but not the comments
¢nnnUC     {Translate the next¢nnn{lines to upper case, but not the comments
¢UUC       {Block-translate lines to upper case, but not the comments
)PROC
)END
>Panel XEDITBIG
)PANEL KEYLIST(XEDITCNF,XED2)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITBIG                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Ask the user if he want to edit a big dataset  **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 \ TYPE(FP)                            /* Field prompt                */
 _ TYPE(INPUT) COLOR(TURQ) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
)BODY WINDOW(76,12) CMD() SMSG(MSG) LMSG(MSG)
~Edit big dataset &DATASET
\
\You want to edit a very big dataset (&DATASET)
\which is &NrBytes
\Do you really want to edit it?
\
\Put your cursor on one of the options and press ENTER
\
_OPTION1
_OPTION2
@MSG
~ENTER=Select  F3=Cancel
)INIT
.HELP = XEDHELP
&OPTION1 = 'No, use browse it'
&OPTION2 = 'Yes, edit it'
vget (cursor,csrpos)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'OPTION1'
 .csrpos = 1
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (cmd,pfkey,cursor,csrpos)
)END
>Panel XEDITCHM
)PANEL KEYLIST(XEDITREC,XED4)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITCHM                                       **/
/**                                                                  **/
/** Creation date   : June, 2000                                     **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : OMVS chmod                                     **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 % TYPE(TEXT) COLOR(GREEN) INTENS(HIGH)
 ' TYPE(TEXT) COLOR(BLUE) INTENS(HIGH)
 | AREA(SCRL) EXTEND(ON)
 _ TYPE(INPUT) COLOR(WHITE) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
)BODY WINDOW(77,11) CMD() SMSG(MSG) LMSG(MSG)
~XEDIT OMVS Change Mode
%Path  . . . . . . :^PWD
%&FileDir           ^FILE
 
'Authority           R W X
  %User  . . . . . ._Z_Z_Z%
  %Group . . . . . ._Z_Z_Z%
  %Other . . . . . ._Z_Z_Z%
 
@MSG
~ENTER=Process F1=Help F3=Return F12=Cancel
)INIT
.ZVARS = '(UserR UserW UserX GroupR GroupW GroupX OtherR OtherW OtherX)'
.HELP = XEDHELP
)PROC
&pfkey = .pfkey
VPUT (UserR UserW UserX GroupR GroupW GroupX OtherR OtherW OtherX)
)END
>Panel XEDITCNF
)PANEL KEYLIST(XEDITCNF,XED2)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITCNF                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Ask the user a confirmation.                   **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 \ TYPE(FP)                            /* Field prompt                */
 _ TYPE(INPUT) COLOR(TURQ) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
)BODY WINDOW(76,11) CMD() SMSG(MSG) LMSG(MSG)
~Confirm Lock
\
\You requested to lock the dataset "&DATASET",
\but it has been updated since you last accessed it.
\
\Put your cursor on one of the options and press ENTER
\
_OPTION1
_OPTION2
@MSG
~ENTER=Select  F3=Return
)INIT
.HELP = XEDHELP
&OPTION1 = 'Lock most recent version'
&OPTION2 = 'Lock this version'
vget (cursor,csrpos)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'OPTION1'
 .csrpos = 1
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (cmd,pfkey,cursor,csrpos)
)END
>Panel XEDITFIN
)PANEL KEYLIST(XEDITREC,XED4)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITFIN                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display search results for member in allocated **/
/**                   libraries                                      **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 | AREA(SCRL)
 _ TYPE(INPUT) COLOR(WHITE) INTENS(HIGH) CAPS(ON) HILITE(USCORE)
 $ TYPE(OUTPUT) COLOR(WHITE) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(TEXT) COLOR(GREEN) INTENS(LOW) CAPS(OFF) JUST(ASIS) SKIP(ON)
 ` TYPE(TEXT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS) SKIP(ON)
 @ TYPE(TEXT) COLOR(&XFCOLOR) INTENS(HIGH) CAPS(OFF) HILITE(&XFHILITE)
 \ TYPE(TEXT) COLOR(BLUE) INTENS(LOW) CAPS(OFF) JUST(ASIS)
)BODY WINDOW(76,22) CMD() SMSG(MSG) LMSG(MSG)
~XFIND: Edit member &MEMBER in currently allocated libraries
^
@&XFmsg
|LIBS                                                                      |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
$MSG
~ENTER=Process  F3=Return  F7=Backward  F8=Forward
)AREA LIBS
\            Dataset                                               DDname
^Results . :_XFdset1                                              `&XFdd1
^           _XFdset2                                              `&XFdd2
^           _XFdset3                                              `&XFdd3
^           _XFdset4                                              `&XFdd4
^           _XFdset5                                              `&XFdd5
^           _XFdset6                                              `&XFdd6
^           _XFdset7                                              `&XFdd7
^           _XFdset8                                              `&XFdd8
^           _XFdset9                                              `&XFdd9
^           _XFdset10                                             `&XFdd10
^           _XFdset11                                             `&XFdd11
^           _XFdset12                                             `&XFdd12
^           _XFdset13                                             `&XFdd13
^           _XFdset14                                             `&XFdd14
^           _XFdset15                                             `&XFdd15
^           _XFdset16                                             `&XFdd16
^           _XFdset17                                             `&XFdd17
^           _XFdset18                                             `&XFdd18
^           _XFdset19                                             `&XFdd19
^           _XFdset20                                             `&XFdd20
^           _XFdset21                                             `&XFdd21
^           _XFdset22                                             `&XFdd22
^           _XFdset23                                             `&XFdd23
^           _XFdset24                                             `&XFdd24
^           _XFdset25                                             `&XFdd25
^           _XFdset26                                             `&XFdd26
^           _XFdset27                                             `&XFdd27
^           _XFdset28                                             `&XFdd28
^           _XFdset29                                             `&XFdd29
^           _XFdset30                                             `&XFdd30
^           _XFdset31                                             `&XFdd31
^           _XFdset32                                             `&XFdd32
^           _XFdset33                                             `&XFdd33
^           _XFdset34                                             `&XFdd34
^           _XFdset35                                             `&XFdd35
^           _XFdset36                                             `&XFdd36
^           _XFdset37                                             `&XFdd37
^           _XFdset38                                             `&XFdd38
^           _XFdset39                                             `&XFdd39
^           _XFdset40                                             `&XFdd40
^           _XFdset41                                             `&XFdd41
^           _XFdset42                                             `&XFdd42
^           _XFdset43                                             `&XFdd43
^           _XFdset44                                             `&XFdd44
^           _XFdset45                                             `&XFdd45
^           _XFdset46                                             `&XFdd46
^           _XFdset47                                             `&XFdd47
^           _XFdset48                                             `&XFdd48
^           _XFdset49                                             `&XFdd49
^           _XFdset50                                             `&XFdd50
)INIT
.HELP = XEDHELP
vget (cursor csrpos member msg)
vget (XFdset1  XFdset2  XFdset3  XFdset4  XFdset5 ,
      XFdset6  XFdset7  XFdset8  XFdset9  XFdset10,
      XFdset11 XFdset12 XFdset13 XFdset14 XFdset15,
      XFdset16 XFdset17 XFdset18 XFdset19 XFdset20)
vget (XFdset21 XFdset22 XFdset23 XFdset24 XFdset25,
      XFdset26 XFdset27 XFdset28 XFdset29 XFdset30,
      XFdset31 XFdset32 XFdset33 XFdset34 XFdset35,
      XFdset36 XFdset37 XFdset38 XFdset39 XFdset40)
vget (XFdset41 XFdset42 XFdset43 XFdset44 XFdset45,
      XFdset46 XFdset47 XFdset48 XFdset49 XFdset50)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'XFDSET1'
 .csrpos = 1
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (XFdset1  XFdset2  XFdset3  XFdset4  XFdset5 ,
      XFdset6  XFdset7  XFdset8  XFdset9  XFdset10,
      XFdset11 XFdset12 XFdset13 XFdset14 XFdset15,
      XFdset16 XFdset17 XFdset18 XFdset19 XFdset20)
vput (XFdset21 XFdset22 XFdset23 XFdset24 XFdset25,
      XFdset26 XFdset27 XFdset28 XFdset29 XFdset30,
      XFdset31 XFdset32 XFdset33 XFdset34 XFdset35,
      XFdset36 XFdset37 XFdset38 XFdset39 XFdset40)
vput (XFdset41 XFdset42 XFdset43 XFdset44 XFdset45,
      XFdset46 XFdset47 XFdset48 XFdset49 XFdset50)
vput (pfkey cursor csrpos)
)END
>Panel XEDITFLD
)PANEL KEYLIST(XEDIT,XED1)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITFLD                                       **/
/**                                                                  **/
/** Creation date   : Januari 2006                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 2006                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display fields in a record                     **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 | AREA(SCRL)
 _ TYPE(INPUT) COLOR(GREEN) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
 % TYPE(OUTPUT) COLOR(GREEN)
 #  AREA(DYNAMIC)
 01 TYPE(DATAIN)  COLOR(TURQ) JUST(ASIS) CAPS(OFF) HILITE(USCORE)
 02 TYPE(DATAOUT) CAPS(OFF)
 13 TYPE(DATAOUT) COLOR(RED) CAPS(OFF)
)BODY WINDOW(76,22) CMD() SMSG(MSG) LMSG(MSG)
~Fields of &FLDGROUP
%FLD1N                 #FLD1                                               #
%FLD2N                 #FLD2                                               #
%FLD3N                 #FLD3                                               #
%FLD4N                 #FLD4                                               #
%FLD5N                 #FLD5                                               #
%FLD6N                 #FLD6                                               #
%FLD7N                 #FLD7                                               #
%FLD8N                 #FLD8                                               #
%FLD9N                 #FLD9                                               #
%FLD10N                #FLD10                                              #
%FLD11N                #FLD11                                              #
%FLD12N                #FLD12                                              #
%FLD13N                #FLD13                                              #
%FLD14N                #FLD14                                              #
%FLD15N                #FLD15                                              #
%FLD16N                #FLD16                                              #
%FLD17N                #FLD17                                              #
%FLD18N                #FLD18                                              #
%FLD19N                #FLD19                                              #
@MSG
~F3=Update  F7=Backward  F8=Forward  F9=Top F11=Bottom  F12=Cancel
)INIT
.HELP = XEDHELP
vget (cursor,csrpos)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'FLD1'
 .csrpos = 2
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (FLD1 FLD2 FLD3 FLD4 FLD5 FLD6 FLD7 FLD8 FLD9 FLD10 FLD11)
vput (FLD12 FLD13 FLD14 FLD15 FLD16 FLD17 FLD18 FLD19)
vput (pfkey,cursor)
)END
>Panel XEDITINF
)PANEL KEYLIST(XEDITREC,XED4)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITINF                                       **/
/**                                                                  **/
/** Creation date   : June, 2000                                     **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display dataset information                    **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 % TYPE(TEXT) COLOR(GREEN) INTENS(HIGH)
 ' TYPE(TEXT) COLOR(BLUE) INTENS(HIGH)
 | AREA(SCRL) EXTEND(ON)
 _ TYPE(INPUT) COLOR(GREEN) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
)BODY WINDOW(77,26) CMD() SMSG(MSG) LMSG(MSG)
~XEDIT dataset information
|INFO                                                                      |
@MSG
~ENTER=Return  F1=Help F3=Return  F7=Backward  F8=Forward
)AREA INFO
%Data Set Name . . . . :^SYSDSNAM                                        +
+
'General Data                            'Current Allocation
+ %Volume  . . . . . . :^SYSVOLUM        + %Space in  . . . . . :^SYSUNITS
+ %Device type   . . . :^SYSUNIT         + %Allocated &units1   :^SYSALLOC
+ %SMS data class. . . :^SYSDATAC        + %Tracks per cylinder :^SYSTRKSC
+ %SMS management class:^SYSMGMTC        + %Blocks per track  . :^SYSBLKST
+ %SMS storage class . :^SYSSTORC        + %Allocated extents . :^SYSEXTEN
+ %Data set name type. :^SYSDSSMS        + %Maximum dir. blocks :^SYSADIRB
+ %Organization  . . . :^SYSDSORG
+ %Record format . . . :^SYSRECFM        'Current Utilization
+ %Record length . . . :^SYSLRECL        + %Used &units2        :^SYSUSED
+ %Block size  . . . . :^SYSBLKSI        + %Used 4K pages (PDSE):^SYSUSEDP
+ %1st extent &units3  :^SYSPRIMA        + %Used dir. blocks  . :^SYSUDIRB
+ %Secondary &units4   :^SYSSECON        + %Number of members . :^SYSMEMBE
+ %Key length  . . . . :^SYSKEYLE
+ %Password protected  :^SYSPASSW
+ %RACF profile  . . . :^SYSRACFA
+ %Creation date . . . :^SYSCREAT
+ %Referenced date . . :^SYSREFDA
+ %Changed ref. date . :^SYSUPDAT
+ %Expiration date . . :^SYSEXDAT
)INIT
.HELP = XEDHELP
)PROC
&pfkey = .pfkey
)END
>Panel XEDITLIS
)PANEL KEYLIST(XEDITREC,XED4)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITLIS                                       **/
/**                                                                  **/
/** Creation date   : August, 2006                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 2006                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Edit a member in a concatenation of libraries  **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 | AREA(SCRL)
 _ TYPE(INPUT) COLOR(WHITE) INTENS(HIGH) CAPS(ON) HILITE(USCORE)
 $ TYPE(OUTPUT) COLOR(WHITE) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(TEXT) COLOR(GREEN) INTENS(LOW) CAPS(OFF) JUST(ASIS) SKIP(ON)
 @ TYPE(TEXT) COLOR(BLUE) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 \ TYPE(TEXT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
)BODY WINDOW(70,22) CMD() SMSG(MSG) LMSG(MSG)
~XLIST: Edit member in a list of libraries
^
^  Member . . . . ._XLmember^
|LIBS                                                                |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
$MSG
~ENTER=Process  F3=Return  F7=Backward  F8=Forward
)AREA LIBS
^  Libraries  . . ._XLdset1                                     ^
^                  _XLdset2                                     ^
^                  _XLdset3                                     ^
^                  _XLdset4                                     ^
^                  _XLdset5                                     ^
^                  _XLdset6                                     ^
^                  _XLdset7                                     ^
^                  _XLdset8                                     ^
^                  _XLdset9                                     ^
^                  _XLdset10                                    ^
^                  _XLdset11                                    ^
^                  _XLdset12                                    ^
^                  _XLdset13                                    ^
^                  _XLdset14                                    ^
^                  _XLdset15                                    ^
^                  _XLdset16                                    ^
^                  _XLdset17                                    ^
^                  _XLdset18                                    ^
^                  _XLdset19                                    ^
^                  _XLdset20                                    ^
^                  _XLdset21                                    ^
^                  _XLdset22                                    ^
^                  _XLdset23                                    ^
^                  _XLdset24                                    ^
^                  _XLdset25                                    ^
^                  _XLdset26                                    ^
^                  _XLdset27                                    ^
^                  _XLdset28                                    ^
^                  _XLdset29                                    ^
^                  _XLdset30                                    ^
^                  _XLdset31                                    ^
^                  _XLdset32                                    ^
^                  _XLdset33                                    ^
^                  _XLdset34                                    ^
^                  _XLdset35                                    ^
^                  _XLdset36                                    ^
^                  _XLdset37                                    ^
^                  _XLdset38                                    ^
^                  _XLdset39                                    ^
^                  _XLdset40                                    ^
^                  _XLdset41                                    ^
^                  _XLdset42                                    ^
^                  _XLdset43                                    ^
^                  _XLdset44                                    ^
^                  _XLdset45                                    ^
^                  _XLdset46                                    ^
^                  _XLdset47                                    ^
^                  _XLdset48                                    ^
^                  _XLdset49                                    ^
^                  _XLdset50                                    ^
)INIT
.HELP = XEDHELP
vget (cursor csrpos XLmember msg)
vget (XLdset1  XLdset2  XLdset3  XLdset4  XLdset5 ,
      XLdset6  XLdset7  XLdset8  XLdset9  XLdset10,
      XLdset11 XLdset12 XLdset13 XLdset14 XLdset15,
      XLdset16 XLdset17 XLdset18 XLdset19 XLdset20)
vget (XLdset21 XLdset22 XLdset23 XLdset24 XLdset25,
      XLdset26 XLdset27 XLdset28 XLdset29 XLdset30,
      XLdset31 XLdset32 XLdset33 XLdset34 XLdset35,
      XLdset36 XLdset37 XLdset38 XLdset39 XLdset40)
vget (XLdset41 XLdset42 XLdset43 XLdset44 XLdset45,
      XLdset46 XLdset47 XLdset48 XLdset49 XLdset50)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'XLMEMBER'
 .csrpos = 1
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (XLdset1  XLdset2  XLdset3  XLdset4  XLdset5 ,
      XLdset6  XLdset7  XLdset8  XLdset9  XLdset10,
      XLdset11 XLdset12 XLdset13 XLdset14 XLdset15,
      XLdset16 XLdset17 XLdset18 XLdset19 XLdset20)
vput (XLdset21 XLdset22 XLdset23 XLdset24 XLdset25,
      XLdset26 XLdset27 XLdset28 XLdset29 XLdset30,
      XLdset31 XLdset32 XLdset33 XLdset34 XLdset35,
      XLdset36 XLdset37 XLdset38 XLdset39 XLdset40)
vput (XLdset41 XLdset42 XLdset43 XLdset44 XLdset45,
      XLdset46 XLdset47 XLdset48 XLdset49 XLdset50)
vput (XLmember pfkey cursor csrpos)
)END
>Panel XEDITMEM
)PANEL KEYLIST(XEDITREC,XED4)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITMEM                                       **/
/**                                                                  **/
/** Creation date   : June, 2000                                     **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display member information                     **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 % TYPE(TEXT) COLOR(GREEN) INTENS(HIGH)
 ' TYPE(TEXT) COLOR(BLUE) INTENS(HIGH)
 | AREA(SCRL) EXTEND(ON)
 _ TYPE(INPUT) COLOR(GREEN) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
)BODY WINDOW(77,23) CMD() SMSG(MSG) LMSG(MSG)
~XEDIT member information
%Data Set Name . . . . . . :^DSET
'
'General Data
  %Member  . . . . . . . . :^MEMNAME
  %library . . . . . . . . :^ZLLIB
  %Groups  . . . . . . . . :^XXGROUP1^XXGROUP2^XXGROUP3^XXGROUP4
  %Version/Modification  . :^VVMM
  %Created date  . . . . . :^ZLCDATE
  %Modified date . . . . . :^ZLMDATE
  %Modified time . . . . . :^ZLMTIME
  %Current size  . . . . . :^ZLCNORC
  %Initial size  . . . . . :^ZLINORC
  %Last modified by  . . . :^ZLUSER
  %&ALIASF                  ^ALIAS
  %Load module size in hex :^ZLSIZE
  %Track record (TTR). . . :^ZLTTR
  %Authorization code (AC) :^ZLAC
  %Addressing mode (AMODE) :^ZLAMODE
  %Residence mode (RMODE). :^ZLRMODE
  %Attributes  . . . . . . :^ATTR
@MSG
~ENTER=Return  F1=Help F3=Return
)INIT
.HELP = XEDHELP
)PROC
&pfkey = .pfkey
)END
>Panel XEDITMKD
)PANEL KEYLIST(XEDITREC,XED4)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITMKR                                       **/
/**                                                                  **/
/** Creation date   : June, 2000                                     **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : OMVS chmod                                     **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 % TYPE(TEXT) COLOR(GREEN) INTENS(HIGH)
 ' TYPE(TEXT) COLOR(BLUE) INTENS(HIGH)
 | AREA(SCRL) EXTEND(ON)
 _ TYPE(INPUT) COLOR(WHITE) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
 01 TYPE(DATAIN)  COLOR(WHITE) JUST(ASIS) CAPS(OFF)
 ¢  AREA(DYNAMIC) EXTEND(ON)
)BODY CMD() SMSG(MSG) LMSG(MSG)
~XEDIT OMVS Make Directory
'
%Path  . . . ._PATH
 
 
'
'Authority     R W X
  %User  . . ._Z_Z_Z%
  %Group . . ._Z_Z_Z%
  %Other . . ._Z_Z_Z%
¢DUMMY¢
@MSG
~ENTER=Process F1=Help F3=Return F12=Cancel
)INIT
.ZVARS = '(UserR UserW UserX GroupR GroupW GroupX OtherR OtherW OtherX)'
.HELP = XEDHELP
)PROC
&pfkey = .pfkey
VPUT (Path UserR UserW UserX GroupR GroupW GroupX OtherR OtherW OtherX)
)END
>Panel XEDITODM
)PANEL KEYLIST(XEDIT,XED1)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITODM                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display fields in ODM file                     **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 | AREA(SCRL)
 _ TYPE(INPUT) COLOR(GREEN) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
 % TYPE(OUTPUT) COLOR(GREEN)
 #  AREA(DYNAMIC)
 01 TYPE(DATAIN)  COLOR(TURQ) JUST(ASIS) CAPS(OFF) HILITE(USCORE)
 02 TYPE(DATAOUT) CAPS(OFF)
 13 TYPE(DATAOUT) COLOR(RED) CAPS(OFF)
)BODY WINDOW(76,22) CMD() SMSG(MSG) LMSG(MSG)
~ODM fields &ODMtitle
%ODM1N   #ODM1                                                             #
%ODM2N   #ODM2                                                             #
%ODM3N   #ODM3                                                             #
%ODM4N   #ODM4                                                             #
%ODM5N   #ODM5                                                             #
%ODM6N   #ODM6                                                             #
%ODM7N   #ODM7                                                             #
%ODM8N   #ODM8                                                             #
%ODM9N   #ODM9                                                             #
%ODM10N  #ODM10                                                            #
%ODM11N  #ODM11                                                            #
%ODM12N  #ODM12                                                            #
%ODM13N  #ODM13                                                            #
%ODM14N  #ODM14                                                            #
%ODM15N  #ODM15                                                            #
%ODM16N  #ODM16                                                            #
%ODM17N  #ODM17                                                            #
%ODM18N  #ODM18                                                            #
%ODM19N  #ODM19                                                            #
@MSG
~F3=Update  F7=Backward  F8=Forward  F9=Top F11=Bottom  F12=Cancel
)INIT
.HELP = XEDHELP
vget (cursor,csrpos)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'ODM1'
 .csrpos = 2
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (ODM1 ODM2 ODM3 ODM4 ODM5 ODM6 ODM7 ODM8 ODM9 ODM10 ODM11)
vput (ODM12 ODM13 ODM14 ODM15 ODM16 ODM17 ODM18 ODM19)
vput (pfkey,cursor)
)END
>Panel XEDITREC
)PANEL KEYLIST(XEDITREC,XED4)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITREC                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display the last 40 xedit commands.            **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 | AREA(SCRL)
 _ TYPE(INPUT) COLOR(GREEN) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
)BODY WINDOW(76,22) CMD() SMSG(MSG) LMSG(MSG)
~Recall XEDIT commands
|RECALL                                                                    |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
@MSG
~ENTER=Select  F3=Return  F5=Edit command  F7=Backward  F8=Forward
)AREA RECALL
_R1
_R2
_R3
_R4
_R5
_R6
_R7
_R8
_R9
_R10
_R11
_R12
_R13
_R14
_R15
_R16
_R17
_R18
_R19
_R20
_R21
_R22
_R23
_R24
_R25
_R26
_R27
_R28
_R29
_R30
_R31
_R32
_R33
_R34
_R35
_R36
_R37
_R38
_R39
_R40
_R41
_R42
_R43
_R44
_R45
_R46
_R47
_R48
_R49
_R50
_R51
_R52
_R53
_R54
_R55
_R56
_R57
_R58
_R59
_R60
_R61
_R62
_R63
_R64
_R65
_R66
_R67
_R68
_R69
_R70
_R71
_R72
_R73
_R74
_R75
_R76
_R77
_R78
_R79
_R80
_R81
_R82
_R83
_R84
_R85
_R86
_R87
_R88
_R89
_R90
_R91
_R92
_R93
_R94
_R95
_R96
_R97
_R98
_R99
_R100
_R101
_R102
_R103
_R104
_R105
_R106
_R107
_R108
_R109
_R110
_R111
_R112
_R113
_R114
_R115
_R116
_R117
_R118
_R119
_R120
_R121
_R122
_R123
_R124
_R125
_R126
_R127
_R128
_R129
_R130
_R131
_R132
_R133
_R134
_R135
_R136
_R137
_R138
_R139
_R140
_R141
_R142
_R143
_R144
_R145
_R146
_R147
_R148
_R149
_R150
_R151
_R152
_R153
_R154
_R155
_R156
_R157
_R158
_R159
_R160
_R161
_R162
_R163
_R164
_R165
_R166
_R167
_R168
_R169
_R170
_R171
_R172
_R173
_R174
_R175
_R176
_R177
_R178
_R179
_R180
_R181
_R182
_R183
_R184
_R185
_R186
_R187
_R188
_R189
_R190
_R191
_R192
_R193
_R194
_R195
_R196
_R197
_R198
_R199
_R200
)INIT
.HELP = XEDHELP
vget (r1,r2,r3,r4,r5,r6,r7,r8,r9,r10)
vget (r11,r12,r13,r14,r15,r16,r17,r18,r19,r20)
vget (r21,r22,r23,r24,r25,r26,r27,r28,r29,r30)
vget (r31,r32,r33,r34,r35,r36,r37,r38,r39,r40)
vget (r41,r42,r43,r44,r45,r46,r47,r48,r49,r50)
vget (r51,r52,r53,r54,r55,r56,r57,r58,r59,r60)
vget (r61,r62,r63,r64,r65,r66,r67,r68,r69,r70)
vget (r71,r72,r73,r74,r75,r76,r77,r78,r79,r80)
vget (r81,r82,r83,r84,r85,r86,r87,r88,r89,r90)
vget (r91,r92,r93,r94,r95,r96,r97,r98,r99,r100)
vget (r101,r102,r103,r104,r105,r106,r107,r108,r109,r110)
vget (r111,r112,r113,r114,r115,r116,r117,r118,r119,r120)
vget (r121,r122,r123,r124,r125,r126,r127,r128,r129,r130)
vget (r131,r132,r133,r134,r135,r136,r137,r138,r139,r140)
vget (r141,r142,r143,r144,r145,r146,r147,r148,r149,r150)
vget (r151,r152,r153,r154,r155,r156,r157,r158,r159,r160)
vget (r161,r162,r163,r164,r165,r166,r167,r168,r169,r170)
vget (r171,r172,r173,r174,r175,r176,r177,r178,r179,r180)
vget (r181,r182,r183,r184,r185,r186,r187,r188,r189,r190)
vget (r191,r192,r193,r194,r195,r196,r197,r198,r199,r200)
vget (cursor,csrpos)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'R1'
 .csrpos = 1
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (r1,r2,r3,r4,r5,r6,r7,r8,r9,r10)
vput (r11,r12,r13,r14,r15,r16,r17,r18,r19,r20)
vput (r21,r22,r23,r24,r25,r26,r27,r28,r29,r30)
vput (r31,r32,r33,r34,r35,r36,r37,r38,r39,r40)
vput (r41,r42,r43,r44,r45,r46,r47,r48,r49,r50)
vput (r51,r52,r53,r54,r55,r56,r57,r58,r59,r60)
vput (r61,r62,r63,r64,r65,r66,r67,r68,r69,r70)
vput (r71,r72,r73,r74,r75,r76,r77,r78,r79,r80)
vput (r81,r82,r83,r84,r85,r86,r87,r88,r89,r90)
vput (r91,r92,r93,r94,r95,r96,r97,r98,r99,r100)
vput (r101,r102,r103,r104,r105,r106,r107,r108,r109,r110)
vput (r111,r112,r113,r114,r115,r116,r117,r118,r119,r120)
vput (r121,r122,r123,r124,r125,r126,r127,r128,r129,r130)
vput (r131,r132,r133,r134,r135,r136,r137,r138,r139,r140)
vput (r141,r142,r143,r144,r145,r146,r147,r148,r149,r150)
vput (r151,r152,r153,r154,r155,r156,r157,r158,r159,r160)
vput (r161,r162,r163,r164,r165,r166,r167,r168,r169,r170)
vput (r171,r172,r173,r174,r175,r176,r177,r178,r179,r180)
vput (r181,r182,r183,r184,r185,r186,r187,r188,r189,r190)
vput (r191,r192,r193,r194,r195,r196,r197,r198,r199,r200)
vput (pfkey,cursor)
)END
>Panel XEDITRNG
)PANEL KEYLIST(XEDITREC,XED4)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITRNG                                       **/
/**                                                                  **/
/** Creation date   : June, 1997                                     **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display the datasets in the XEDIT-ring         **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 | AREA(SCRL)
 _ TYPE(INPUT) COLOR(GREEN) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
)BODY WINDOW(50,22) CMD() SMSG(MSG) LMSG(MSG)
~XEDIT ring
|RING                                           |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
@MSG
~ENTER=Select  F3=Return  F7=Backward  F8=Forward
)AREA RING
_R1
_R2
_R3
_R4
_R5
_R6
_R7
_R8
_R9
_R10
_R11
_R12
_R13
_R14
_R15
_R16
_R17
_R18
_R19
_R20
_R21
_R22
_R23
_R24
_R25
_R26
_R27
_R28
_R29
_R30
_R31
_R32
_R33
_R34
_R35
_R36
_R37
_R38
_R39
_R40
_R41
_R42
_R43
_R44
_R45
_R46
_R47
_R48
_R49
_R50
_R51
_R52
_R53
_R54
_R55
_R56
_R57
_R58
_R59
_R60
_R61
_R62
_R63
_R64
_R65
_R66
_R67
_R68
_R69
_R70
_R71
_R72
_R73
_R74
_R75
_R76
_R77
_R78
_R79
_R80
_R81
_R82
_R83
_R84
_R85
_R86
_R87
_R88
_R89
_R90
_R91
_R92
_R93
_R94
_R95
_R96
_R97
_R98
_R99
_R100
_R101
_R102
_R103
_R104
_R105
_R106
_R107
_R108
_R109
_R110
_R111
_R112
_R113
_R114
_R115
_R116
_R117
_R118
_R119
_R120
_R121
_R122
_R123
_R124
_R125
_R126
_R127
_R128
_R129
_R130
_R131
_R132
_R133
_R134
_R135
_R136
_R137
_R138
_R139
_R140
_R141
_R142
_R143
_R144
_R145
_R146
_R147
_R148
_R149
_R150
_R151
_R152
_R153
_R154
_R155
_R156
_R157
_R158
_R159
_R160
_R161
_R162
_R163
_R164
_R165
_R166
_R167
_R168
_R169
_R170
_R171
_R172
_R173
_R174
_R175
_R176
_R177
_R178
_R179
_R180
_R181
_R182
_R183
_R184
_R185
_R186
_R187
_R188
_R189
_R190
_R191
_R192
_R193
_R194
_R195
_R196
_R197
_R198
_R199
_R200
)INIT
.HELP = XEDHELP
vget (r1,r2,r3,r4,r5,r6,r7,r8,r9,r10)
vget (r11,r12,r13,r14,r15,r16,r17,r18,r19,r20)
vget (r21,r22,r23,r24,r25,r26,r27,r28,r29,r30)
vget (r31,r32,r33,r34,r35,r36,r37,r38,r39,r40)
vget (r41,r42,r43,r44,r45,r46,r47,r48,r49,r50)
vget (r51,r52,r53,r54,r55,r56,r57,r58,r59,r60)
vget (r61,r62,r63,r64,r65,r66,r67,r68,r69,r70)
vget (r71,r72,r73,r74,r75,r76,r77,r78,r79,r80)
vget (r81,r82,r83,r84,r85,r86,r87,r88,r89,r90)
vget (r91,r92,r93,r94,r95,r96,r97,r98,r99,r100)
vget (r101,r102,r103,r104,r105,r106,r107,r108,r109,r110)
vget (r111,r112,r113,r114,r115,r116,r117,r118,r119,r120)
vget (r121,r122,r123,r124,r125,r126,r127,r128,r129,r130)
vget (r131,r132,r133,r134,r135,r136,r137,r138,r139,r140)
vget (r141,r142,r143,r144,r145,r146,r147,r148,r149,r150)
vget (r151,r152,r153,r154,r155,r156,r157,r158,r159,r160)
vget (r161,r162,r163,r164,r165,r166,r167,r168,r169,r170)
vget (r171,r172,r173,r174,r175,r176,r177,r178,r179,r180)
vget (r181,r182,r183,r184,r185,r186,r187,r188,r189,r190)
vget (r191,r192,r193,r194,r195,r196,r197,r198,r199,r200)
vget (cursor,csrpos)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'R1'
 .csrpos = 1
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (cmd,pfkey,cursor,csrpos)
)END
>Panel XEDITTAG
)PANEL KEYLIST(XEDITREC,XED4)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITTAG                                       **/
/**                                                                  **/
/** Creation date   : Februari, 2000                                 **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 2000                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display the last 99 xedit tags.                **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 % TYPE(TEXT) COLOR(WHITE) INTENS(HIGH)
 | AREA(SCRL)
 _ TYPE(INPUT) COLOR(GREEN) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
)BODY WINDOW(76,22) CMD() SMSG(MSG) LMSG(MSG)
~XEDIT tags
%Tag   Line Text at line
|TAGS                                                                     |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
|                                                                         |
@MSG
~ENTER=Select  F3=Return  F7=Backward  F8=Forward
)AREA TAGS
_R1
_R2
_R3
_R4
_R5
_R6
_R7
_R8
_R9
_R10
_R11
_R12
_R13
_R14
_R15
_R16
_R17
_R18
_R19
_R20
_R21
_R22
_R23
_R24
_R25
_R26
_R27
_R28
_R29
_R30
_R31
_R32
_R33
_R34
_R35
_R36
_R37
_R38
_R39
_R40
_R41
_R42
_R43
_R44
_R45
_R46
_R47
_R48
_R49
_R50
_R51
_R52
_R53
_R54
_R55
_R56
_R57
_R58
_R59
_R60
_R61
_R62
_R63
_R64
_R65
_R66
_R67
_R68
_R69
_R70
_R71
_R72
_R73
_R74
_R75
_R76
_R77
_R78
_R79
_R80
_R81
_R82
_R83
_R84
_R85
_R86
_R87
_R88
_R89
_R90
_R91
_R92
_R93
_R94
_R95
_R96
_R97
_R98
_R99
)INIT
.HELP = XEDHELP
vget (r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16,r17,r18,r19,r20)
vget (r21,r22,r23,r24,r25,r26,r27,r28,r29,r30)
vget (r31,r32,r33,r34,r35,r36,r37,r38,r39,r40)
vget (r41,r42,r43,r44,r45,r46,r47,r48,r49,r50)
vget (r51,r52,r53,r54,r55,r56,r57,r58,r59,r60)
vget (r61,r62,r63,r64,r65,r66,r67,r68,r69,r70)
vget (r71,r72,r73,r74,r75,r76,r77,r78,r79,r80)
vget (r81,r82,r83,r84,r85,r86,r87,r88,r89,r90)
vget (r91,r92,r93,r94,r95,r96,r97,r98,r99)
vget (cursor,csrpos)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'R1'
 .csrpos = 1
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16,r17,r18,r19,r20)
vput (r21,r22,r23,r24,r25,r26,r27,r28,r29,r30)
vput (r31,r32,r33,r34,r35,r36,r37,r38,r39,r40)
vput (r41,r42,r43,r44,r45,r46,r47,r48,r49,r50)
vput (r51,r52,r53,r54,r55,r56,r57,r58,r59,r60)
vput (r61,r62,r63,r64,r65,r66,r67,r68,r69,r70)
vput (r71,r72,r73,r74,r75,r76,r77,r78,r79,r80)
vput (r81,r82,r83,r84,r85,r86,r87,r88,r89,r90)
vput (r91,r92,r93,r94,r95,r96,r97,r98,r99)
vput (cmd,pfkey,cursor,csrpos)
)END
>Panel XEDITVAR
)PANEL KEYLIST(XEDIT,XED1)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITVAR                                       **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Display fields in a file define by VARIABLE    **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 | AREA(SCRL)
 _ TYPE(INPUT) COLOR(GREEN) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(OUTPUT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 % TYPE(OUTPUT) COLOR(BLUE) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 @ TYPE(OUTPUT) COLOR(YELLOW) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 $ TYPE(INPUT) COLOR(YELLOW) HILITE(USCORE) INTENS(HIGH) CAPS(OFF)
)BODY WINDOW(76,22) CMD() SMSG(MSG) LMSG(MSG)
~Variable                 Value         &lines
%V1                      ^W1
%V2                      ^W2
%V3                      ^W3
%V4                      ^W4
%V5                      ^W5
%V6                      ^W6
%V7                      ^W7
%V8                      ^W8
%V9                      ^W9
%V10                     ^W10
%V11                     ^W11
%V12                     ^W12
%V13                     ^W13
%V14                     ^W14
%V15                     ^W15
%V16                     ^W16
%V17                     ^W17
%V18                     ^W18
%V19                     ^W19
@MSG
~F3=Return  F7=Backward  F8=Forward  F9=Top F11=Bottom  F12=Cancel
)INIT
.HELP = XEDHELP
vget (v1,v2,v3,v4,v5,v6,v7,v8,v9,v10)
vget (v11,v12,v13,v14,v15,v16,v17,v18,v19)
vget (w1,w2,w3,w4,w5,w6,w7,w8,w9,w10)
vget (w11,w12,w13,w14,w15,w16,w17,w18,w19)
 
vget (cursor,csrpos)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'W1'
 .csrpos = 1
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (pfkey,cursor)
)END
>Panel XEDITX
)PANEL KEYLIST(XEDITX,XED3)
/**********************************************************************/
/**                                                                  **/
/** Classification  : IBM internal use only                          **/
/**                                                                  **/
/** Panelname       : XEDITX                                         **/
/**                                                                  **/
/** Creation date   : August, 1994                                   **/
/** Author          : George van der Klauw                           **/
/** Modificator(s)  :                                                **/
/**                                                                  **/
/** Copyright       : (c) Copyright IBM corp 1994                    **/
/**                   LICENSED MATERIAL - PROGRAM PROPERTY OF IBM    **/
/**                   REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER    **/
/**                   G120-2083                                      **/
/**                                                                  **/
/** Function        : Allow the user to specify a dataset to edit    **/
/**                                                                  **/
/** Operating System: MVS, ISPF                                      **/
/**                                                                  **/
/** Modifications   :                                                **/
/** dd/mm/yy By   Code    Description                                **/
/** ======== ==== ======= ========================================== **/
/** dd/mm/yy XvdY xxxxxxx Fix a bug                                  **/
/**********************************************************************/
)ATTR DEFAULT($¢_) FORMAT(MIX)
 ~ TYPE(TEXT) COLOR(WHITE) INTENS(HIGH) HILITE(REVERSE)
 | AREA(SCRL)
 _ TYPE(INPUT) COLOR(WHITE) INTENS(HIGH) CAPS(ON) HILITE(USCORE)
 $ TYPE(OUTPUT) COLOR(WHITE) INTENS(HIGH) CAPS(OFF)
 ^ TYPE(TEXT) COLOR(GREEN) INTENS(LOW) CAPS(OFF) JUST(ASIS) SKIP(ON)
 @ TYPE(TEXT) COLOR(BLUE) INTENS(LOW) CAPS(OFF) JUST(ASIS)
 \ TYPE(TEXT) COLOR(TURQ) INTENS(LOW) CAPS(OFF) JUST(ASIS)
)BODY WINDOW(74,12) CMD() SMSG(MSG) LMSG(MSG)
~Specify dataset to edit
^
@ISPF library
^  Project . ._xxpro   ^
^  Group . . ._xxgr1   ^ or _xxgr2   ^ or _xxgr3   ^ or _xxgr4   ^
^  Type  . . ._xxtyp   ^
^  Member  . ._xxmem   \ (blank or pattern for member selection list)
^
@Other partitioned or sequential data set
^  Data set  ._xxdst                                       \
$MSG
~ENTER=Process F3=Return
)INIT
.HELP = XEDHELP
vget (cursor,csrpos)
vget (xxpro xxgr1 xxgr2 xxgr3 xxgr4 xxtyp xxmem xxdst msg)
If (&cursor ^= '')
 .cursor = &cursor
 .csrpos = &csrpos
else
 .cursor = 'XXMEM'
 .csrpos = 1
)PROC
&pfkey = .pfkey
&cursor = .cursor
&csrpos = .csrpos
vput (xxpro xxgr1 xxgr2 xxgr3 xxgr4 xxtyp xxmem xxdst)
vput (pfkey,cursor,csrpos)
)END
>Msg XEDI00
XEDI001 .HELP=XEDHELP
'&XeditMsg'
>Skel XED1KEYS
 àTIR:  	&XED1KEYS ñØ 7Ø  Ç  ç   nênêI095C              ° KEYLIS
TN 	 âKEY1DEF   4KEY1LAB   KEY1ATR   KEY2DEF   KEY2LA
B   éKEY2ATR   ßKEY3DEF   ;KEY3LAB   fKEY3ATR   þKEY4DE
F   lKEY4LAB   ¨KEY4ATR   CKEY5DEF   HKEY5LAB   0KEY5AT
R   8KEY6DEF   ÙKEY6LAB   KEY6ATR   KEY7DEF   KEY7LA
B   !KEY7ATR   ÂKEY8DEF   ÅKEY8LAB   ±KEY8ATR   pKEY9DE
F   æKEY9LAB   DKEY9ATR   öKEY10DEF  JKEY10LAB  9KEY10A
TR  KEY11DEF  KEY11LAB  KEY11ATR  KEY12DEF  KEY12L
AB  ÄKEY12ATR  ,KEY13DEF  øKEY13LAB  qKEY13ATR  µKEY14D
EF  vKEY14LAB  òKEY14ATR  NKEY15DEF  ¹KEY15LAB   KEY15A
TR   KEY16DEF   KEY16LAB   KEY16ATR   KEY17DEF   àKEY17L
AB   %KEY17ATR   ÈKEY18DEF   `KEY18LAB   ~KEY18ATR   zKEY19D
EF   ÞKEY19LAB   OKEY19ATR   úKEY20DEF   TKEY20LAB   KEY20A
TR   KEY21DEF   KEY21LAB    KEY21ATR   çKEY22DEF   (KEY22L
AB   ÍKEY22ATR   'KEY23DEF   bKEY23LAB   ¡KEY23ATR   ¥KEY24D
EF   ¼KEY24LAB   ÿKEY24ATR   X   ¢ ¡ £ ¶ ¨ × D I ò K P û \ V Z Ó
 3 7 Ü	âå.&íß;ÄÅ%ÉÍ:"chýjoº¤uz
[¥¼¨{EIóLPü÷V²Õ3Ù 	XEDIT END END NO END END NO END 
END NO END END NO END END NO END END NO END END NO END END NO E
ND END NO END END NO END END NO END END NO END END NO END END N
O END END NO END END NO END END NO END END NO END END NO END EN
D NO END END NO END END NO END END NO RETRIEVE RETRIEVE NOKEYHELPN
                                                                                
>Skel XED2KEYS
 àTIR:  °	&XED2KEYS ñØ 7Ø  0  ç   n¤ân¤âI095C              ° KEYLIS
TN  âKEY1DEF   4KEY1LAB   KEY1ATR   KEY2DEF    KEY2LA
B    éKEY2ATR    ßKEY3DEF   ;KEY3LAB   fKEY3ATR   þKEY4DE
F    lKEY4LAB    ¨KEY4ATR    CKEY5DEF    HKEY5LAB    0KEY5AT
R    8KEY6DEF    ÙKEY6LAB    KEY6ATR    KEY7DEF    KEY7LA
B    !KEY7ATR    ÂKEY8DEF    ÅKEY8LAB    ±KEY8ATR    pKEY9DE
F    æKEY9LAB    DKEY9ATR    öKEY10DEF   JKEY10LAB   9KEY10A
TR   KEY11DEF   KEY11LAB   KEY11ATR   KEY12DEF  KEY12L
AB  ÄKEY12ATR  ,KEY13DEF  øKEY13LAB  qKEY13ATR  µKEY14D
EF 	 vKEY14LAB 	 òKEY14ATR  NKEY15DEF  ¹KEY15LAB   KEY15A
TR   KEY16DEF    KEY16LAB    KEY16ATR    KEY17DEF    àKEY17L
AB    %KEY17ATR    ÈKEY18DEF    `KEY18LAB    ~KEY18ATR    zKEY19D
EF    ÞKEY19LAB    OKEY19ATR    úKEY20DEF    TKEY20LAB    KEY20A
TR    KEY21DEF   KEY21LAB    KEY21ATR   çKEY22DEF    (KEY22L
AB    ÍKEY22ATR    'KEY23DEF    bKEY23LAB    ¡KEY23ATR    ¥KEY24D
EF   ¼KEY24LAB   ÿKEY24ATR   X  µ ¢« ¡ © Ý { D F H ­ õ M Q ¹ ü ú \
 S U W Y ² Ö Ó 0 2 4 6 8 ³ Ü Ú âãç¢<+&êèî
ì!*;-ÂÀ¦øÈÎÌ:@=Øe«þ XEDITCNF HELP HELP NO       END END
 NO                                                 END END NO HELP HELP 
NO 	SPLIT 	SPLIT NO END END NO                               SWAP SWAP NO
             END END NOKEYHELPN                                             
>Skel XED3KEYS
 àTIR:  °	&XED3KEYS ñØ 7Ø  0  ç   n¤ên¤êI095C              ° KEYLIS
TN  âKEY1DEF   4KEY1LAB   KEY1ATR   KEY2DEF    KEY2LA
B    éKEY2ATR    ßKEY3DEF   ;KEY3LAB   fKEY3ATR   þKEY4DE
F    lKEY4LAB    ¨KEY4ATR    CKEY5DEF   HKEY5LAB   0KEY5AT
R   8KEY6DEF    ÙKEY6LAB    KEY6ATR    KEY7DEF    KEY7LA
B    !KEY7ATR    ÂKEY8DEF    ÅKEY8LAB    ±KEY8ATR    pKEY9DE
F    æKEY9LAB    DKEY9ATR    öKEY10DEF   JKEY10LAB   9KEY10A
TR   KEY11DEF   KEY11LAB   KEY11ATR   KEY12DEF  KEY12L
AB  ÄKEY12ATR  ,KEY13DEF  øKEY13LAB  qKEY13ATR  µKEY14D
EF 	 vKEY14LAB 	 òKEY14ATR  NKEY15DEF  ¹KEY15LAB   KEY15A
TR   KEY16DEF    KEY16LAB    KEY16ATR    KEY17DEF    àKEY17L
AB    %KEY17ATR    ÈKEY18DEF    `KEY18LAB    ~KEY18ATR    zKEY19D
EF    ÞKEY19LAB    OKEY19ATR    úKEY20DEF    TKEY20LAB    KEY20A
TR    KEY21DEF   KEY21LAB    KEY21ATR   çKEY22DEF    (KEY22L
AB    ÍKEY22ATR    'KEY23DEF    bKEY23LAB    ¡KEY23ATR    ¥KEY24D
EF   ¼KEY24LAB   ÿKEY24ATR   X  µ ¢« ¡ ¥ ½ ´ B D F H ò K O Q ¹ ü ÷
 W ² Ö Ó 0 2 4 6 8 ³ Ü Ú äç<+&êèîì!*
;-ÂÀÃÇ¦øÎ:@=Øbdf»°m XEDITX HELP HELP NO       END END 
NO       END END NO                                     END END NO HELP 
HELP NO 	SPLIT 	SPLIT NO END END NO                               SWAP SW
AP NO             END END NOKEYHELPN                                       
>Skel XED4KEYS
 àTIR:  °	&XED4KEYS ñØ 7Ø    ç   n¤ n¤I095C              ° KEYLIS
TN  âKEY1DEF   4KEY1LAB   KEY1ATR   KEY2DEF    KEY2LA
B    éKEY2ATR    ßKEY3DEF   ;KEY3LAB   fKEY3ATR   þKEY4DE
F    lKEY4LAB    ¨KEY4ATR    CKEY5DEF   HKEY5LAB   0KEY5AT
R   8KEY6DEF    ÙKEY6LAB    KEY6ATR    KEY7DEF   KEY7LA
B   !KEY7ATR   ÂKEY8DEF   ÅKEY8LAB   ±KEY8ATR   pKEY9DE
F    æKEY9LAB    DKEY9ATR    öKEY10DEF   JKEY10LAB   9KEY10A
TR   KEY11DEF   KEY11LAB   KEY11ATR   KEY12DEF  KEY12L
AB  ÄKEY12ATR  ,KEY13DEF  øKEY13LAB  qKEY13ATR  µKEY14D
EF   vKEY14LAB   òKEY14ATR   NKEY15DEF  ¹KEY15LAB   KEY15A
TR   KEY16DEF    KEY16LAB    KEY16ATR    KEY17DEF   àKEY17L
AB   %KEY17ATR   ÈKEY18DEF    `KEY18LAB    ~KEY18ATR    zKEY19D
EF   ÞKEY19LAB   OKEY19ATR   úKEY20DEF   TKEY20LAB   KEY20A
TR   KEY21DEF    KEY21LAB     KEY21ATR    çKEY22DEF    (KEY22L
AB    ÍKEY22ATR    'KEY23DEF    bKEY23LAB    ¡KEY23ATR    ¥KEY24D
EF   ¼KEY24LAB   ÿKEY24ATR   X  ½ ¢s ¡ © Ý { D F H ­ õ M Q ¹ ü ú T
 Y Ö Ó 0 2 6 ³ Ú âàñ+êèîì)ÂÃÇ¦
%øÈÌ=dh«ðþ°kmoqª¤uy XEDITREC HELP HELP NO       END END
 NO       END END NO       UP UP NO DOWN DOWN NO                   EN
D END NO HELP HELP NO       END END NO       END END NO       UP UP
 NO DOWN DOWN NO                   END END NOKEYHELPN                   
>Skel XED5KEYS
 àTIR:  °	&XED5KEYS ñØ 7Ø  Y  ç   n¤n¤I095C              ° KEYLIS
TN  âKEY1DEF   4KEY1LAB   KEY1ATR   KEY2DEF    KEY2LA
B    éKEY2ATR    ßKEY3DEF   ;KEY3LAB   fKEY3ATR   þKEY4DE
F    lKEY4LAB    ¨KEY4ATR    CKEY5DEF    HKEY5LAB    0KEY5AT
R    8KEY6DEF    ÙKEY6LAB    KEY6ATR    KEY7DEF    KEY7LA
B    !KEY7ATR    ÂKEY8DEF    ÅKEY8LAB    ±KEY8ATR    pKEY9DE
F    æKEY9LAB    DKEY9ATR    öKEY10DEF   JKEY10LAB   9KEY10A
TR   KEY11DEF   KEY11LAB   KEY11ATR   KEY12DEF  KEY12L
AB  ÄKEY12ATR  ,KEY13DEF  øKEY13LAB  qKEY13ATR  µKEY14D
EF   vKEY14LAB   òKEY14ATR   NKEY15DEF  ¹KEY15LAB   KEY15A
TR   KEY16DEF    KEY16LAB    KEY16ATR    KEY17DEF    àKEY17L
AB    %KEY17ATR    ÈKEY18DEF    `KEY18LAB    ~KEY18ATR    zKEY19D
EF    ÞKEY19LAB    OKEY19ATR    úKEY20DEF    TKEY20LAB    KEY20A
TR    KEY21DEF    KEY21LAB     KEY21ATR    çKEY22DEF    (KEY22L
AB    ÍKEY22ATR    'KEY23DEF    bKEY23LAB    ¡KEY23ATR    ¥KEY24D
EF   ¼KEY24LAB   ÿKEY24ATR   X  q ¢b ¡ · ¾ × C E G I õ N R û ù ÿ ÷
 T V X Z Ô Ò Õ 1 3 5 7 9 Û Ù 	äáåñ.(|éë
íïß$)^/ÄÁÅÑ,_?ÉË#cg XEDHELP HELP HELP NO       EXIT EXI
T NO                                                 CANCEL CANCEL NO HELP 
HELP NO       EXIT EXIT NO                                                 
CANCEL CANCEL NOKEYHELPN                                                    
>Skel XED6KEYS
 àTIR:  °	&XED6KEYS ñØ 5Ø  8  ç   n¤n¤ñI095C            ° KEYLIS
TN  âKEY1DEF    4KEY1LAB    KEY1ATR    KEY2DEF    KEY2LA
B    éKEY2ATR    ßKEY3DEF   ;KEY3LAB   fKEY3ATR   þKEY4DE
F    lKEY4LAB    ¨KEY4ATR    CKEY5DEF    HKEY5LAB    0KEY5AT
R    8KEY6DEF    ÙKEY6LAB    KEY6ATR    KEY7DEF   KEY7LA
B   !KEY7ATR   ÂKEY8DEF  	 ÅKEY8LAB  	 ±KEY8ATR   pKEY9DE
F    æKEY9LAB    DKEY9ATR    öKEY10DEF   JKEY10LAB   9KEY10A
TR   KEY11DEF   KEY11LAB   KEY11ATR   KEY12DEF  KEY12L
AB  ÄKEY12ATR  ,KEY13DEF   øKEY13LAB   qKEY13ATR   µKEY14D
EF   vKEY14LAB   òKEY14ATR   NKEY15DEF   ¹KEY15LAB    KEY15A
TR    KEY16DEF    KEY16LAB    KEY16ATR    KEY17DEF    àKEY17L
AB    %KEY17ATR    ÈKEY18DEF    `KEY18LAB    ~KEY18ATR    zKEY19D
EF   ÞKEY19LAB   OKEY19ATR   úKEY20DEF 	  TKEY20LAB 	  KEY20A
TR   KEY21DEF    KEY21LAB     KEY21ATR    çKEY22DEF    (KEY22L
AB    ÍKEY22ATR    'KEY23DEF    bKEY23LAB    ¡KEY23ATR    ¥KEY24D
EF   ¼KEY24LAB   ÿKEY24ATR   X µ y ¢k ¡ © ¶ ½ Ý ¯ ´ { H } M O Q ¹ ü
 ú \ S U W Ö 2 6 Ù âàãç¢<+&
êì;ÂÑøÈÎÌ:@=Øbdfþoª XEDHELP1             CANCEL CANCEL NO
                   LEFT LEFT NO 	RIGHT 	RIGHT NO                   CANCEL 
CANCEL NO                                     LEFT LEFT NO 	RIGHT 	RIGHT NO
                   CANCEL CANCEL NOKEYHELPN                                 
>END */
