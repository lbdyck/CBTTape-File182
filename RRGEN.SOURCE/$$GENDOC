GENERAL

a. RRGEN was developed in the early 1970's at USA RCPAC, St. Louis, MO
(SHARE installation code URV).  RRGEN translates program instructions
and creates IBM System/360 machine instructions in memory before passing
control to them for execution.  The results of most RRGEN instructions
are stored in the second operand (B-address).  The exception to this
is the System Programmer instructions which operate as documented in
the IBM System/360 Principles of Operation.

b. The program instructions of an RRGEN program usually reside in-
stream with other JCL (job control language) statements and are
accessed via the SYSIN DD statement.  However, these instructions can
be also defined as a member of a partitioned data set and referenced
using that data set name.

c. Each RRGEN program must have at least one input file.  The file can
be defined using either the CARD DD statement or the INPx statement(s)
(See paragraph 3.3 below).

d. There is a PROCedure available which EXECutes program RRGEN5.
Included in the PROC are the JCL DD statements for STEPLIB,
SYSUDUMP, SYSOUT, and PRINT.

REQUIRED JCL STATEMENTS
STATEMENT                   PURPOSE
(REQ)    JOB                Initiates the job.
(REQ)    EXEC               Specifies the program name, PGM=RRGENx,
                            where   x is the version number.
(REQ)    SYSOUT DD          Defines a sequential data set used for listing
                            RRGEN instructions and associated generated
                            machine instructions or error messages.     It
                            also includes total number of records read or
                            written for each data set.
 *       INP1/2/3 DD        Defines an input data set.  This can include a
                            sequential data set (PS/PDS), an index
                            sequential data set (IS), or a direct data set
                            (DA).
 *       CARD DD            Specifies input from a card reader only.

 *       NOTE: One of these DDname statements must be used to specify
               the input data set.

(OPT)    OUT1/2/3 DD        Defines an output data set.   It can include
                            a sequential data set (PS/PDS), an index
                            index sequential data set (IS), or a direct
                            data set (DA).
(OPT)    PRINT DD           Defines an output data set being written to a
                            printer.
(OPT)    SORTLIB DD         Defines a data set that contains sort/
                            merge program modules.
(OPT)    SORTWK01 DD        Defines intermediate storage data sets
         SORTWK02 DD        used by a sort program.
         SORTWK03 DD

(REQ)    SYSIN DD           Defines the instruction data set.  The
                            instruction data set normally resides in the
                            input stream; however, it can be defined as a
                            member of a partitioned data set.

EXAMPLE:
----+----1----+----2----+----3----+----4----+----5
//STEP01   EXEC  RRGEN
//OUT1     DD  DSN=DARGTE.UES.GTE3101,UNIT=DISK,
//             DISP=(,CATLG,DELETE),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=6080),
//             SPACE=(TRK,(5,5),RLSE)
//CARD      DD *
.
input data (80-column records)
.
/*
//SYSIN     DD *
.
RRGEN instructions
.
/*

PROCedure RRGEN
a. Below are the JCL statements contained in the PROC named RRGEN.

----+----1----+----2----+----3----+----4----+----5
//RRGEN    PROC  RPTNAME='*'
//RRGEN    EXEC  PGM=RRGEN,REGION=128K
//STEPLIB  DD  DSN=SSO.RRGEN.LOAD.DISP=SHR
//SYSUDUMP DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//PRINT    DD  SYSOUT=&RPTNAME

REQUIRED FORMAT FOR INSTRUCTIONS
a. There can be five parts to an RRGEN instruction.  These five parts are
described in detail below.  All instructions must contain an Operation.
Generally, most RRGEN instructions will require at least an Operation and
an Address (Exception: the EXIT instruction does not require an address).

(1) Location.  Provides a unique address (tag) to the line of coding
or indicates a comment statement if an asterisk (*) appears in
column 1.  Valid tags are TG0l thru TG99.  Tags are always coded
in column 1 thru column 4.    (See example below)

(2) Operation.  This entry is used to designate a programming
instruction or an I/O macro.  The Operation is always coded in
column 7 thru column 11.      (See example below)

(3) Size. This entry is used to designate a count for the
programming instruction appearing in the Operation field.  When
used, Size is always coded beginning in column 13. (Example
below)

(4) Address.  This field is used for A or B addresses of
programming instructions.  A Address should be coded beginning
in column 20; B Address should be coded beginning in column 25.
If A or B addresses contain SELF, columns 34 thru 73 are used for
the contents of the SELF constant.  If there is a B Address, it must
be preceded by a comma in column 24.  (See example below)

(5) Constants or Remarks.     Self explanatory.

(6) Sample coding:

 1      2      3        4                   5
LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
 * READ AND WRITE CARDS
TG01  READ         CARD,EOJ
      MOVE  80     CD00,J000
      MOVE  3      SELF,J080     JOE
      WRITE        OUT1
      GO           TG01

AREA ADDRESS
Refer to the section in this chapter which shows the assigned
addresses for all available records or work areas.

STORAGE OF CONSTANT DATA
a. Storage of Constant data. There are two storage areas assigned to
hold constant data: SELF and the Constant Area (positions 0000-1999).

b. SELF. The SELF storage area is used by the program to store
constants which are used in the execution of the instruction.

       (1) Sample coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CONS  3      0000          000
      ADD   3      SELF,0000     001

      NOTE: The ADD instruction above would be read as:
      Add the 3-digit number stored at address 0000 to the
      3-digit number stored in the address SELF. The
      contents of SELF are defined in the constant area of
      the same line of code as the instruction being
      executed.

c. The Constant Area. The Constant Area from 0000-1999 is initialized to
blanks prior to storage of constant data supplied via the CONS or XCON
parameters.   Detailed descriptions of the CONS and XCON parameters
follow.

(1) CONS. This parameter is used to store character constants.
No object code is generated.

       FORMAT:
       Operation =  CONS
       Size      =  Size of constant(Max 40 bytes)
       A Address =  LHE address of area to receive constant
                    (0000-1999)
       CC 34-73  =  Constant data

       (a) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CONS  3      0000          123
      CONS  4      0003          ABCD

(2) XCONS.    This parameter is used to store hexadecimal
constants.   The hexadecimal digits, (0-9 and A-F), are converted to
one byte per pair of digits. No object code is generated.

       FORMAT:
       Operation  =  XCONS
       Size       =  Size of constant (max 20 bytes)
       A Address  =  LHE address of area to receive
                     constant (0000-1999)
       CC 34-74   =  Hexadecimal digits

       (a) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      XCONS 3      1000          F1F2F3
      XCONS 4      1003          C1C2C3C4

Acceptable Branch Addresses
a. Acceptable addresses are TG0l through TG99, EOJ, and SORT, if the
sort has been CALLed. A branch to EOJ will close all files and terminate
the program.

RTCD (Return Code)
a. The return code can be set or tested by either MOVEing to or
COMparing against the RTCD field.  The field is initialized to zero. The
maximum value is 4095.  A size of four (4) should be used when  moving
to or comparing against the RTCD field.  Appendix B of this Section
contains a table which shows standard RRGEN return code meanings.

b. Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      MOVE  4      SELF,RTCD     0016
      GO           EOJ

INSTRUCTION SET

a. READ (Sequential). The READ sequential macro instruction obtains the
next record from a Physical Sequential (PS) or a Partitioned Data Set
(PDS).  Transfer of control to B operand will take place when the end of
the data set is reached.

       (1) FORMAT:
           Operation = READ
           Size      = blank
           A Address = ddname (CARD, INP1, INP2 or INP3)
           B Address = Valid TAG or EOJ

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      READ         INP1,TG01


b. READ (Index sequential). The READ index sequential macro instruction
obtains records sequentially or randomly from index sequential data sets.
If a record is not found when processing randomly, the
corresponding record area will contain "NOHITb".  It is the programmer's
responsibility to check for this condition after each read.

       (1) FORMAT:
           Operation = READ
           Size      = IS if processing sequentially ISR if processing
                       randomly
           A Address = ddname (INP1, INP2 or INP3)
           B Address = Valid TAG or EOJ if processing sequentially;
                       Key Address if processing randomly (SELF not
                       valid).
       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      READ  IS     INP1,TG01     NOTE: TG01 = End of Data address
      READ  ISR    INP1,0000     NOTE: 0000 = Address of area containing the Key


c. READ (Direct). The READ direct macro instruction causes a data block
(max 4000 bytes) to be retrieved from a direct data set and placed into the
Work Area (2000-5999).  The associated Record Area (A000, B000, or
C000) must contain the Block Address (Relative track, relative block, or
actual device address - See OS Data Management Services Guide for
further details).  The programmer is responsible for any de-blocking that is
required, If DI is specified in the Size field, transfer of control to B operand
will take place if end-of-data is reached.    If DK is specified, and the
request Key cannot be found, the Work Area will contain "NOHITb".

       (1) FORMAT:
           Operation = READ
           Size      = DI specifies that data and a key, if any,
                       are to be read.   The address of the data
                       block to be read is contained in the Record
                       Area.  If a key exists, it will precede the data
                       block in the Work Area. DK specifies that data
                       only is to be read and that a key is to be used
                       as the search argument.  The search for the
                       key starts at the block address contained in the
                       record area.
           A Address = ddname (INP1, INP2 or INP3)
           B Address = Valid TAG or EOJ if DI is specified; Key
                       Address if DK is specified.

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CONS  3      0000          000
TG01  CVZB  3,3    0000A000      NOTE: Read entire file
      READ  DI     INP1,EOJ            by relative block
      ADD   3      SELF,0000     001   address
      GO           TG01
*
      READ  DK     INP1,0000     NOTE: 0000 = Address of
      COM   6      2000,SELF     NOHIT area containing the key


d. WRITE.  The WRITE macro is used to place a record into an output
data set.  WRITE can be used to: (1) create a Physical Sequential (PS)
data set, (2) add a member to a Partitioned data set (PDS), (3) create an
Direct data set (DA).

       (1) FORMAT:
           Operation   =  WRITE
           Size        =  IS if an index sequential data set is to be
                          created.
                          DA if a direct data set is to be created.
                          blank if a sequential or partitioned data set
                          is to be created.
           A Address   =  ddname (OUT1, OUT2 or OUT3)
           B Address   =  not used

       (2) NOTE: If a Direct data set is being created, the programmer is
       responsible for any blocking that is required (record area does not
       exist for DA data sets).  The Work Area (2000-5999) is used for the
       block area.  If keys are used, the key must start in 2000 followed
       by the data block.

       (3) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      WRITE IS     OUT1
      WRITE DA     OUT2
      WRITE        OUT3


e. GO (Unconditional Branch).  This instruction causes an unconditional
break in the normal sequence of performed instructions.  Control is
transferred to the specified TAG.
       (1) FORMAT:
           Operation = GO
           Size      = not used
           A Address = Tag representing the next instruc tion to
                       be executed (TG01 thru TG99, EOJ, or SORT).
           B Address = not used

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      GO           TG01
      GO           EOJ


f. MOVE. This instruction transfers a specified number of consecutive
bytes from one area to another area.
       (1) FORMAT:
           Operation  =  MOVE
           Size       =  Number of bytes (1-900) to be transferred.
           A Address  =  Address of Sending area
           B Address  =  Address of Receiving area

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      MOVE   80    CD00,J000


g. COM (Compare).    This instruction is used to determine the relative
magnitude of two operands of equal length.
       (1) FORMAT:
           Operation = COM
           Size      = Number of bytes (1-256) to be compared.
           A Address = Address of first operand
           B Address = Address of second operand

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      COM   3      SELF,A000     JOE
      GE           TG03

NOTE:  > indicator set if A > B. (A high) < indicator set if A < B. (A
low) = indicator set if A = B. (A equal B) = indicator set if A = B. (A
not equal B)


h. Test COMPARE results. This instruction senses the indicators set by
the compare (COM) instruction and branches accordingly.

       (1) FORMAT:
           Operation  =  GE, GH, GL or GNE *
           Size       =  not used
           A Address  =  TG (tag) to go to if condition is true.
           B Address  =  not used

           GE (Go Equal)      go on A = B  (A equal B)
           GL (Go Low)        go on A < B  (A low)
           GH (Go High)       go on A > B  (A high)
           GNE (Go Not Equal) go on A = B  (A not equal B)

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      COM   3      A000,CD000
      GE           TG02
      GNE          TG01
      COM    2     A100,SELF     00
      GH           TG03
      GL           TG04


i. ADD. This instruction performs decimal addition on zoned decimal
operands.  The result is stored in the area originally occupied by the B
operand.  The two operands must be equal in length and may not exceed
16 bytes per operand.


       (1) FORMAT:
           Operation   =  ADD
           Size        =  Number of bytes (1-16) to be added.
           A Address   =  Address of the Addend (first of the numbers
                          being added)
           B Address   =  Address of the Augend (number added to first
                          number) and Sum (result of addition)

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      ADD   6      SELF,A003     000001


j. SUB. This instruction performs decimal subtraction on zoned decimal
operands.  The result is stored in the area originally occupied by the B
operand.  The two operands must be equal in length and may not exceed
 16 bytes per operand.
       (1) FORMAT:
           Operation   =  SUB
           Size        =  Number of bytes (1-16) to be subtract ed
           A Address   =  Address of the Subtrahend (first of the
                          numbers being subtracted)
           B Address   =  Address of the Minuend (number added to
                          first number) and Difference (result of
                          subtraction)
       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      SUB    5     SELF,CD00     00126


k. MPY. (Multiply).  This instruction performs decimal multiplication with
zoned decimal operands.      The product is right-justified in a 30-position
result area (RS00-RS29).
       (1) FORMAT:
           Operation   =  MPY
           Size        =  Number of bytes (1-15) in multiplier, a comma,
                          number of bytes (1-15) in multiplicand.
           A Address    = Address of Multiplier (number used to multiply
                          by).
           B Address    = Address of Multiplicand (number being
                          multiplied).

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CONS  7      0000          1234567
      MPY   2,7    SELF,0000     10
      MOVE  9      RS21,P0000

      NOTE: After execution of this instruction, P000=012345670


l. DVD (Divide).  This instruction performs decimal division with zoned
decimal operands.  The quotient is right-justified in the first 15 positions of
the Result Area (RS00-RS14) and the remainder is right-justified in the
last 15 positions of the Result Area (RS15-RS29).
       (1) FORMAT:
           Operation   =  DVD
           Size        =  Number of bytes (1-15) in divisor, a comma,
                          and number of bytes (1-15) in dividend.
           A Address   =  Address of Divisor (number used to divide by).
           B Address   =  Address of Dividend (number being divided).

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CONS  5      OUT1          45001
      DVD   2,5    SELF,0000     22
      MOVE  5      RS10,P000
      MOVE  2      RS28,P020

      NOTE: After execution of this instruction, P000=02045 P020=11


m. PRINT.    The PRINT instruction is used to print a record (ddname
PRINT).
       (1) FORMAT:
              Operation   = PRINT
              Size        =  not used
              A Address   =  SKIP0, SKIP1, SKIP2, SKIP3 or CHANxx
                            (where xx = Channel Number 01 thru 12)
              B Address   =  not used

       NOTE:  Spacing takes place after printing.

       (2). Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      PRINT        SKIP2
      PRINT        CHAN01


n. CALL. The CALL macro instruction causes control to be passed to a
specified load module.  The load module containing the program is
brought into main storage if a useable copy is not already available. The
CALL macro also provides, via the USING option, the ability to pass
address parameters to the CALLed program.  If the CALLed module sets
the return code before returning, this return code will be available to the
user in the RTCD field. (Refer to RTCD)
       (1) FORMAT:
             Operation  =  CALL
             Size       =  not used
             Address    =  aaaaaaaa,USING,bbbb,.....
             Where:
             aaaaaaaa =  the name of the program that is being CALLed
                         or the name of the entry point in the CALLed
                         program.  The name must be padded with
                         blanks to eight bytes, if necessary.
             USING   =   indicates that address parameters are to be
                   passed to the CALLed program.   bbbb = addresses
                   of parameters (max of 8) to be passed to the CALLed
                   program.   The addresses must be in either the
                   constant storage area (0000-1999) or in Working
                   Storage area (2000-5999).

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
TG01  CALL         GETPMFSQ,USING,0000,0100
      COM   4      RTCD,SELF     0000
      GE           TG02
      COM   4      RTCD,SELF     0002
      GE           TG03
      GO           EOJ
TG02  MOVE  450    0100,J000
      WRITE        OUT1
      GO           TG01
TG03  MOVE  4      SELF,RTCD
      GO           EOJ


o. ENTER. This instruction permits the execution of a subroutine and, with
the use of EXIT, returns control to the instruction following the ENTER.
       (1) FORMAT:
           Operation = ENTER
           Size      = not used
           A Address = TG (tag) representing the next instruction to
                       be executed.
           B Address = not used


p. EXIT. This instruction reverses the actions performed by the ENTER
instruction and provides the exit from a subroutine.

NOTE: Executing an EXIT without a previous ENTER will cause
termination of the program with a completion code of 901.

       (1) FORMAT:
           Operation = EXIT
           Size      = not used
           A Address = not used
           B Address = not used

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      ENTER        TG01
      MOVE  2      A000,J000
      GO           TG02
TG01  READ         INP1,EOF
      EXIT
TG02  WRITE        OUT1


q. CVBZ   (Convert binary to zoned).  The format of A operand is changed
from binary to zoned, and the result is placed in the B operand.
       (1) FORMAT:
           Operation  =  CVBZ
           Size       =  Number of bytes (1-4) in A operand, a comma,
                         and number of bytes (1-10) in B operand
           A Address  =  Address of Sending area (binary)
           B Address  =  Address of Receiving area (zoned results)

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CVBZ  4,10   A000,0100     After execution:
*                                A000 = 499602D2
*                                0100 = F1F2F3F4F5F6F7F8F9F0
      CVBZ  1,2    1000,2000     After execution:
*                                1000 = 0A
*                                2000 = F1F0


r. CVZB (Convert zoned to binary).   The format of A operand is changed
from zoned to binary, and the result is placed in the B operand.  The A
operand is assumed to have the zoned format.  All zones are ignored
except the zone over the low-order digit.  The largest number that can be
converted is:  2,147,483,647; the smallest number is:  - 2,147,483,648.
       (1) FORMAT:
               Operation   =  CVZB
               Size        =  Number of bytes (1-4) in A operand, a comma,
                              and number of bytes (1-10) in B operand
               A Address   =  Address of Sending area (zoned)
               B Address   =  Address of Receiving area (binary results)

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CVZB  10,4   0000,0100     After execution:
*                                0000 = F1F2F3F4F5F6F7F8F9F0
*                                0100 = 499602D2
      CVZB  2,1    0100,0200     After execution:
*                                0100 = F1F0
*                                0200 = 0A


s. PACK. The format of the A operand is changed from zoned to packed,
and the result is placed in the B operand.  The A operand is assumed to
have the zoned format.  All zones are ignored execpt the zone over
the low-order digit.
       (1) FORMAT:
               Operation = PACK
               Size      = Number of bytes (1-16) in A operand, a comma,
                           and number of bytes (1-16) in B operand.
               A Address = Address of Sending area (zoned)
               B Address = Address of Receiving area (packed results)

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      PACK  5,3    A000,J000     After execution:
                                 A000 = F1 F2 F3 F4 F5
                                 J000 = 12 34 5F
      PACK  5,4    A000,J000     After execution:
                                 A000 = F1 F2 F3 F4 F5
                                 J000 = 00 12 34 5F
      PACK  5,2    A000,J000     After execution:
                                 A000 = F1 F2 F3 F4 F5
                                 J000 = 34 5F


t. UNPK (Unpack).    The format of the A operand is changed from packed
to zoned, and the result is placed in the B operand.
       (1) FORMAT:
              Operation = UNPK
              Size      = Number of bytes (1-16) in A operand, a comma,
                          and number of bytes (1-16) in B operand.
              A Address = Address of Sending area (packed)
              B Address = Address of Receiving area (zoned results)

       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      UNPK  3,5    J000,A000     After execution:
                                 A000 = 12 34 5F
                                 J000 = F1 F2 F3 F4 F5
      UNPK  3,6    J000,A000     After execution:
                                 A000 = 12 34 5F
                                 J000 = F0 F1 F2 F3 F4 F5
      UNPK  3,3    J000,A000     After execution:
                                 A000 = 12 34 5F
                                 J000 = F3 F4 F5


u. TRANS. (Translate).   This instruction translates bytes from one bit
configuration to another by the use of a 256-byte translate table. The hex
value of each byte to be translated is added to the left hand
end address of the table to generate the address within the table that
holds the translated equivalent.

       (1) FORMAT:
              Operation  =  TRANS
              Size       =  Number of bytes (1-256) to be translated
              A Address  =  Data to be translated and results of translation
              B Address  =  Address of 256-byte table to be used for
                            translation
       (2) Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CONS  1      0064          1
      CONS  9      0193          222222222
      CONS  9      0209          333333333
      CONS  8      0226          444444444
      CONS  10     0240          ABCDEFGHIJ
      TRANS 21     J000,0000

NOTE 1: CONS Area (0000-1999) is initialized to blanks
prior to storing user constants.

NOTE 2: Before execution, J000 = 0123456789bbAIJRSZ*$&
After execution, J000 = ABCDEFGHIJ11223344bbb

INDEXING
a. There are two index registers available (INX1 and INX2).  The size of
each register is four positions. To set or increment an index register, the
programmer must MOVE or ADD a value to either INX1 or INX2.  The
index registers may be assigned to A or B addresses by suffixing the
address with a dash   - and either 1 or 2 (see Address field of 4th line of
code below).  The index register will then be added to the address before
execution.  Numbers used when moving, adding, subtracting, or
comparing an index register must be four positions in size.

b. Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CONS  15     0000          AA1BB2CC3DD4EE5
      MOVE  4      SELF,INX1     0000
      MOVE  4      SELF,INX2     0000
TG01  MOVE  1      0002-1,P000-2
      COM   4      INX1,SELF     0012
      GE           TG02
      ADD    4     SELF,INX1     0003
      ADD    4     SELF,INX2     0001
      GO           TG01
TG02  PRINT        SKIP1
      GO           EOJ

Program would execute as follows:
        Line 1 initializes a constant
        Line 2 sets INX1 to zero
        Line 3 sets INX2 to zero
        Line 4 TG01 - moves data to print area
        Line 5 checks to see if all data has been moved to print area
        Line 6 goes to TG02 if all data moved
        Line 7 adds 3 to INX1 if all data not moved
        Line 8 adds 1 to INX2
        Line 9 goes back to beginning of program (MOVE)
        Line 10 TG02 - prints data
        Line 11 ends program

NOTE: Printed output = "12345"


SORT
a. General. The RRGENSRT, RELEASE, and RETURN subroutines
provide the linkage for RRGEN users to sort a file and define procedures
for handling these files both before and after they have been sorted.  Both
an Input and Output procedure MUST be coded.  The input and output
area for the sort is 5000-5999.   The user must branch to the tag SORT to
initiate the sort after all desired records have been RELEASEd to the Sort.
Only one sort may be executed within a RRGEN program.  A Region Size
of approximately 80K will be necessary if SORT is used.  Refer to the
section on RRGEN examples.

b. RRGENSRT. This subroutine provides the information that controls the
sort operation.  Control is received following this CALL when the last
record has been RETURNed to the user.  The user is responsible for
checking the return code (RTCD) for successful completion of the sort.
       (1) FORMAT:
               Operation = CALL
               Size      = not used
               Address   = RRGENSRT,USING,aaaa,bbbb,TGcc,TGdd
       Where:
               aaaa = location of the SORT statement *
                      within the CONS area.

               bbbb = location of the RECORD statement *
                      within the CONS area.
               TGcc = Tag of the user Input procedure.
               TGdd = Tag of the user Output procedure.

             * NOTE: See OS SORT/MERGE manual for description.

c. RELEASE. Transfers a record located at 5000 to the input phase of the
Sort operation.
       (1) FORMAT:
              Operation = CALL
              Size      = not used
              Address   = RELEASE

d. RETURN. Obtains individual records in sorted order from the final
phase of the sort and moves them to 5000-5999 for processing by the
user.  After the last record has been RETURNed, the sort passes control
to the instruction following the call of RRGENSRT.
       (1) FORMAT:
              Operation = CALL
              Size      = not used
              Address   = RETURN


BINARY SEARCH
a. General. The binary search subroutine performs a logical binary search
of a table for a specified argument.

b. When an equal key is found:
       (1) Index Register One (INX1) is set to the relative address of the
       table entry that produced the equal condition.
       (2) Control is returned to the user following the CALL instruction
       with the 'EQUAL' condition code set.

c. When an equal key is NOT found:
       (1) Contents of INX1 are unpredictable.
       (2) Control is returned to the user following the CALL instruction
       with the 'NOT EQUAL' condition code set.

d. FORMAT:
       Operation = CALL
       Size      = not used
       Address   = RRBINARY,USING,aaaa,bbbb,(c,d,e,f)
              where:
                     aaaa = CONS/Working Storage address for the
                            argument to be searched against the table.
                     bbbb = CONS/Working Storage address for the table
                            being searched.


                     c = Number of entries in the table.
                     d = Size of each entry.
                     e = Size of key within the entry (0-255).
                     f = Relative position of the key within the entry (first
                         position = 0, maximum = 255).

SYSTEM PROGRAMMER INSTRUCTIONS
a. The following instructions have been provided for programmers who
are familiar with IBM Assembly language.  The format of the instructions
are the same as for the RRGEN instruction set.  The description of their
operation can be found in the IBM Principles of Operation Manual.

b. Instructions.
       AP   (Add decimal)         MVN   (Move numerics)
       CP   (Compare decimal)     MVO   (Move with offset)
       SP   (Subtract decimal)    MVZ   (Move zones)
       NC   (Logical AND)
       OC   (Logical OR)
       XC   (Logical Exclusive OR)

c. Sample Coding.

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      XCONS 1      0000          0F
      XCONS 1      1000          F1
      NC    1      0000,1000     LOGICAL AND

After execution:  0000 = Hex 01      e.g. 0000 1111    1st operand
                  1000 = Hex F1           1111 0001    2nd operand
                                          0000 0001    Results in 1st

NOTE: Operands and Results are as described in the Principle of
       Operations manual.

TABLE OF ASSIGNED RECORD/WORK AREAS ADDRESSES

     AREA                     ADDRESS         SIZE
CARD record area              CD00-CD79       80
PRINT record area             P000-P131       132
INP1 record area              A000-A899       900
INP2 record area              B000-B899       900
INP3 record area              C000-C899       900
OUT1 record area              J000-J899       900
OUT2 record area              K000-K899       900
OUT3 record area              L000-L899       900
Constant Storage area *       0000-1999       2000
WORK AREA **                  2000-5999       4000
Result of Multiply or Divide  RS00-RS29       30
SELF constant storage ***     SELF            1772
RETURN CODE                   RTCD            4
INDEX 1                       INX1            4
INDEX 2                       INX2            4
JULIAN DATE (YYJJJ) ****      DATE            5
NUMERIC DATE (YYMMDD) ****    DATE            6
ALPHA DATE (DD_MMM_YY) ****   DATE            9


* NOTE: The Constant Area (0000-1999) is initialized to blanks prior to
storage of user-supplied CONS or XCONS.

** NOTE: The Work Area (2000-5999) is initialized to blanks.   This area is
also where the data block is written from or read into if direct access data
sets are being processed.

*** NOTE: This area is used by the program to store constants which
appear in an instruction parameter.

**** NOTE: The size determines which date is being addressed.  Table of
Standard RRGEN Return Codes

TABLE OF STANDARD RRGEN RETURN CODES

Return Code                         Meaning
   0000             Successful completion (unless changed by user).
   0008             Parameter errors.
   0009             EXIT executed without a corresponding ENTER.
   0010             8096 bytes available for storing user-generated
                    instructions has been exceeded.
   0011             Sort RECORD statement invalid (length > 900 or = 0).


RRGEN Program Examples

Example 1 - RRGEN program within a Job JCL stream

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890

//MYJOB    JOB
//STEP1    EXEC  RRGEN
//OUT1     DD  DSN=&&TESTDATA,UNIT=DISK,DISP=(NEW,PASS),
//             DCB=(RECFM=FB,LRECL=85,BLKSIZE=170,
//             SPACE=(TRK,(1,1))
//CARD     DD  *
//SYSIN    DD  *
      CONS  5      0000          00001
TG01  READ         CARD,EOJ      READ CARD
      MOVE  80     CD00,J000     MOVE CARD TO OUT1 RECORD AREA
      MOVE  5      0000,J080     MOVE COUNT TO END OF RECORD
      MOVE  85     J000,P000     MOVE OUT1 REC TO PRINT AREA
      PRINT        SKIP1         PRINT RECORD
      WRITE        OUT1          WRITE OUT1 RECORD
      ADD   5      SELF,0000     00001    ADD 1 TO COUNT
      GO           TG01          GO TO READ NEXT CARD
//STEP2    EXEC

Example 2 - RRGEN program with required JCL statements

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890

//STEP2    EXEC  RRGEN
//OUT1     DD  DSN=SP-A001,UNIT=DISK,DISP=(NEW,PASS),
//             DCB=(RECFM=FB,LRECL=450,BLKSIZE=2250),
//             SPACE=(TRK,(20))
//PMFMAST  DD  DSN=ATENLMAS,DISP=SHR,VOL=PRIVATE,UNIT=(DISK,1)
//         DD  DSN=ATOFFMAS,DISP=SHR,VOL=PRIVATE,UNIT=AFF=PMFMAST
//PMFGAIN  DD  DSN=ATEGAINS,DISP=SHR,VOL=PRIVATE,UNIT=(DISK,1)
//         DD  DSN=ATOGRAIN,DISP=SHR,VOL=PRIVATE,UNIT=AFF=PMFGAIN
//SYSIN    DD  *
      MOVE  8      SELF,0000     RCPACGEN USER PASSWORD
      MOVE  7      SELF,0008     SW1=NO   NO DELETE RECS
      MOVE  7      SELF,0015     SW2=YES  WANTS RECS UNPACKED
TG01  CALL         GETPMFSQ,USING,0000,1000,0008,0015
      COM   4      SELF,RTCD     0000     Q. NORMAL RETURN?
      GE           TG02                      YES IF GE IS TAKEN
      COM   4      SELF,RTCD     0002     Q. END OF DATA?
      GE           EOJ                       YES IF GE IS TAKEN
      MOVE  35     SELF,P000     OUT OF SEQUENCE OR BAD PARM
      PRINT        CHAN01
      GO           EOJ
TG02  COM   2      1014,SELF     99  SELECT SSN'S ENDING 99
      GNE          TG01
      MOVE  450    1000,J000     MOVE TO RECORD AREA
      WRITE        OUT1
      GO           TG01

Example 3 - RRGEN SORT subroutine

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890

      NOTE: "SORT" and "RECORD" statements must be preceded and
            followed by a space.

      CONS  24     0000           SORT FIELDS=(1,4,CH,A)
      CONS  26     0040           RECORD TYPE=A,LENGTH=100
*1    CALL         RRGENSRT,USING,0000,0040,TG05,TG09
*4    COM   4      RTCD,SELF     0000 CONTROL RECEIVED HERE AFTER
      GE           EOJ           THE LAST REC RETURNED
      MOVE  12     SELF,P000     SORT NO GOOD
      PRINT        SKIP1
      GO           EOJ
***   INPUT PROCEDURE   ***
*2
TG05  READ         INP1,SORT     AT EOF GO SORT RELEASE RECORDS
      MOVE  100    A000,5000     MOVE RECORD TO SORT AREA
      CALL         RELEASE       RELEASE RECORD AT 5000 TO SORT
      GO           TG05
***   OUTPUT PROCEDURE   ***
*3
TG09  CALL         RETURN        ASK SORT FOR A SORTED RECORD
      MOVE  100    5000,P000     MOVE SORTED RECORD TO PRINT AREA
      PRINT        SKIP1         PRINT RECORD
      GO           TG09          GO GET NEXT RECORD

* Execution Sequence
  1 will execute one time
  2 will execute n times ( n = nr of recs RELEASEd)
  3 will execute n times ( n = nr of recs RETURNed)
  4 will execute one time

Example 4 - RRGEN binary search routine

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890
      CONS  2      0000          WORK AREA FOR ARGUMENT
      CONS  30     0100          01JAN02FEB03MAR04APR05MAY06JUN
      CONS  30     0130          07JUL08AUG09SEP10OCT11NOV12DEC
TG01  READ         CARD,EOJ
      MOVE  2      CD05,0000     MOVE NUMERIC MONTH TO ARGUMENT
      CALL         RRBINARY,USING,0000,0100,(12,5,2,0)
      GNE          TG02
      MOVE  3      0102-1,P000   MOVE ALPHA MONTH TO PRINT AREA
      PRINT        SKIP1         PRINT ALPHA MONTH
      GO           TG01
TG02  MOVE  21     SELF,P000     INVALID NUMERIC MONTH
      PRINT        SKIP1
      GO           TG01

Example 5 - RRGEN PDS directory list

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890

//RRGEN    EXEC  PGM=RRGEN
//STEPLIB  DD  DSN=SSO.RRGEN.LOAD,DISP=SHR
//SYSOUT   DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//PRINT    DD  SYSOUT=*
//INP1     DD  DSN=SYS1.PROCLIB,DISP=SHR,
//             DSORG=PS,RECFM=F,LRECL=256,BLKSIZE=256
//OUT1     DD  SYSOUT=*,DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=0
//SYSIN    DD  *
      XCONS 1      0000          1F        ISOLATE USERDATA LENGTH
      XCONS 1      0001          80        ISOLATE ALIAS INDICATOR
      XCONS 1      0002          0F        SIGN HALF BYTE
      XCONS 8      0010          FFFFFFFFFFFFFFFF  HIGH VALUES
      CONS  40     0020          MEMBER     VV.MM CDATE  MDATE  TIME
      CONS  40     0060          SIZE   INIT  ID       XSIZE     XINIT
      XCONS 4      1000          00000000  USED BYTES
      XCONS 1      1004          00        PDS2INDC
      XCONS 1      1005          00        PDS2INDC
      XCONS 1      1006          0F        SPF STATS
      XCONS 1      1007          14        SPF XSTATS
      CONS  4      1008          0000
      XCONS 3      1012          000000    0HHMM0 AFTER MVO
      MOVE  80     0020,J000     HEADER
      WRITE        OUT1
      MOVE  80     0500,J000     CLEAR OUTPUT
      WRITE        OUT1
TG01  READ         INP1,EOJ      READ DIRECTORY BLOCK
      CVBZ  2,4    A000,1000     USED BYTES IN BLOCK
      MOVE  4      SELF,INX1     0002  SKIP USED BYTES IN BLOCK
TG05  COM   4      INX1,1000     INDEX >= USED?
      GE           TG01          YES
      GH           TG01          YES
      COM   8      A000-1,0010   MEMBER NAME = HIGH VALUES?
      GE           EOJ           YES, DONE
      MOVE  4      INX1,INX2     SAVE MEMBER NAME START
      ADD   4      SELF,INX1     0011  SKIP MEMBER NAME/TTR
      ENTER        TG10
      MOVE  1      A000-1,1004   PDS2INDC
      NC    1      1004,0000     <--- ISOLATE USERDATA LENGTH
      CVBZ  1,4    1004,1008
      ADD   4      SELF,INX1     0001  SKIP PDS2INDC
      ADD   4      1008,INX1     USERDATA LENGTH IN HALFWORDS
      ADD   4      1008,INX1     *2
      GO           TG05
TG10  MOVE  80     0500,J000     CLEAR OUTPUT
      MOVE  8      A000-2,J000   PDS2NAME
      MOVE  1      A000-1,1005   PDS2INDC
      NC    1      1005,0001     <--- ISOLATE ALIAS IDENTIFIER
      COM   1      1005,0001     ALIAS?
      GNE          TG15          NO
      MOVE  2      SELF,J007     -A
TG15  MOVE  1      A000-1,1005   PDS2INDC
      NC    1      1005,0000     <--- ISOLATE USERDATA LENGTH
      COM   1      1005,1006     SPF STATS?
      GE           TG20          YES
      COM   1      1005,1007     SPF XSTATS?
      GE           TG20          YES
      GO           TG99
TG20  ADD   4      SELF,INX2     0012  SKIP MEMBER NAME/TTR/INDICATOR
      CVBZ  1,2    A000-2,J011         ISPVERS
      MOVE  1      SELF,J013     .
      ADD   4      SELF,INX2     0001
      CVBZ  1,2    A000-2,J014         ISPMOD
      ADD   4      SELF,INX2     0004
      UNPK  3,5    A000-2,J017         ISPCDATE
      ADD   4      SELF,INX2     0004
      UNPK  3,5    A000-2,J024         ISPMDATE
      ADD   4      SELF,INX2     0003
      MOVE  2      A000-2,1013         ISPMTIME
      MVO   3,3    1012,1012     0HHMM0
      OC    1      1014,0002     0HHMMF
      UNPK  3,4    1012,J031     HHMM
      ADD   4      SELF,INX2     0002
      CVBZ  2,5    A000-2,J040         ISPCLINE
      ADD   4      SELF,INX2     0002
      CVBZ  2,5    A000-2,J047         ISPILINE
      ADD   4      SELF,INX2     0004
      MOVE  8      A000-2,J053         ISPUSRID
      COM   1      1005,1007     SPF XSTATS?
      GNE          TG99          NO
      ADD   4      SELF,INX2     0008
      CVBZ  4,8    A000-2,J062         ISPECLIN
      ADD   4      SELF,INX2     0004
      CVBZ  4,8    A000-2,J072         ISPEILIN
TG99  WRITE        OUT1
      EXIT

Example 6 - RRGEN Call JES2 separator routine

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890

//RRGEN    EXEC  PGM=RRGEN
//STEPLIB  DD  DSN=SSO.RRGEN.LOAD,DISP=SHR
//SYSOUT   DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//PRINT    DD  SYSOUT=*
//CARD     DD  *
JOHNNY
ROTTEN
//SYSIN    DD  *
      CONS  8      0000                    P1
      XCONS 4      0008          00000000  P2 LINE NUMBER (BINARY)
*                                          P3 LINE OUTPUT AREA
      CONS  40     0100
      CONS  40     0140
      CONS  30     0180
      XCONS 4      0210          00000008  P4 LENGTH(P1)  (BINARY)
      CONS  8      0214                    P5
      CONS  8      0222                    P6
      CONS  8      0230                    P7
      CONS  40     0300
      CONS  40     0340
      CONS  30     0380
*
TG05  READ         CARD,TG99
      MOVE  8      CD00,0000     8-BYTE STRING
      MOVE  4      SELF,INX1     0001
      ENTER        TG10
      GO           TG05
TG10  COM   4      INX1,SELF     0012
      GH           TG20
      CVZB  4,4    INX1,0008     P2    LINE 1-12
      MOVE  110    0300,0100
      CALL         IEFSD095,USING,0000,0008,0100,0210
      MOVE  110    0100,P000
      PRINT        SKIP1
      ADD   4      SELF,INX1     0001  NEXT LINE
      GO           TG10
TG20  MOVE  110    0300,P000
      PRINT        SKIP1         BLANK LINE
      EXIT
TG99  MOVE  4      SELF,RTCD     0000
      GO           EOJ

Example 7 - RRGEN Call SMS Data Set Attribute Retrieval

LOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS
0        1         2         3         4         5         6
123456789012345678901234567890123456789012345678901234567890

//RRGEN    EXEC  PGM=RRGEN
//STEPLIB  DD  DSN=SSO.RRGEN.LOAD,DISP=SHR
//SYSOUT   DD  SYSOUT=*
//PRINT    DD  SYSOUT=*
      XCONS 4      0000          00000000
      XCONS 4      0004          00000000
      XCONS 8      0008          0000000000000000
      XCONS 4      0016          0000002C
      CONS  40     0020          SSO.SMS.PARMLIB
      CONS  4      0060
      CONS  30     0100
      CONS  30     0130
      CONS  30     0160
      CONS  4      0200
      CALL         IGWASMS ,USING,0000,0004,0008,0016,0020,0100,0200
      MOVE  9      SELF,P000     STORCLAS=
      MOVE  8      0100,P009
      PRINT        SKIP1
      MOVE  9      SELF,P000     MGMTCLAS=
      MOVE  8      0130,P009
      PRINT        SKIP1
      MOVE  9      SELF,P000     DATACLAS=
      MOVE  8      0160,P009
      PRINT        SKIP1
      GO           EOJ

**************************** Bottom of Data ****************************
